<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blueberrycoder.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="动态库的链接过程 我之前写了简单的C++文件然后用Android Ndk构建除了一个动态库，通过readelf可以查看到这个动态库依赖了5个其他的动态库。根据以往的经验，一个工程依赖库应该是一个DAG（有向不循环图）。 123450x0000000000000001 (NEEDED)             Shared library: [libandroid.so]0x000000000000">
<meta property="og:type" content="article">
<meta property="og:title" content="Android动态链接技术二（动态库的加载过程）">
<meta property="og:url" content="https://blueberrycoder.github.io/2025/09/20/android/native_dynamic_process/index.html">
<meta property="og:site_name" content="Keep learning">
<meta property="og:description" content="动态库的链接过程 我之前写了简单的C++文件然后用Android Ndk构建除了一个动态库，通过readelf可以查看到这个动态库依赖了5个其他的动态库。根据以往的经验，一个工程依赖库应该是一个DAG（有向不循环图）。 123450x0000000000000001 (NEEDED)             Shared library: [libandroid.so]0x000000000000">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_dynamic_so_load.png">
<meta property="article:published_time" content="2025-09-20T02:01:42.000Z">
<meta property="article:modified_time" content="2025-10-02T13:43:05.964Z">
<meta property="article:author" content="blueberry">
<meta property="article:tag" content="code">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blueberrycoder.github.io/images/android/native_dynamic_so_load.png">


<link rel="canonical" href="https://blueberrycoder.github.io/2025/09/20/android/native_dynamic_process/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://blueberrycoder.github.io/2025/09/20/android/native_dynamic_process/","path":"2025/09/20/android/native_dynamic_process/","title":"Android动态链接技术二（动态库的加载过程）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android动态链接技术二（动态库的加载过程） | Keep learning</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Keep learning</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">动态库的链接过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">打开一个动态库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%BB%E6%89%BE%E5%8A%A0%E8%BD%BD%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">寻找加载整体流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80bfs%E5%AF%BB%E6%89%BE%E6%89%80%E6%9C%89%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="nav-number">4.</span> <span class="nav-text">一、BFS寻找所有的依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96elf%E6%96%87%E4%BB%B6"><span class="nav-number">4.1.</span> <span class="nav-text">读取ELF文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8A%A0%E8%BD%BD%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">5.</span> <span class="nav-text">二、加载动态库</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E9%A2%84%E9%93%BE%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">三、预链接</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E9%93%BE%E6%8E%A5"><span class="nav-number">7.</span> <span class="nav-text">四、链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-number">7.1.</span> <span class="nav-text">重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E6%9F%A5%E6%89%BE"><span class="nav-number">7.1.1.</span> <span class="nav-text">符号查找</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">五、调用构造器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">blueberry</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueberrycoder.github.io/2025/09/20/android/native_dynamic_process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blueberry">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep learning">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android动态链接技术二（动态库的加载过程） | Keep learning">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android动态链接技术二（动态库的加载过程）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-20 10:01:42" itemprop="dateCreated datePublished" datetime="2025-09-20T10:01:42+08:00">2025-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-02 21:43:05" itemprop="dateModified" datetime="2025-10-02T21:43:05+08:00">2025-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="动态库的链接过程">动态库的链接过程</h1>
<p>我之前写了简单的C++文件然后用Android
Ndk构建除了一个动态库，通过readelf可以查看到这个动态库依赖了5个其他的动态库。根据以往的经验，一个工程依赖库应该是一个DAG（有向不循环图）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [liblog.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libm.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libdl.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libc.so]</span><br></pre></td></tr></table></figure>
<pre>
<code class="mermaid">
sequenceDiagram
participant libdl 
participant linker
participant LoadTask
participant soinfo
participant ElfReader 


libdl-&gt;&gt;+libdl: dlopen
libdl-&gt;&gt;+linker: find_library
linker-&gt;&gt;linker: find_libraries
linker-&gt;&gt;linker: prepare LoadTask list
Note right of linker: Step 1. prepare loadtasks
linker-&gt;&gt;+LoadTask: create
Note over linker, LoadTask: Create a loadTask for current so that will be load 
LoadTask-&gt;&gt;-linker: return
Note right of linker: Step 2. bfs dependencies
loop bfs dependencies
  
    linker-&gt;&gt;linker: load_library
    linker-&gt;&gt;+soinfo: alloc
    soinfo-&gt;&gt;soinfo: generate_handle and add to ns
    soinfo-&gt;&gt;-linker: return
    linker-&gt;&gt;+ElfReader: construct 
    linker-&gt;&gt;+LoadTask: read
    LoadTask-&gt;&gt;+ElfReader: Read
    ElfReader-&gt;&gt;ElfReader:ReadElfHeader
    ElfReader-&gt;&gt;ElfReader:VerifyElfHeader
    ElfReader-&gt;&gt;ElfReader:ReadProgramHeaders
    ElfReader-&gt;&gt;ElfReader:CheckProgramHeaderAlignment
    ElfReader-&gt;&gt;ElfReader:ReadSectionHeaders
    ElfReader-&gt;&gt;ElfReader:ReadDynamicSection
    ElfReader-&gt;&gt;ElfReader:ReadPadSegmentNote
    ElfReader-&gt;&gt;-LoadTask: return
    LoadTask-&gt;&gt;linker: return
    linker-&gt;&gt;ElfReader: Get DT_NEEDED
    linker-&gt;&gt;LoadTask: create
    LoadTask-&gt;&gt;linker: return
    linker-&gt;&gt;linker: add to LoadTask list
    Note right of linker: Create a LoadTask for dependency and add it to list.

end
linker-&gt;&gt;linker: shuffle loadtasks
Note right of linker: Step 3. foreach soinfos to prelink libraries
loop loadtasks
    linker-&gt;&gt;soinfo:prelink_image
    Note right of soinfo: Get all information from elf dynamic section.
end
linker-&gt;&gt;linker:Construct the global group
Note right of linker: Step 4. Construct the global group
linker-&gt;&gt;linker: Step 5. Collect roots of local_groups
Note right of linker: Step 6. Link all local groups
loop local_group_roots
    linker-&gt;&gt;linker: walk_dependencies_tree
    Note right of linker: Collect soinfo to a local_group
    loop local_group
        linker-&gt;&gt;soinfo:link_image
        soinfo-&gt;&gt;soinfo:relocate
        Note right of soinfo: Relocate by rel&#x2F;rela
    end
end
linker-&gt;&gt;linker: mark linked
Note right of linker: Step 7. Mark libraries as linked
linker-&gt;&gt;soinfo: call_constructors
linker-&gt;&gt;-libdl: return handle
libdl-&gt;&gt;-libdl: return 

</code>
</pre>
<p>上面是一个动态库被加载的大致流程，我们有时候会使用dlopen一个外部库，然后通过dlsym根据符号查找某个函数进行调用。这里就通过dlopen这个函数的调用作为切入点来分析动态库的加载过程。</p>
<p>上图描述的动态库的加载流程粗略概括为：</p>
<ol type="1">
<li>获取调用方传入的要加载的库的名称、调用者的namespace。创建一个load_tasks列表。</li>
<li>根据库的名称创建一个LoadTask，放到遍历列表中。并开始遍历列表，通过LoadTask、创建soinfo、解析so文件，读取Shdrs、Phdrs、获取依赖库信息，然后对依赖的so库也创建一个LoadTask，并放到遍历列表load_tasks中，然后继续遍历列表。</li>
<li>打乱LoadTask列表的顺序、继续通过LoadTask预链接库。</li>
<li>根据Android中的namespace机制，构建一个local_group树，收集roots以便后续遍历。</li>
<li>遍历local_group树，对库进行重定位。</li>
<li>标记所有的库状态为已链接。调用每个库的构造器。</li>
</ol>
<h1 id="打开一个动态库">打开一个动态库</h1>
<p>dlopen函数的使用方式：<a
target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlopen.3.html"
class="uri">https://man7.org/linux/man-pages/man3/dlopen.3.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libdl.cpp</span></span><br><span class="line"><span class="comment">// 加载一个动态库，filename为库的名称，flag可以为：RTLD_LAZY、RTLD_NOW、RTLD_GLOBAL...</span></span><br><span class="line">__attribute__((__weak__))</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前函数的返回地址</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span>* caller_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __loader_dlopen(filename, flag, caller_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* __loader_dlopen(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">void</span>* caller_addr) &#123;</span><br><span class="line">  <span class="comment">// android_dlextinfo传nullptr</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dlopen_ext</span>(filename, flags, <span class="literal">nullptr</span>, caller_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">dlopen_ext</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">void</span>* caller_addr)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;g_dl_mutex)</span></span>;</span><br><span class="line">  g_linker_logger.<span class="built_in">ResetState</span>();</span><br><span class="line">  <span class="type">void</span>* result = <span class="built_in">do_dlopen</span>(filename, flags, extinfo, caller_addr);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    __bionic_format_dlerror(<span class="string">&quot;dlopen failed&quot;</span>, <span class="built_in">linker_get_error_buffer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">do_dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,  <span class="comment">// 要加载的库名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> flags, <span class="comment">// flag</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> android_dlextinfo* extinfo, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">void</span>* caller_addr  <span class="comment">// dlopen中的函数返回地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                )</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 找出调用者的soinfo（谁发起的dlopen)           </span></span><br><span class="line">     soinfo* <span class="type">const</span> caller = <span class="built_in">find_containing_library</span>(caller_addr); </span><br><span class="line">     <span class="comment">// 调用者的namespace</span></span><br><span class="line">     <span class="type">android_namespace_t</span>* ns = <span class="built_in">get_caller_namespace</span>(caller);   </span><br><span class="line">     ...</span><br><span class="line">       <span class="keyword">if</span> (g_is_asan &amp;&amp; translated_name != <span class="literal">nullptr</span> &amp;&amp; translated_name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="type">char</span> original_path[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">realpath</span>(name, original_path) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">file_exists</span>(translated_name_holder.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="comment">// 存放加载后的动态信息  </span></span><br><span class="line">        soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line">         <span class="comment">// 根据路径加载动态库 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_loaded_library_by_realpath</span>(ns, original_path, <span class="literal">true</span>, &amp;si)) &#123;</span><br><span class="line">          <span class="built_in">DL_WARN</span>(<span class="string">&quot;linker_asan dlopen NOT translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;: library already loaded&quot;</span>, name,</span><br><span class="line">                  translated_name_holder.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;       </span><br><span class="line">  ProtectedDataGuard guard;</span><br><span class="line">  <span class="comment">// 加载动态库</span></span><br><span class="line">  soinfo* si = <span class="built_in">find_library</span>(ns, translated_name, flags, extinfo, caller);</span><br><span class="line">  loading_trace.<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 转成handle</span></span><br><span class="line">    <span class="type">void</span>* handle = si-&gt;<span class="built_in">to_handle</span>();</span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;... dlopen calling constructors: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;</span>,</span><br><span class="line">           si-&gt;<span class="built_in">get_realpath</span>(), si-&gt;<span class="built_in">get_soname</span>(), handle);</span><br><span class="line">    <span class="comment">// 调用初始构造,调用DT_INIT节和DT_INIT_ARRAY的函数</span></span><br><span class="line">    si-&gt;<span class="built_in">call_constructors</span>();</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="寻找加载整体流程">寻找加载整体流程</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找动态库</span></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">find_library</span><span class="params">(<span class="type">android_namespace_t</span>* ns,<span class="comment">// caller所处的namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> <span class="type">char</span>* name,  <span class="comment">// 要加载的so名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> rtld_flags, <span class="comment">// flag</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> android_dlextinfo* extinfo, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            soinfo* needed_by <span class="comment">// caller的soinfo</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            )</span> </span>&#123;</span><br><span class="line">  soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    si = <span class="built_in">solist_get_somain</span>();</span><br><span class="line">    <span class="comment">// 加载目标库</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">find_libraries</span>(ns,</span><br><span class="line">                             needed_by,</span><br><span class="line">                             &amp;name,</span><br><span class="line">                             <span class="number">1</span>,</span><br><span class="line">                             &amp;si,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             rtld_flags,</span><br><span class="line">                             extinfo,</span><br><span class="line">                             <span class="literal">false</span> <span class="comment">/* add_as_children */</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">soinfo_unload</span>(si);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  si-&gt;<span class="built_in">increment_ref_count</span>();</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker.cpp</span></span><br><span class="line"><span class="comment">// 加载动态库，主要分下面几步：</span></span><br><span class="line"><span class="comment">// 1. 根据so的名称找到要加载的库，然后通过DT_NEED找出它的第一层依赖，然后创建加载任务，然后通过BFS遍历的方式继续加载二级、三级...依赖。</span></span><br><span class="line"><span class="comment">// 2. 打乱加载顺序，加载所有的so。</span></span><br><span class="line"><span class="comment">// 3. 预链接所有库。</span></span><br><span class="line"><span class="comment">// 5. 根据所有库的namespce构建构建查找树（影响符号寻找顺序）。</span></span><br><span class="line"><span class="comment">// 6. 遍历树，链接所有的动态库。</span></span><br><span class="line"><span class="comment">// add_as_children - add first-level loaded libraries (i.e. library_names[], but</span></span><br><span class="line"><span class="comment">// not their transitive dependencies) as children of the start_with library.</span></span><br><span class="line"><span class="comment">// This is false when find_libraries is called for dlopen(), when newly loaded</span></span><br><span class="line"><span class="comment">// libraries must form a disjoint tree.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_libraries</span><span class="params">(<span class="type">android_namespace_t</span>* ns,<span class="comment">// caller的ns</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    soinfo* start_with, <span class="comment">// caller的soinfo</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> library_names[], <span class="comment">// 就存放一个当前要加载的so名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">size_t</span> library_names_count, <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    soinfo* soinfos[],<span class="comment">// 输出soinfo</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::vector&lt;soinfo*&gt;* ld_preloads, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">size_t</span> ld_preloads_count, <span class="comment">// 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> rtld_flags, <span class="comment">// rtld_flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> android_dlextinfo* extinfo, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">bool</span> add_as_children, <span class="comment">// false</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::vector&lt;<span class="type">android_namespace_t</span>*&gt;* namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Step 0: prepare.</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">const</span> soinfo*, ElfReader&gt; readers_map;</span><br><span class="line">  <span class="comment">// 创建LoadTaskList; typedef std::vector&lt;LoadTask*&gt; LoadTaskList;</span></span><br><span class="line">  LoadTaskList load_tasks;</span><br><span class="line">  <span class="comment">// 首次这里的 library_names_count = 1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; library_names_count; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = library_names[i];</span><br><span class="line">    <span class="comment">// 为要加载的动态库创建一个加载任务</span></span><br><span class="line">    load_tasks.<span class="built_in">push_back</span>(LoadTask::<span class="built_in">create</span>(name, start_with, ns, &amp;readers_map));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历load_tasks，load_tasks允许扩张，可以将DT_NEED中的子库添加到load_tasks，这里是一种BFS遍历算法。</span></span><br><span class="line">  <span class="comment">// Step 1: expand the list of load_tasks to include</span></span><br><span class="line">  <span class="comment">// all DT_NEEDED libraries (do not load them just yet)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;load_tasks.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    LoadTask* task = load_tasks[i];</span><br><span class="line">    soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_dt_needed = needed_by != <span class="literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);</span><br><span class="line">    task-&gt;<span class="built_in">set_extinfo</span>(is_dt_needed ? <span class="literal">nullptr</span> : extinfo);</span><br><span class="line">    task-&gt;<span class="built_in">set_dt_needed</span>(is_dt_needed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: start from the namespace that is stored in the LoadTask. This namespace</span></span><br><span class="line">    <span class="comment">// is different from the current namespace when the LoadTask is for a transitive</span></span><br><span class="line">    <span class="comment">// dependency and the lib that created the LoadTask is not found in the</span></span><br><span class="line">    <span class="comment">// current namespace but in one of the linked namespaces.</span></span><br><span class="line">    <span class="type">android_namespace_t</span>* start_ns = <span class="built_in">const_cast</span>&lt;<span class="type">android_namespace_t</span>*&gt;(task-&gt;<span class="built_in">get_start_from</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;find_library_internal(ns=%s@%p): task=%s, is_dt_needed=%d&quot;</span>,</span><br><span class="line">           start_ns-&gt;<span class="built_in">get_name</span>(), start_ns, task-&gt;<span class="built_in">get_name</span>(), is_dt_needed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取ELF文件，将Shdrs和Phdrs等映射进来，并为依赖创建load_task放到load_tasks列表中。这是一种BFS遍历</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">find_library_internal</span>(start_ns, task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    <span class="keyword">if</span> (is_dt_needed) &#123;</span><br><span class="line">      needed_by-&gt;<span class="built_in">add_child</span>(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When ld_preloads is not null, the first</span></span><br><span class="line">    <span class="comment">// ld_preloads_count libs are in fact ld_preloads.</span></span><br><span class="line">    <span class="type">bool</span> is_ld_preload = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ld_preloads != <span class="literal">nullptr</span> &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;</span><br><span class="line">      ld_preloads-&gt;<span class="built_in">push_back</span>(si);</span><br><span class="line">      is_ld_preload = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (soinfos_count &lt; library_names_count) &#123;</span><br><span class="line">      soinfos[soinfos_count++] = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the new global group members to all initial namespaces. Do this secondary namespace setup</span></span><br><span class="line">    <span class="comment">// at the same time that libraries are added to their primary namespace so that the order of</span></span><br><span class="line">    <span class="comment">// global group members is the same in the every namespace. Only add a library to a namespace</span></span><br><span class="line">    <span class="comment">// once, even if it appears multiple times in the dependency graph.</span></span><br><span class="line">    <span class="keyword">if</span> (is_ld_preload || (si-&gt;<span class="built_in">get_dt_flags_1</span>() &amp; DF_1_GLOBAL) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; namespaces != <span class="literal">nullptr</span> &amp;&amp; !new_global_group_members.<span class="built_in">contains</span>(si)) &#123;</span><br><span class="line">        new_global_group_members.<span class="built_in">push_back</span>(si);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> linked_ns : *namespaces) &#123;</span><br><span class="line">          <span class="keyword">if</span> (si-&gt;<span class="built_in">get_primary_namespace</span>() != linked_ns) &#123;</span><br><span class="line">            linked_ns-&gt;<span class="built_in">add_soinfo</span>(si);</span><br><span class="line">            si-&gt;<span class="built_in">add_secondary_namespace</span>(linked_ns);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打乱加载的顺序</span></span><br><span class="line">  <span class="comment">// Step 2: Load libraries in random order (see b/24047022)</span></span><br><span class="line">  LoadTaskList load_list;</span><br><span class="line">  <span class="comment">// 找出还没有linked的so</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;](<span class="type">const</span> LoadTask* t) &#123;</span><br><span class="line">      <span class="keyword">return</span> t-&gt;<span class="built_in">get_soinfo</span>() == si;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp;</span><br><span class="line">        std::<span class="built_in">find_if</span>(load_list.<span class="built_in">begin</span>(), load_list.<span class="built_in">end</span>(), pred) == load_list.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">      load_list.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> reserved_address_recursive = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (extinfo) &#123;</span><br><span class="line">    reserved_address_recursive = extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!reserved_address_recursive) &#123;</span><br><span class="line">    <span class="comment">// 打乱加载顺序</span></span><br><span class="line">    <span class="comment">// Shuffle the load order in the normal case, but not if we are loading all</span></span><br><span class="line">    <span class="comment">// the libraries to a reserved address range.</span></span><br><span class="line">    <span class="built_in">shuffle</span>(&amp;load_list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up address space parameters.</span></span><br><span class="line">  address_space_params extinfo_params, default_params;</span><br><span class="line">  <span class="type">size_t</span> relro_fd_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (extinfo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123;</span><br><span class="line">      extinfo_params.start_addr = extinfo-&gt;reserved_addr;</span><br><span class="line">      extinfo_params.reserved_size = extinfo-&gt;reserved_size;</span><br><span class="line">      extinfo_params.must_use_address = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123;</span><br><span class="line">      extinfo_params.start_addr = extinfo-&gt;reserved_addr;</span><br><span class="line">      extinfo_params.reserved_size = extinfo-&gt;reserved_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_list) &#123;</span><br><span class="line">    address_space_params* address_space =</span><br><span class="line">        (reserved_address_recursive || !task-&gt;<span class="built_in">is_dt_needed</span>()) ? &amp;extinfo_params : &amp;default_params;</span><br><span class="line">    <span class="comment">// 加载so,可以通过address_space影响加载地址</span></span><br><span class="line">    <span class="keyword">if</span> (!task-&gt;<span class="built_in">load</span>(address_space)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The WebView loader uses RELRO sharing in order to promote page sharing of the large RELRO</span></span><br><span class="line">  <span class="comment">// segment, as it&#x27;s full of C++ vtables. Because MTE globals, by default, applies random tags to</span></span><br><span class="line">  <span class="comment">// each global variable, the RELRO segment is polluted and unique for each process. In order to</span></span><br><span class="line">  <span class="comment">// allow sharing, but still provide some protection, we use deterministic global tagging schemes</span></span><br><span class="line">  <span class="comment">// for DSOs that are loaded through android_dlopen_ext, such as those loaded by WebView.</span></span><br><span class="line">  <span class="type">bool</span> dlext_use_relro =</span><br><span class="line">      extinfo &amp;&amp; extinfo-&gt;flags &amp; (ANDROID_DLEXT_WRITE_RELRO | ANDROID_DLEXT_USE_RELRO);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预链接</span></span><br><span class="line">  <span class="comment">// Step 3: pre-link all DT_NEEDED libraries in breadth first order.</span></span><br><span class="line">  <span class="type">bool</span> any_memtag_stack = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; !si-&gt;<span class="built_in">prelink_image</span>(dlext_use_relro)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// si-&gt;memtag_stack() needs to be called after si-&gt;prelink_image() which populates</span></span><br><span class="line">    <span class="comment">// the dynamic section.</span></span><br><span class="line">    <span class="keyword">if</span> (si-&gt;<span class="built_in">memtag_stack</span>()) &#123;</span><br><span class="line">      any_memtag_stack = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;... load_library requesting stack MTE for: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;&quot;</span>,</span><br><span class="line">             si-&gt;<span class="built_in">get_realpath</span>(), si-&gt;<span class="built_in">get_soname</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">register_soinfo_tls</span>(si);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (any_memtag_stack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span>* cb = __libc_shared_globals()-&gt;memtag_stack_dlopen_callback) &#123;</span><br><span class="line">      <span class="built_in">cb</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// find_library is used by the initial linking step, so we communicate that we</span></span><br><span class="line">      <span class="comment">// want memtag_stack enabled to __libc_init_mte.</span></span><br><span class="line">      __libc_shared_globals()-&gt;initial_memtag_stack_abi = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4: Construct the global group. DF_1_GLOBAL bit is force set for LD_PRELOADed libs because</span></span><br><span class="line">  <span class="comment">// they must be added to the global group. Note: The DF_1_GLOBAL bit for a library is normally set</span></span><br><span class="line">  <span class="comment">// in step 3.</span></span><br><span class="line">  <span class="keyword">if</span> (ld_preloads != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; si : *ld_preloads) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_dt_flags_1</span>(si-&gt;<span class="built_in">get_dt_flags_1</span>() | DF_1_GLOBAL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 收集所有local_groups的根</span></span><br><span class="line">  <span class="comment">// Step 5: Collect roots of local_groups.</span></span><br><span class="line">  <span class="comment">// Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.</span></span><br><span class="line">  <span class="comment">// Here we collect new roots to link them separately later on. Note that we need to avoid</span></span><br><span class="line">  <span class="comment">// collecting duplicates. Also the order is important. They need to be linked in the same</span></span><br><span class="line">  <span class="comment">// BFS order we link individual libraries.</span></span><br><span class="line">  std::vector&lt;soinfo*&gt; local_group_roots;</span><br><span class="line">  <span class="keyword">if</span> (start_with != <span class="literal">nullptr</span> &amp;&amp; add_as_children) &#123;</span><br><span class="line">    local_group_roots.<span class="built_in">push_back</span>(start_with);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(soinfos_count == <span class="number">1</span>);</span><br><span class="line">    local_group_roots.<span class="built_in">push_back</span>(soinfos[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">    <span class="type">bool</span> is_dt_needed = needed_by != <span class="literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);</span><br><span class="line">    <span class="type">android_namespace_t</span>* needed_by_ns =</span><br><span class="line">        is_dt_needed ? needed_by-&gt;<span class="built_in">get_primary_namespace</span>() : ns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; si-&gt;<span class="built_in">get_primary_namespace</span>() != needed_by_ns) &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(local_group_roots.<span class="built_in">begin</span>(), local_group_roots.<span class="built_in">end</span>(), si);</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;</span>,</span><br><span class="line">             si-&gt;<span class="built_in">get_realpath</span>(),</span><br><span class="line">             si,</span><br><span class="line">             si-&gt;<span class="built_in">get_primary_namespace</span>()-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">             si-&gt;<span class="built_in">get_primary_namespace</span>(),</span><br><span class="line">             needed_by == <span class="literal">nullptr</span> ? <span class="string">&quot;(nullptr)&quot;</span> : needed_by-&gt;<span class="built_in">get_realpath</span>(),</span><br><span class="line">             needed_by,</span><br><span class="line">             ns-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">             ns,</span><br><span class="line">             needed_by_ns-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">             needed_by_ns,</span><br><span class="line">             it == local_group_roots.<span class="built_in">end</span>() ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (it == local_group_roots.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        local_group_roots.<span class="built_in">push_back</span>(si);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 6: Link all local groups</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> root : local_group_roots) &#123;</span><br><span class="line">    <span class="type">soinfo_list_t</span> local_group;</span><br><span class="line">    <span class="type">android_namespace_t</span>* local_group_ns = root-&gt;<span class="built_in">get_primary_namespace</span>();</span><br><span class="line"><span class="comment">// 从各个group的root开始遍历，并放到local_group列表</span></span><br><span class="line">    <span class="built_in">walk_dependencies_tree</span>(root,</span><br><span class="line">      [&amp;] (soinfo* si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (local_group_ns-&gt;<span class="built_in">is_accessible</span>(si)) &#123;</span><br><span class="line">          local_group.<span class="built_in">push_back</span>(si);</span><br><span class="line">          <span class="keyword">return</span> kWalkContinue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> kWalkSkip;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">soinfo_list_t</span> global_group = local_group_ns-&gt;<span class="built_in">get_global_group</span>();</span><br><span class="line">    <span class="comment">// 创建符号寻找器 SymbolLookupList</span></span><br><span class="line">    <span class="function">SymbolLookupList <span class="title">lookup_list</span><span class="params">(global_group, local_group)</span></span>;</span><br><span class="line">    soinfo* local_group_root = local_group.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> linked = local_group.<span class="built_in">visit</span>([&amp;](soinfo* si) &#123;</span><br><span class="line">      <span class="comment">// Even though local group may contain accessible soinfos from other namespaces</span></span><br><span class="line">      <span class="comment">// we should avoid linking them (because if they are not linked -&gt; they</span></span><br><span class="line">      <span class="comment">// are in the local_group_roots and will be linked later).</span></span><br><span class="line">      <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; si-&gt;<span class="built_in">get_primary_namespace</span>() == local_group_ns) &#123;</span><br><span class="line">        <span class="type">const</span> android_dlextinfo* link_extinfo = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (si == soinfos[<span class="number">0</span>] || reserved_address_recursive) &#123;</span><br><span class="line">          <span class="comment">// Only forward extinfo for the first library unless the recursive</span></span><br><span class="line">          <span class="comment">// flag is set.</span></span><br><span class="line">          link_extinfo = extinfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__libc_shared_globals()-&gt;load_hook) &#123;</span><br><span class="line">          __libc_shared_globals()-&gt;<span class="built_in">load_hook</span>(si-&gt;load_bias, si-&gt;phdr, si-&gt;phnum);</span><br><span class="line">        &#125;</span><br><span class="line">        lookup_list.<span class="built_in">set_dt_symbolic_lib</span>(si-&gt;has_DT_SYMBOLIC ? si : <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="keyword">if</span> (!si-&gt;<span class="built_in">link_image</span>(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) ||</span><br><span class="line">            !<span class="built_in">get_cfi_shadow</span>()-&gt;<span class="built_in">AfterLoad</span>(si, <span class="built_in">solist_get_head</span>())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!linked) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表即soinfo为linked。</span></span><br><span class="line">  <span class="comment">// Step 7: Mark all load_tasks as linked and increment refcounts</span></span><br><span class="line">  <span class="comment">// for references between load_groups (at this point it does not matter if</span></span><br><span class="line">  <span class="comment">// referenced load_groups were loaded by previous dlopen or as part of this</span></span><br><span class="line">  <span class="comment">// one on step 6)</span></span><br><span class="line">  <span class="keyword">if</span> (start_with != <span class="literal">nullptr</span> &amp;&amp; add_as_children) &#123;</span><br><span class="line">    start_with-&gt;<span class="built_in">set_linked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    si-&gt;<span class="built_in">set_linked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">    <span class="keyword">if</span> (needed_by != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        needed_by != start_with &amp;&amp;</span><br><span class="line">        needed_by-&gt;<span class="built_in">get_local_group_root</span>() != si-&gt;<span class="built_in">get_local_group_root</span>()) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">increment_ref_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>find_libraries函数几乎包含了整个动态的加载阶段，它分了7步来加载动态，我们主要看下核心的一些步骤。</p>
<h1 id="一bfs寻找所有的依赖">一、BFS寻找所有的依赖</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">find_library_internal</span><span class="params">(<span class="type">android_namespace_t</span>* ns, <span class="comment">// 名称空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  LoadTask* task,<span class="comment">//当前加载的任务</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  LoadTaskList* load_tasks, <span class="comment">// 任务列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> rtld_flags)</span> </span>&#123;</span><br><span class="line">  soinfo* candidate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 看看当前的名称空间是否已经能访问到这个so。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">find_loaded_library_by_soname</span>(ns, task-&gt;<span class="built_in">get_name</span>(), <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>,</span><br><span class="line">                                    &amp;candidate)) &#123;</span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;find_library_internal(ns=%s, task=%s): Already loaded (by soname): %s&quot;</span>,</span><br><span class="line">           ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), candidate-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">    task-&gt;<span class="built_in">set_soinfo</span>(candidate);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Library might still be loaded, the accurate detection</span></span><br><span class="line">  <span class="comment">// of this fact is done by load_library.</span></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;[ \&quot;%s\&quot; find_loaded_library_by_soname failed (*candidate=%s@%p). Trying harder... ]&quot;</span>,</span><br><span class="line">           task-&gt;<span class="built_in">get_name</span>(), candidate == <span class="literal">nullptr</span> ? <span class="string">&quot;n/a&quot;</span> : candidate-&gt;<span class="built_in">get_realpath</span>(), candidate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载这个动态库</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">load_library</span>(ns, task, zip_archive_cache, load_tasks, rtld_flags,</span><br><span class="line">                   <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(dimitry): workaround for http://b/26394120 (the exempt-list)</span></span><br><span class="line">  <span class="keyword">if</span> (ns-&gt;<span class="built_in">is_exempt_list_enabled</span>() &amp;&amp; <span class="built_in">is_exempt_lib</span>(ns, task-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_needed_by</span>())) &#123;</span><br><span class="line">    <span class="comment">// For the libs in the exempt-list, switch to the default namespace and then</span></span><br><span class="line">    <span class="comment">// try the load again from there. The library could be loaded from the</span></span><br><span class="line">    <span class="comment">// default namespace or from another namespace (e.g. runtime) that is linked</span></span><br><span class="line">    <span class="comment">// from the default namespace.</span></span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;find_library_internal(ns=%s, task=%s): Exempt system library - trying namespace %s&quot;</span>,</span><br><span class="line">           ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), g_default_namespace.<span class="built_in">get_name</span>());</span><br><span class="line">    ns = &amp;g_default_namespace;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">load_library</span>(ns, task, zip_archive_cache, load_tasks, rtld_flags,</span><br><span class="line">                     <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// END OF WORKAROUND</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// if a library was not found - look into linked namespaces</span></span><br><span class="line">  <span class="comment">// preserve current dlerror in the case it fails.</span></span><br><span class="line">  DlErrorRestorer dlerror_restorer;</span><br><span class="line">  <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;find_library_internal(ns=%s, task=%s): Trying %zu linked namespaces&quot;</span>,</span><br><span class="line">         ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), ns-&gt;<span class="built_in">linked_namespaces</span>().<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; linked_namespace : ns-&gt;<span class="built_in">linked_namespaces</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_library_in_linked_namespace</span>(linked_namespace, task)) &#123;</span><br><span class="line">      <span class="comment">// Library is already loaded.</span></span><br><span class="line">      <span class="keyword">if</span> (task-&gt;<span class="built_in">get_soinfo</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// n.b. This code path runs when find_library_in_linked_namespace found an already-loaded</span></span><br><span class="line">        <span class="comment">// library by soname. That should only be possible with a exempt-list lookup, where we</span></span><br><span class="line">        <span class="comment">// switch the namespace, because otherwise, find_library_in_linked_namespace is duplicating</span></span><br><span class="line">        <span class="comment">// the soname scan done in this function&#x27;s first call to find_loaded_library_by_soname.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">load_library</span>(linked_namespace.<span class="built_in">linked_namespace</span>(), task, zip_archive_cache, load_tasks,</span><br><span class="line">                       rtld_flags, <span class="literal">false</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">        <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;find_library_internal(ns=%s, task=%s): Found in linked namespace %s&quot;</span>,</span><br><span class="line">               ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), linked_namespace.<span class="built_in">linked_namespace</span>()-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">load_library</span><span class="params">(<span class="type">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTask* task,</span></span></span><br><span class="line"><span class="params"><span class="function">                         ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name = task-&gt;<span class="built_in">get_name</span>();</span><br><span class="line">  soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">  <span class="type">const</span> android_dlextinfo* extinfo = task-&gt;<span class="built_in">get_extinfo</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extinfo != <span class="literal">nullptr</span> &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">off64_t</span> file_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != <span class="number">0</span>) &#123;</span><br><span class="line">      file_offset = extinfo-&gt;library_fd_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string realpath;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">realpath_fd</span>(extinfo-&gt;library_fd, &amp;realpath)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_first_stage_init</span>()) &#123;</span><br><span class="line">        <span class="built_in">DL_WARN</span>(<span class="string">&quot;unable to get realpath for the library \&quot;%s\&quot; by extinfo-&gt;library_fd. &quot;</span></span><br><span class="line">                <span class="string">&quot;Will use given name.&quot;</span>,</span><br><span class="line">                name);</span><br><span class="line">      &#125;</span><br><span class="line">      realpath = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">set_fd</span>(extinfo-&gt;library_fd, <span class="literal">false</span>);</span><br><span class="line">    task-&gt;<span class="built_in">set_file_offset</span>(file_offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">load_library</span>(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">         <span class="string">&quot;load_library(ns=%s, task=%s, flags=0x%x, search_linked_namespaces=%d): calling &quot;</span></span><br><span class="line">         <span class="string">&quot;open_library&quot;</span>,</span><br><span class="line">         ns-&gt;<span class="built_in">get_name</span>(), name, rtld_flags, search_linked_namespaces);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the file.</span></span><br><span class="line">  <span class="type">off64_t</span> file_offset;</span><br><span class="line">  std::string realpath;</span><br><span class="line">  <span class="comment">// 寻找到ELF文件并打开得到fd。</span></span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open_library</span>(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;<span class="built_in">is_dt_needed</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (needed_by-&gt;<span class="built_in">is_main_executable</span>()) &#123;</span><br><span class="line">        <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found: needed by main executable&quot;</span>, name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found: needed by %s in namespace %s&quot;</span>, name,</span><br><span class="line">                    needed_by-&gt;<span class="built_in">get_realpath</span>(), task-&gt;<span class="built_in">get_start_from</span>()-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将ELF文件的fd设置给task</span></span><br><span class="line">  task-&gt;<span class="built_in">set_fd</span>(fd, <span class="literal">true</span>);</span><br><span class="line">  task-&gt;<span class="built_in">set_file_offset</span>(file_offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">load_library</span>(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">load_library</span><span class="params">(<span class="type">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTask* task,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::string&amp; realpath,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="type">off64_t</span> file_offset = task-&gt;<span class="built_in">get_file_offset</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name = task-&gt;<span class="built_in">get_name</span>();</span><br><span class="line">  <span class="type">const</span> android_dlextinfo* extinfo = task-&gt;<span class="built_in">get_extinfo</span>();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Check for symlink and other situations where</span></span><br><span class="line">  <span class="comment">// file can have different names, unless ANDROID_DLEXT_FORCE_LOAD is set</span></span><br><span class="line">  <span class="keyword">if</span> (extinfo == <span class="literal">nullptr</span> || (extinfo-&gt;flags &amp; ANDROID_DLEXT_FORCE_LOAD) == <span class="number">0</span>) &#123;</span><br><span class="line">    soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_loaded_library_by_inode</span>(ns, file_stat, file_offset, search_linked_namespaces, &amp;si)) &#123;</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;load_library(ns=%s, task=%s): Already loaded under different name/path \&quot;%s\&quot; - &quot;</span></span><br><span class="line">             <span class="string">&quot;will return existing soinfo&quot;</span>,</span><br><span class="line">             ns-&gt;<span class="built_in">get_name</span>(), name, si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      task-&gt;<span class="built_in">set_soinfo</span>(si);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rtld_flags &amp; RTLD_NOLOAD) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; wasn&#x27;t loaded and RTLD_NOLOAD prevented it&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">statfs</span> fs_stat;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">fstatfs</span>(task-&gt;<span class="built_in">get_fd</span>(), &amp;fs_stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;unable to fstatfs file for the library \&quot;%s\&quot;: %m&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not check accessibility using realpath if fd is located on tmpfs</span></span><br><span class="line">  <span class="comment">// this enables use of memfd_create() for apps</span></span><br><span class="line">  <span class="keyword">if</span> ((fs_stat.f_type != TMPFS_MAGIC) &amp;&amp; (!ns-&gt;<span class="built_in">is_accessible</span>(realpath))) &#123;</span><br><span class="line">    <span class="comment">// TODO(dimitry): workaround for http://b/26394120 - the exempt-list</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> soinfo* needed_by = task-&gt;<span class="built_in">is_dt_needed</span>() ? task-&gt;<span class="built_in">get_needed_by</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_exempt_lib</span>(ns, name, needed_by)) &#123;</span><br><span class="line">      <span class="comment">// print warning only if needed by non-system library</span></span><br><span class="line">      <span class="keyword">if</span> (needed_by == <span class="literal">nullptr</span> || !<span class="built_in">is_system_library</span>(needed_by-&gt;<span class="built_in">get_realpath</span>())) &#123;</span><br><span class="line">        <span class="type">const</span> soinfo* needed_or_dlopened_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* sopath = needed_or_dlopened_by == <span class="literal">nullptr</span> ? <span class="string">&quot;(unknown)&quot;</span> :</span><br><span class="line">                                                      needed_or_dlopened_by-&gt;<span class="built_in">get_realpath</span>();</span><br><span class="line">        <span class="comment">// is_exempt_lib() always returns true for targetSdkVersion &lt; 24,</span></span><br><span class="line">        <span class="comment">// so no need to check the return value of DL_ERROR_AFTER().</span></span><br><span class="line">        <span class="comment">// We still call it rather than DL_WARN() to get the extra clarification.</span></span><br><span class="line">        <span class="built_in">DL_ERROR_AFTER</span>(<span class="number">24</span>, <span class="string">&quot;library \&quot;%s\&quot; (\&quot;%s\&quot;) needed or dlopened by \&quot;%s\&quot; &quot;</span></span><br><span class="line">                       <span class="string">&quot;is not accessible by namespace \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                       name, realpath.<span class="built_in">c_str</span>(), sopath, ns-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">        <span class="built_in">add_dlwarning</span>(sopath, <span class="string">&quot;unauthorized access to&quot;</span>,  name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// do not load libraries if they are not accessible for the specified namespace.</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* needed_or_dlopened_by = task-&gt;<span class="built_in">get_needed_by</span>() == <span class="literal">nullptr</span> ?</span><br><span class="line">                                          <span class="string">&quot;(unknown)&quot;</span> :</span><br><span class="line">                                          task-&gt;<span class="built_in">get_needed_by</span>()-&gt;<span class="built_in">get_realpath</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; needed or dlopened by \&quot;%s\&quot; is not accessible for the namespace \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">             name, needed_or_dlopened_by, ns-&gt;<span class="built_in">get_name</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// do not print this if a library is in the list of shared libraries for linked namespaces</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">maybe_accessible_via_namespace_links</span>(ns, name)) &#123;</span><br><span class="line">        <span class="built_in">DL_WARN</span>(<span class="string">&quot;library \&quot;%s\&quot; (\&quot;%s\&quot;) needed or dlopened by \&quot;%s\&quot; is not accessible for the&quot;</span></span><br><span class="line">                <span class="string">&quot; namespace: [name=\&quot;%s\&quot;, ld_library_paths=\&quot;%s\&quot;, default_library_paths=\&quot;%s\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot; permitted_paths=\&quot;%s\&quot;]&quot;</span>,</span><br><span class="line">                name, realpath.<span class="built_in">c_str</span>(),</span><br><span class="line">                needed_or_dlopened_by,</span><br><span class="line">                ns-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">                android::base::<span class="built_in">Join</span>(ns-&gt;<span class="built_in">get_ld_library_paths</span>(), <span class="string">&#x27;:&#x27;</span>).<span class="built_in">c_str</span>(),</span><br><span class="line">                android::base::<span class="built_in">Join</span>(ns-&gt;<span class="built_in">get_default_library_paths</span>(), <span class="string">&#x27;:&#x27;</span>).<span class="built_in">c_str</span>(),</span><br><span class="line">                android::base::<span class="built_in">Join</span>(ns-&gt;<span class="built_in">get_permitted_paths</span>(), <span class="string">&#x27;:&#x27;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建出soinfo</span></span><br><span class="line">  soinfo* si = <span class="built_in">soinfo_alloc</span>(ns, realpath.<span class="built_in">c_str</span>(), &amp;file_stat, file_offset, rtld_flags);</span><br><span class="line">  <span class="comment">// 将soinfo设置给加载任务</span></span><br><span class="line">  task-&gt;<span class="built_in">set_soinfo</span>(si);</span><br><span class="line">  <span class="comment">// 注意：创建ELFReader，读取ELF文件.</span></span><br><span class="line">  <span class="comment">// Read the ELF header and some of the segments.</span></span><br><span class="line">  <span class="keyword">if</span> (!task-&gt;<span class="built_in">read</span>(realpath.<span class="built_in">c_str</span>(), file_stat.st_size)) &#123;</span><br><span class="line">    task-&gt;<span class="built_in">remove_cached_elf_reader</span>();</span><br><span class="line">    task-&gt;<span class="built_in">set_soinfo</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">soinfo_free</span>(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find and set DT_RUNPATH, DT_SONAME, and DT_FLAGS_1.</span></span><br><span class="line">  <span class="comment">// Note that these field values are temporary and are</span></span><br><span class="line">  <span class="comment">// going to be overwritten on soinfo::prelink_image</span></span><br><span class="line">  <span class="comment">// with values from PT_LOAD segments.</span></span><br><span class="line">  <span class="type">const</span> ElfReader&amp; elf_reader = task-&gt;<span class="built_in">get_elf_reader</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)* d = elf_reader.<span class="built_in">dynamic</span>(); d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_RUNPATH) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_dt_runpath</span>(elf_reader.<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置SoName</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_SONAME) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_soname</span>(elf_reader.<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We need to identify a DF_1_GLOBAL library early so we can link it to namespaces.</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_FLAGS_1) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_dt_flags_1</span>(d-&gt;d_un.d_val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__ANDROID__)</span></span><br><span class="line">  <span class="comment">// Bionic on the host currently uses some Android prebuilts, which don&#x27;t set</span></span><br><span class="line">  <span class="comment">// DT_RUNPATH with any relative paths, so they can&#x27;t find their dependencies.</span></span><br><span class="line">  <span class="comment">// b/118058804</span></span><br><span class="line">  <span class="keyword">if</span> (si-&gt;<span class="built_in">get_dt_runpath</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    si-&gt;<span class="built_in">set_dt_runpath</span>(<span class="string">&quot;$ORIGIN/../lib64:$ORIGIN/lib64&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取dynamic段</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)* d = elf_reader.<span class="built_in">dynamic</span>(); d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123; <span class="comment">// 读取DT_NEEDED,获取依赖列表</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">fix_dt_needed</span>(elf_reader.<span class="built_in">get_string</span>(d-&gt;d_un.d_val), elf_reader.<span class="built_in">name</span>());</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;load_library(ns=%s, task=%s): Adding DT_NEEDED task: %s&quot;</span>,</span><br><span class="line">             ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), name);</span><br><span class="line">      <span class="comment">// 对依赖的库，创建一个LoadTask，并加入到load_tasks中。从而导致循环不结束。（BFS遍历算法）。</span></span><br><span class="line">      load_tasks-&gt;<span class="built_in">push_back</span>(LoadTask::<span class="built_in">create</span>(name, si, ns, task-&gt;<span class="built_in">get_readers_map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建soinfo，并添加到solist中</span></span><br><span class="line"><span class="function">soinfo* <span class="title">soinfo_alloc</span><span class="params">(<span class="type">android_namespace_t</span>* ns, <span class="type">const</span> <span class="type">char</span>* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="keyword">struct</span> stat* file_stat, <span class="type">off64_t</span> file_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint32_t</span> rtld_flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= PATH_MAX) &#123;</span><br><span class="line">    <span class="built_in">async_safe_fatal</span>(<span class="string">&quot;library name \&quot;%s\&quot; too long&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;name %s: allocating soinfo for ns=%p&quot;</span>, name, ns);</span><br><span class="line"></span><br><span class="line">  soinfo* si = <span class="built_in">new</span> (g_soinfo_allocator.<span class="built_in">alloc</span>()) <span class="built_in">soinfo</span>(ns, name, file_stat,</span><br><span class="line">                                                       file_offset, rtld_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将soinfo增加到solist中</span></span><br><span class="line">  <span class="built_in">solist_add_soinfo</span>(si);</span><br><span class="line"><span class="comment">// 生成handle</span></span><br><span class="line">  si-&gt;<span class="built_in">generate_handle</span>();</span><br><span class="line">  ns-&gt;<span class="built_in">add_soinfo</span>(si);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;name %s: allocated soinfo @ %p&quot;</span>, name, si);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取elf文件">读取ELF文件</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linkerphdr.cpp</span></span><br><span class="line"><span class="comment">// 读取ELF文件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::Read</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> fd, <span class="type">off64_t</span> file_offset, <span class="type">off64_t</span> file_size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (did_read_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  name_ = name;</span><br><span class="line">  fd_ = fd;</span><br><span class="line">  file_offset_ = file_offset;</span><br><span class="line">  file_size_ = file_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ReadElfHeader</span>() &amp;&amp; <span class="comment">// 读取ELF文件头</span></span><br><span class="line">      <span class="built_in">VerifyElfHeader</span>() &amp;&amp; <span class="comment">// 验证ELF文件头</span></span><br><span class="line">      <span class="built_in">ReadProgramHeaders</span>() &amp;&amp; <span class="comment">// 映射Phdrs</span></span><br><span class="line">      <span class="built_in">CheckProgramHeaderAlignment</span>() &amp;&amp; <span class="comment">// 对齐</span></span><br><span class="line">      <span class="built_in">ReadSectionHeaders</span>() &amp;&amp; <span class="comment">// 映射Shdrs</span></span><br><span class="line">      <span class="built_in">ReadDynamicSection</span>() &amp;&amp; <span class="comment">// 得到Dynamic信息</span></span><br><span class="line">      <span class="built_in">ReadPadSegmentNote</span>()) &#123; <span class="comment">// pad</span></span><br><span class="line">    did_read_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kPageSize == <span class="number">16</span>*<span class="number">1024</span> &amp;&amp; min_align_ == <span class="number">4096</span>) &#123;</span><br><span class="line">    <span class="comment">// This prop needs to be read on 16KiB devices for each ELF where min_palign is 4KiB.</span></span><br><span class="line">    <span class="comment">// It cannot be cached since the developer may toggle app compat on/off.</span></span><br><span class="line">    <span class="comment">// This check will be removed once app compat is made the default on 16KiB devices.</span></span><br><span class="line">    should_use_16kib_app_compat_ =</span><br><span class="line">        ::android::base::<span class="built_in">GetBoolProperty</span>(<span class="string">&quot;bionic.linker.16kb.app_compat.enabled&quot;</span>, <span class="literal">false</span>) ||</span><br><span class="line">        <span class="built_in">get_16kb_appcompat_mode</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> did_read_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件头</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">ssize_t</span> rc = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">pread64</span>(fd_, &amp;header_, <span class="built_in">sizeof</span>(header_), file_offset_));</span><br><span class="line">  <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t read file \&quot;%s\&quot;: %s&quot;</span>, name_.<span class="built_in">c_str</span>(), <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="built_in">sizeof</span>(header_)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is too small to be an ELF executable: only found %zd bytes&quot;</span>, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rc));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证ELF文件头</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::VerifyElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 对比文件的魔术看是否匹配   </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(header_.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has bad ELF magic: %02x%02x%02x%02x&quot;</span>, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">           header_.e_ident[<span class="number">0</span>], header_.e_ident[<span class="number">1</span>], header_.e_ident[<span class="number">2</span>], header_.e_ident[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看位宽是否匹配</span></span><br><span class="line">  <span class="comment">// Try to give a clear diagnostic for ELF class mismatches, since they&#x27;re</span></span><br><span class="line">  <span class="comment">// an easy mistake to make during the 32-bit/64-bit transition period.</span></span><br><span class="line">  <span class="type">int</span> elf_class = header_.e_ident[EI_CLASS];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS64) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS32) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is 32-bit instead of 64-bit&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS32) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS64) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is 64-bit instead of 32-bit&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 查看字节序是否匹配</span></span><br><span class="line">  <span class="keyword">if</span> (header_.e_ident[EI_DATA] != ELFDATA2LSB) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; not little-endian: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), header_.e_ident[EI_DATA]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_type != ET_DYN) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_type: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), header_.e_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_version != EV_CURRENT) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_version: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), header_.e_version);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 校验架构是否匹配</span></span><br><span class="line">  <span class="keyword">if</span> (header_.e_machine != <span class="built_in">GetTargetElfMachine</span>()) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is for %s (%d) instead of %s (%d)&quot;</span>,</span><br><span class="line">           name_.<span class="built_in">c_str</span>(),</span><br><span class="line">           <span class="built_in">EM_to_string</span>(header_.e_machine), header_.e_machine,</span><br><span class="line">           <span class="built_in">EM_to_string</span>(<span class="built_in">GetTargetElfMachine</span>()), <span class="built_in">GetTargetElfMachine</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_shentsize != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Shdr))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; has unsupported e_shentsize: 0x%x (expected 0x%zx)&quot;</span>,</span><br><span class="line">                       name_.<span class="built_in">c_str</span>(), header_.e_shentsize, <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Shdr)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;has invalid ELF header&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_shstrndx == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; has invalid e_shstrndx&quot;</span>, name_.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;has invalid ELF header&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ELF文件中的phdrs map到私有、只读、匿名内存块</span></span><br><span class="line"><span class="comment">// Loads the program header table from an ELF file into a read-only private</span></span><br><span class="line"><span class="comment">// anonymous mmap-ed block.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadProgramHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phdr_num_ = header_.e_phnum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like the kernel, we only accept program header tables that</span></span><br><span class="line">  <span class="comment">// are smaller than 64KiB.</span></span><br><span class="line">  <span class="keyword">if</span> (phdr_num_ &lt; <span class="number">1</span> || phdr_num_ &gt; <span class="number">65536</span>/<span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Phdr))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid e_phnum: %zd&quot;</span>, name_.<span class="built_in">c_str</span>(), phdr_num_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界检查</span></span><br><span class="line">  <span class="comment">// Boundary checks</span></span><br><span class="line">  <span class="type">size_t</span> size = phdr_num_ * <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Phdr));</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(header_.e_phoff, size, <span class="built_in">alignof</span>(<span class="built_in">ElfW</span>(Phdr)))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid phdr offset/size: %zu/%zu&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                   <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(header_.e_phoff),</span><br><span class="line">                   size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap64映射</span></span><br><span class="line">  <span class="keyword">if</span> (!phdr_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, header_.e_phoff, size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; phdr mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 记录映射后的phdr表的起始位置</span></span><br><span class="line">  phdr_table_ = <span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Phdr)*&gt;(phdr_fragment_.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射</span></span><br><span class="line"><span class="comment">// fd: ELF文件的fd</span></span><br><span class="line"><span class="comment">// base_offset: ELF问价本身的偏移</span></span><br><span class="line"><span class="comment">// elf_offset: 要映射的区域本身在ELF文件中的区域。</span></span><br><span class="line"><span class="comment">// size: 要映射的区域的大小</span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line"><span class="comment">//  VirtualMemory                 File</span></span><br><span class="line"><span class="comment">// ....                            ...</span></span><br><span class="line"><span class="comment">// 0x...5000                        10      // 需要的内存地址开始</span></span><br><span class="line"><span class="comment">// 0x...5008                        18</span></span><br><span class="line"><span class="comment">// ...                             ...</span></span><br><span class="line"><span class="comment">// 0x...5128                       4128     // 需要被加载文件偏移开始</span></span><br><span class="line"><span class="comment">// 0x...5130                       4130</span></span><br><span class="line"><span class="comment">// 0x...5138                       4138</span></span><br><span class="line"><span class="comment">// ...                             ...</span></span><br><span class="line"><span class="comment">// 0x...6120                       5120     // 需要被加载的文件结束    </span></span><br><span class="line"><span class="comment">// ...                             ...</span></span><br><span class="line"><span class="comment">// 0x...6FFF                       ...      // 需要的内存地址结束</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MappedFileFragment::Map</span><span class="params">(<span class="type">int</span> fd, <span class="type">off64_t</span> base_offset, <span class="type">size_t</span> elf_offset, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">off64_t</span> offset;</span><br><span class="line">  <span class="comment">// 得到具体偏移，offset = base_offset + elf_offset</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">safe_add</span>(&amp;offset, base_offset, elf_offset));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为mmap是按页来映射的，所以这里需要根据文件映射区域的起始位置和大小，计算需要的页大小。</span></span><br><span class="line">  <span class="comment">// 计算这个偏移对应的页开始位置,比如假设PAGESIZE是4096（0x1000),偏移是0x4128，则得到0x4000</span></span><br><span class="line">  <span class="type">off64_t</span> page_min = <span class="built_in">page_start</span>(offset);</span><br><span class="line">  <span class="type">off64_t</span> end_offset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算得到区域的结束位置</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">safe_add</span>(&amp;end_offset, offset, size));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 补齐。比如偏移是0x4128,因为page_min为0x4000。如果仍然size来映射的话，可能得到的内存不够。</span></span><br><span class="line">  <span class="comment">// 所以需要在给end_offset增加0x128。</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">safe_add</span>(&amp;end_offset, end_offset, <span class="built_in">page_offset</span>(offset)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到需要的内存大小</span></span><br><span class="line">  <span class="type">size_t</span> map_size = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(end_offset - page_min);</span><br><span class="line">  <span class="built_in">CHECK</span>(map_size &gt;= size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件映射到内存</span></span><br><span class="line">  <span class="type">uint8_t</span>* map_start = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(</span><br><span class="line">                          <span class="built_in">mmap64</span>(<span class="literal">nullptr</span>, map_size, PROT_READ, MAP_PRIVATE, fd, page_min));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map_start == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存页开始位置</span></span><br><span class="line">  map_start_ = map_start;</span><br><span class="line"><span class="comment">// 内存页大小  </span></span><br><span class="line">  map_size_ = map_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到数据的开始位置指针</span></span><br><span class="line">  data_ = map_start + <span class="built_in">page_offset</span>(offset);</span><br><span class="line">  <span class="comment">// 数据大小</span></span><br><span class="line">  size_ = size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the address of the page containing address &#x27;x&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">page_start</span><span class="params">(<span class="type">uintptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; ~(<span class="built_in">page_size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the offset of address &#x27;x&#x27; in its page.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">page_offset</span><span class="params">(<span class="type">uintptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (<span class="built_in">page_size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the address of the next page after address &#x27;x&#x27;, unless &#x27;x&#x27; is</span></span><br><span class="line"><span class="comment">// itself at the start of a page.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">page_end</span><span class="params">(<span class="type">uintptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">page_start</span>(x + <span class="built_in">page_size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据phdr中的p_align计算对齐</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::CheckProgramHeaderAlignment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  max_align_ = min_align_ = <span class="built_in">page_size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For loadable segments, p_align must be 0, 1,</span></span><br><span class="line">    <span class="comment">// or a positive, integral power of two.</span></span><br><span class="line">    <span class="comment">// The kernel ignores loadable segments with other values,</span></span><br><span class="line">    <span class="comment">// so we just warn rather than reject them.</span></span><br><span class="line">    <span class="keyword">if</span> ((phdr-&gt;p_align &amp; (phdr-&gt;p_align - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_WARN</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid p_align %zx in phdr %zu&quot;</span>, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                     <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(phdr-&gt;p_align), i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max_align_ = std::<span class="built_in">max</span>(max_align_, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(phdr-&gt;p_align));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_align &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      min_align_ = std::<span class="built_in">min</span>(min_align_, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(phdr-&gt;p_align));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射Shdrs</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadSectionHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  shdr_num_ = header_.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr_num_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has no section headers&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size = shdr_num_ * <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Shdr));</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(header_.e_shoff, size, <span class="built_in">alignof</span>(<span class="type">const</span> <span class="built_in">ElfW</span>(Shdr)))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid shdr offset/size: %zu/%zu&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                   <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(header_.e_shoff),</span><br><span class="line">                   size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!shdr_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, header_.e_shoff, size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; shdr mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 记录shdr表开始位置</span></span><br><span class="line">  shdr_table_ = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="built_in">ElfW</span>(Shdr)*&gt;(shdr_fragment_.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Dynamic节</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadDynamicSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. Find .dynamic section (in section headers)</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Shdr)</span>* dynamic_shdr </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shdr_num_; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shdr_table_[i].sh_type == SHT_DYNAMIC) &#123;</span><br><span class="line">      <span class="comment">// 记录dynamic_shdr</span></span><br><span class="line">      dynamic_shdr = &amp;shdr_table_ [i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dynamic_shdr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; .dynamic section header was not found&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验shdr中描述的dynamic节的偏移和phdr中描述dynamic开始位置是一致且大小一致</span></span><br><span class="line">  <span class="comment">// Make sure dynamic_shdr offset and size matches PT_DYNAMIC phdr</span></span><br><span class="line">  <span class="type">size_t</span> pt_dynamic_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> pt_dynamic_filesz = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type == PT_DYNAMIC) &#123;</span><br><span class="line">      pt_dynamic_offset = phdr-&gt;p_offset;</span><br><span class="line">      pt_dynamic_filesz = phdr-&gt;p_filesz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pt_dynamic_offset != dynamic_shdr-&gt;sh_offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid offset: 0x%zx, &quot;</span></span><br><span class="line">                       <span class="string">&quot;expected to match PT_DYNAMIC offset: 0x%zx&quot;</span>,</span><br><span class="line">                       name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                       <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(dynamic_shdr-&gt;sh_offset),</span><br><span class="line">                       pt_dynamic_offset)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;invalid .dynamic section&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pt_dynamic_filesz != dynamic_shdr-&gt;sh_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid size: 0x%zx &quot;</span></span><br><span class="line">                       <span class="string">&quot;(expected to match PT_DYNAMIC filesz 0x%zx)&quot;</span>,</span><br><span class="line">                       name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                       <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(dynamic_shdr-&gt;sh_size),</span><br><span class="line">                       pt_dynamic_filesz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;invalid .dynamic section&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dynamic_shdr-&gt;sh_link &gt;= shdr_num_) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid sh_link: %d&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                   dynamic_shdr-&gt;sh_link);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符串表</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Shdr)</span>* strtab_shdr </span>= &amp;shdr_table_[dynamic_shdr-&gt;sh_link];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (strtab_shdr-&gt;sh_type != SHT_STRTAB) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid link(%d) sh_type: %d (expected SHT_STRTAB)&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(), dynamic_shdr-&gt;sh_link, strtab_shdr-&gt;sh_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(dynamic_shdr-&gt;sh_offset, dynamic_shdr-&gt;sh_size, <span class="built_in">alignof</span>(<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid offset/size of .dynamic section&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将dynamic节映射到内存</span></span><br><span class="line">  <span class="keyword">if</span> (!dynamic_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, dynamic_shdr-&gt;sh_offset, dynamic_shdr-&gt;sh_size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; dynamic section mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到到dynamic节</span></span><br><span class="line">  dynamic_ = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)*&gt;(dynamic_fragment_.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(strtab_shdr-&gt;sh_offset, strtab_shdr-&gt;sh_size, <span class="built_in">alignof</span>(<span class="type">const</span> <span class="type">char</span>))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid offset/size of the .strtab section linked from .dynamic section&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将字符串映射到内存</span></span><br><span class="line">  <span class="keyword">if</span> (!strtab_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, strtab_shdr-&gt;sh_offset, strtab_shdr-&gt;sh_size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; strtab section mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到了字符串</span></span><br><span class="line">  strtab_ = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(strtab_fragment_.<span class="built_in">data</span>());</span><br><span class="line">  strtab_size_ = strtab_fragment_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里读取了ELF文件的基本信息并完成了校验。并且将Phdr、Shdr、dynamic节、strtab节等映射到了内存，并记录到了ELFReader中的变量。</p>
<h1 id="二加载动态库">二、加载动态库</h1>
<p><img src="/images/android/native_dynamic_so_load.png" alt="LoadTask_load" width="720"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">load</span><span class="params">(address_space_params* address_space)</span> </span>&#123;</span><br><span class="line">    ElfReader&amp; elf_reader = <span class="built_in">get_elf_reader</span>();</span><br><span class="line">    <span class="comment">// 加载动态库，address_space用来指导内存的分配</span></span><br><span class="line">    <span class="keyword">if</span> (!elf_reader.<span class="built_in">Load</span>(address_space)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将elf_reader中的load_bias,phdr初始地址等赋值到soinfo中。</span></span><br><span class="line">    si_-&gt;base = elf_reader.<span class="built_in">load_start</span>(); <span class="comment">// 内存页的起始位置</span></span><br><span class="line">    si_-&gt;size = elf_reader.<span class="built_in">load_size</span>();  <span class="comment">// 需要的内存大小</span></span><br><span class="line">    si_-&gt;<span class="built_in">set_mapped_by_caller</span>(elf_reader.<span class="built_in">is_mapped_by_caller</span>());</span><br><span class="line">    si_-&gt;load_bias = elf_reader.<span class="built_in">load_bias</span>(); <span class="comment">// 这个库的基地址</span></span><br><span class="line">    si_-&gt;phnum = elf_reader.<span class="built_in">phdr_count</span>(); </span><br><span class="line">    si_-&gt;phdr = elf_reader.<span class="built_in">loaded_phdr</span>();</span><br><span class="line">    si_-&gt;<span class="built_in">set_gap_start</span>(elf_reader.<span class="built_in">gap_start</span>());</span><br><span class="line">    si_-&gt;<span class="built_in">set_gap_size</span>(elf_reader.<span class="built_in">gap_size</span>());</span><br><span class="line">    si_-&gt;<span class="built_in">set_should_pad_segments</span>(elf_reader.<span class="built_in">should_pad_segments</span>());</span><br><span class="line">    si_-&gt;<span class="built_in">set_should_use_16kib_app_compat</span>(elf_reader.<span class="built_in">should_use_16kib_app_compat</span>());</span><br><span class="line">    <span class="keyword">if</span> (si_-&gt;<span class="built_in">should_use_16kib_app_compat</span>()) &#123;</span><br><span class="line">      si_-&gt;<span class="built_in">set_compat_relro_start</span>(elf_reader.<span class="built_in">compat_relro_start</span>());</span><br><span class="line">      si_-&gt;<span class="built_in">set_compat_relro_size</span>(elf_reader.<span class="built_in">compat_relro_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linker_phdr.cpp</span></span><br><span class="line"><span class="comment">// 将程序加载到指定内存位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::Load</span><span class="params">(address_space_params* address_space)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(did_read_);</span><br><span class="line">  <span class="keyword">if</span> (did_load_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据ELF文件可加载段的大小，预留内存位置</span></span><br><span class="line">  <span class="type">bool</span> reserveSuccess = <span class="built_in">ReserveAddressSpace</span>(address_space);</span><br><span class="line">  <span class="comment">// 加载Segments</span></span><br><span class="line">  <span class="keyword">if</span> (reserveSuccess &amp;&amp; <span class="built_in">LoadSegments</span>() &amp;&amp; <span class="built_in">FindPhdr</span>() &amp;&amp;</span><br><span class="line">      <span class="built_in">FindGnuPropertySection</span>()) &#123;</span><br><span class="line">    did_load_ = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__)</span></span><br><span class="line">    <span class="comment">// For Armv8.5-A loaded executable segments may require PROT_BTI.</span></span><br><span class="line">    <span class="keyword">if</span> (note_gnu_property_.<span class="built_in">IsBTICompatible</span>()) &#123;</span><br><span class="line">      did_load_ =</span><br><span class="line">          (<span class="built_in">phdr_table_protect_segments</span>(phdr_table_, phdr_num_, load_bias_, should_pad_segments_,</span><br><span class="line">                                       should_use_16kib_app_compat_, &amp;note_gnu_property_) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (reserveSuccess &amp;&amp; !did_load_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (load_start_ != <span class="literal">nullptr</span> &amp;&amp; load_size_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mapped_by_caller_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(load_start_, load_size_);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> did_load_;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留一个能够容纳所有可加载段（loadable segments）的内存</span></span><br><span class="line"><span class="comment">// Reserve a virtual address range big enough to hold all loadable</span></span><br><span class="line"><span class="comment">// segments of a program header table. This is done by creating a</span></span><br><span class="line"><span class="comment">// private anonymous mmap() with PROT_NONE.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReserveAddressSpace</span><span class="params">(address_space_params* address_space)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) min_vaddr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算需要的内存大小</span></span><br><span class="line">  load_size_ = <span class="built_in">phdr_table_get_load_size</span>(phdr_table_, phdr_num_, &amp;min_vaddr);</span><br><span class="line">  <span class="keyword">if</span> (load_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has no loadable segments&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="comment">// Reserve additional space for aligning the permission boundary in compat loading</span></span><br><span class="line">    <span class="comment">// Up to kPageSize-kCompatPageSize additional space is needed, but reservation</span></span><br><span class="line">    <span class="comment">// is done with mmap which gives kPageSize multiple-sized reservations.</span></span><br><span class="line">    load_size_ += kPageSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序可加载段的最小偏移</span></span><br><span class="line">  <span class="type">uint8_t</span>* addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(min_vaddr);</span><br><span class="line">  <span class="type">void</span>* start;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认reserved_size是0，所以这个条件必然满足</span></span><br><span class="line">  <span class="keyword">if</span> (load_size_ &gt; address_space-&gt;reserved_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (address_space-&gt;must_use_address) &#123; <span class="comment">// 默认是false</span></span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;reserved address space %zd smaller than %zd bytes needed for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">             load_size_ - address_space-&gt;reserved_size, load_size_, name_.<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> start_alignment = <span class="built_in">page_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_transparent_hugepages_supported</span>() &amp;&amp; <span class="built_in">get_application_target_sdk_version</span>() &gt;= <span class="number">31</span>) &#123;</span><br><span class="line">      <span class="comment">// Limit alignment to PMD size as other alignments reduce the number of</span></span><br><span class="line">      <span class="comment">// bits available for ASLR for no benefit.</span></span><br><span class="line">      start_alignment = max_align_ == kPmdSize ? kPmdSize : <span class="built_in">page_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预留内存位置，并获得内存的起始位置。</span></span><br><span class="line">    start = <span class="built_in">ReserveWithAlignmentPadding</span>(load_size_, kLibraryAlignment, start_alignment, &amp;gap_start_, &amp;gap_size_);</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t reserve %zd bytes of address space for \&quot;%s\&quot;&quot;</span>, load_size_, name_.<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    start = address_space-&gt;start_addr;</span><br><span class="line">    gap_start_ = <span class="literal">nullptr</span>;</span><br><span class="line">    gap_size_ = <span class="number">0</span>;</span><br><span class="line">    mapped_by_caller_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the reserved address space to subtract the space used by this library.</span></span><br><span class="line">    address_space-&gt;start_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(address_space-&gt;start_addr) + load_size_;</span><br><span class="line">    address_space-&gt;reserved_size -= load_size_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 内存的起始位置</span></span><br><span class="line">  load_start_ = start;</span><br><span class="line"><span class="comment">// 得到程序的基地址  </span></span><br><span class="line">  load_bias_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(start) - addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="comment">// In compat mode make the initial mapping RW since the ELF contents will be read</span></span><br><span class="line">    <span class="comment">// into it; instead of mapped over it.</span></span><br><span class="line">    <span class="built_in">mprotect</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(start), load_size_, PROT_READ | PROT_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算出程序需要的地址空间大小，按页对齐。</span></span><br><span class="line"><span class="comment">// 遍历ELF文件中的所有PT_LOAD段，计算出最低地址和最高地址，即可以知道需要的内存大小。</span></span><br><span class="line"><span class="comment">/* Returns the size of the extent of all the possibly non-contiguous</span></span><br><span class="line"><span class="comment"> * loadable segments in an ELF program header table. This corresponds</span></span><br><span class="line"><span class="comment"> * to the page-aligned size in bytes that needs to be reserved in the</span></span><br><span class="line"><span class="comment"> * process&#x27; address space. If there are no loadable segments, 0 is</span></span><br><span class="line"><span class="comment"> * returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If out_min_vaddr or out_max_vaddr are not null, they will be</span></span><br><span class="line"><span class="comment"> * set to the minimum and maximum addresses of pages to be reserved,</span></span><br><span class="line"><span class="comment"> * or 0 if there is nothing to load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">phdr_table_get_load_size</span><span class="params">(<span class="type">const</span> ElfW(Phdr)* phdr_table, <span class="type">size_t</span> phdr_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ElfW(Addr)* out_min_vaddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ElfW(Addr)* out_max_vaddr)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) min_vaddr = UINTPTR_MAX;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) max_vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> found_pt_load = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_count; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    found_pt_load = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_vaddr &lt; min_vaddr) &#123;</span><br><span class="line">      min_vaddr = phdr-&gt;p_vaddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_vaddr + phdr-&gt;p_memsz &gt; max_vaddr) &#123;</span><br><span class="line">      max_vaddr = phdr-&gt;p_vaddr + phdr-&gt;p_memsz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!found_pt_load) &#123;</span><br><span class="line">    min_vaddr = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 需要的内存页起始位置</span></span><br><span class="line">  min_vaddr = <span class="built_in">page_start</span>(min_vaddr);</span><br><span class="line"><span class="comment">// 需要的内存页结束位置</span></span><br><span class="line">  max_vaddr = <span class="built_in">page_end</span>(max_vaddr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_min_vaddr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *out_min_vaddr = min_vaddr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (out_max_vaddr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *out_max_vaddr = max_vaddr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max_vaddr - min_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ELF可加载的段的大小，用mmap预留出一段虚拟地址，并返回内存的起始位置</span></span><br><span class="line"><span class="comment">// Reserve a virtual address range such that if it&#x27;s limits were extended to the next 2**align</span></span><br><span class="line"><span class="comment">// boundary, it would not overlap with any existing mappings.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ReserveWithAlignmentPadding</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> mapping_align, <span class="type">size_t</span> start_align,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">void</span>** out_gap_start, <span class="type">size_t</span>* out_gap_size)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS; <span class="comment">// 私有匿名内存</span></span><br><span class="line">  <span class="comment">// Reserve enough space to properly align the library&#x27;s start address.</span></span><br><span class="line">  mapping_align = std::<span class="built_in">max</span>(mapping_align, start_align);</span><br><span class="line">  <span class="keyword">if</span> (mapping_align == <span class="built_in">page_size</span>()) &#123; <span class="comment">//  假设命中这里的条件，直接用mmap预留内存。内存权限为：PROT_NONE</span></span><br><span class="line">  <span class="comment">// 这里得到的地址是随机的，默认会受到 ASLR (Address Space Layout Randomization) 的影响。</span></span><br><span class="line">    <span class="type">void</span>* mmap_ptr = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, size, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_ptr == MAP_FAILED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回内存的起始位置。</span></span><br><span class="line">    <span class="keyword">return</span> mmap_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Minimum alignment of shared library gap. For efficiency, this should match the second level</span></span><br><span class="line">  <span class="comment">// page size of the platform.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> kGapAlignment = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// Maximum gap size, in the units of kGapAlignment.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> kMaxGapUnits = <span class="number">32</span>;</span><br><span class="line">  <span class="comment">// Allocate enough space so that the end of the desired region aligned up is still inside the</span></span><br><span class="line">  <span class="comment">// mapping.</span></span><br><span class="line">  <span class="type">size_t</span> mmap_size = __builtin_align_up(size, mapping_align) + mapping_align - <span class="built_in">page_size</span>();</span><br><span class="line">  <span class="type">uint8_t</span>* mmap_ptr =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, mmap_size, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (mmap_ptr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">size_t</span> gap_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> first_byte = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">size_t</span>&gt;(__builtin_align_up(mmap_ptr, mapping_align));</span><br><span class="line">  <span class="type">size_t</span> last_byte = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">size_t</span>&gt;(__builtin_align_down(mmap_ptr + mmap_size, mapping_align) - <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (first_byte / kGapAlignment != last_byte / kGapAlignment) &#123;</span><br><span class="line">    <span class="comment">// This library crosses a 2MB boundary and will fragment a new huge page.</span></span><br><span class="line">    <span class="comment">// Lets take advantage of that and insert a random number of inaccessible huge pages before that</span></span><br><span class="line">    <span class="comment">// to improve address randomization and make it harder to locate this library code by probing.</span></span><br><span class="line">    <span class="built_in">munmap</span>(mmap_ptr, mmap_size);</span><br><span class="line">    mapping_align = std::<span class="built_in">max</span>(mapping_align, kGapAlignment);</span><br><span class="line">    gap_size =</span><br><span class="line">        kGapAlignment * (<span class="built_in">is_first_stage_init</span>() ? <span class="number">1</span> : <span class="built_in">arc4random_uniform</span>(kMaxGapUnits - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    mmap_size = __builtin_align_up(size + gap_size, mapping_align) + mapping_align - <span class="built_in">page_size</span>();</span><br><span class="line">    mmap_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, mmap_size, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mmap_ptr == MAP_FAILED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* gap_end = mmap_ptr + mmap_size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (gap_size) &#123;</span><br><span class="line">    gap_end = __builtin_align_down(gap_end, kGapAlignment);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">uint8_t</span>* gap_start = gap_end - gap_size;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* first = __builtin_align_up(mmap_ptr, mapping_align);</span><br><span class="line">  <span class="type">uint8_t</span>* last = __builtin_align_down(gap_start, mapping_align) - size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arc4random* is not available in first stage init because /dev/urandom hasn&#x27;t yet been</span></span><br><span class="line">  <span class="comment">// created. Don&#x27;t randomize then.</span></span><br><span class="line">  <span class="type">size_t</span> n = <span class="built_in">is_first_stage_init</span>() ? <span class="number">0</span> : <span class="built_in">arc4random_uniform</span>((last - first) / start_align + <span class="number">1</span>);</span><br><span class="line">  <span class="type">uint8_t</span>* start = first + n * start_align;</span><br><span class="line">  <span class="comment">// Unmap the extra space around the allocation.</span></span><br><span class="line">  <span class="comment">// Keep it mapped PROT_NONE on 64-bit targets where address space is plentiful to make it harder</span></span><br><span class="line">  <span class="comment">// to defeat ASLR by probing for readable memory mappings.</span></span><br><span class="line">  <span class="built_in">munmap</span>(mmap_ptr, start - mmap_ptr);</span><br><span class="line">  <span class="built_in">munmap</span>(start + size, gap_start - (start + size));</span><br><span class="line">  <span class="keyword">if</span> (gap_end != mmap_ptr + mmap_size) &#123;</span><br><span class="line">    <span class="built_in">munmap</span>(gap_end, mmap_ptr + mmap_size - gap_end);</span><br><span class="line">  &#125;</span><br><span class="line">  *out_gap_start = gap_start;</span><br><span class="line">  *out_gap_size = gap_size;</span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Segments</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::LoadSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The compat(legacy) page size (4096) must be used when aligning</span></span><br><span class="line">  <span class="comment">// the 4KiB segments for loading in compat mode. The larger 16KiB page size</span></span><br><span class="line">  <span class="comment">// will lead to overwriting adjacent segments since the ELF&#x27;s segment(s)</span></span><br><span class="line">  <span class="comment">// are not 16KiB aligned.</span></span><br><span class="line">  <span class="type">size_t</span> seg_align = should_use_16kib_app_compat_ ? kCompatPageSize : kPageSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only enforce this on 16 KB systems with app compat disabled.</span></span><br><span class="line">  <span class="comment">// Apps may rely on undefined behavior here on 4 KB systems,</span></span><br><span class="line">  <span class="comment">// which is the norm before this change is introduced</span></span><br><span class="line">  <span class="keyword">if</span> (kPageSize &gt;= <span class="number">16384</span> &amp;&amp; min_align_ &lt; kPageSize &amp;&amp; !should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; program alignment (%zu) cannot be smaller than system page size (%zu)&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(), min_align_, kPageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Setup16KiBAppCompat</span>()) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; failed to setup 16KiB App Compat&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 遍历所有的段头，phdrs、shdrs、strtab、dynamic在BFS遍历find_library的时候已经映射到了内存。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读取loadable segments</span></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取文件偏移和需要的虚拟内存地址</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) p_memsz = phdr-&gt;p_memsz;</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) p_filesz = phdr-&gt;p_filesz;</span><br><span class="line">    _extend_load_segment_vma(phdr_table_, phdr_num_, i, &amp;p_memsz, &amp;p_filesz, should_pad_segments_,</span><br><span class="line">                             should_use_16kib_app_compat_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加load_bias, 即将相对地址变为绝对地址</span></span><br><span class="line"><span class="comment">// 前面已经用mmap预留了内存，这里根据phdr中的内存相对地址+load_bias_即即可得到该段应该放到内存的什么区域。</span></span><br><span class="line">    <span class="comment">// Segment addresses in memory.</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_start = phdr-&gt;p_vaddr + load_bias_;</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_end = seg_start + p_memsz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按页向上对齐</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_page_end = __builtin_align_up(seg_end, seg_align);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_file_end = seg_start + p_filesz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到该段的文件偏移和大小信息</span></span><br><span class="line">    <span class="comment">// File offsets.</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_start = phdr-&gt;p_offset;</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_end = file_start + p_filesz;</span><br><span class="line"><span class="comment">// 按页向下对齐</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_page_start = __builtin_align_down(file_start, seg_align);</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_length = file_end - file_page_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_size_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; invalid file size: %&quot;</span> PRId64, name_.<span class="built_in">c_str</span>(), file_size_);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_start + phdr-&gt;p_filesz &gt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(file_size_)) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid ELF file \&quot;%s\&quot; load segment[%zd]:&quot;</span></span><br><span class="line">          <span class="string">&quot; p_offset (%p) + p_filesz (%p) ( = %p) past end of file (0x%&quot;</span> PRIx64 <span class="string">&quot;)&quot;</span>,</span><br><span class="line">          name_.<span class="built_in">c_str</span>(), i, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(phdr-&gt;p_offset),</span><br><span class="line">          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(phdr-&gt;p_filesz),</span><br><span class="line">          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(file_start + phdr-&gt;p_filesz), file_size_);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据段信息中描述的权限信息，写内存页的权限</span></span><br><span class="line">      <span class="type">int</span> prot = <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags);</span><br><span class="line">      <span class="keyword">if</span> ((prot &amp; (PROT_EXEC | PROT_WRITE)) == (PROT_EXEC | PROT_WRITE)) &#123;</span><br><span class="line">        <span class="comment">// target 26后, load segemnts不能同时可写、可执行。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; has load segments that are both writable and executable&quot;</span>,</span><br><span class="line">                           name_.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;W+E load segments&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Pass the file_length, since it may have been extended by _extend_load_segment_vma().</span></span><br><span class="line">      <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CompatMapSegment</span>(i, file_length)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将对应的段往指定的位置上映射</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MapSegment</span>(i, file_length)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// pagesize是4k的情况下，内存映射是有些冗余的，将冗余的内存清零</span></span><br><span class="line">    <span class="built_in">ZeroFillSegment</span>(phdr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DropPaddingPages</span>(phdr, seg_file_end);</span><br><span class="line"><span class="comment">// 为bss节分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MapBssSection</span>(phdr, seg_page_end, seg_file_end)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Segment对应的文件内容往指对应phdr指定的内存地址上进行映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::MapSegment</span><span class="params">(<span class="type">size_t</span> seg_idx, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[seg_idx];</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* start = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">page_start</span>(phdr-&gt;p_vaddr + load_bias_));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ELF could be being loaded directly from a zipped APK,</span></span><br><span class="line">  <span class="comment">// the zip offset must be added to find the segment offset.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> offset </span>= file_offset_ + <span class="built_in">page_start</span>(phdr-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> prot = <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将对应的段，映射到指定的内存上, MAP_FIXED 为固定内存映射</span></span><br><span class="line">  <span class="type">void</span>* seg_addr = <span class="built_in">mmap64</span>(start, len, prot, MAP_FIXED | MAP_PRIVATE, fd_, offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (seg_addr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t map \&quot;%s\&quot; segment %zd: %m&quot;</span>, name_.<span class="built_in">c_str</span>(), seg_idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark segments as huge page eligible if they meet the requirements</span></span><br><span class="line">  <span class="keyword">if</span> ((phdr-&gt;p_flags &amp; PF_X) &amp;&amp; phdr-&gt;p_align == kPmdSize &amp;&amp;</span><br><span class="line">      <span class="built_in">get_transparent_hugepages_supported</span>()) &#123;</span><br><span class="line">    <span class="built_in">madvise</span>(seg_addr, len, MADV_HUGEPAGE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为bss节分配内存</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::MapBssSection</span><span class="params">(<span class="type">const</span> ElfW(Phdr)* phdr, ElfW(Addr) seg_page_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ElfW(Addr) seg_file_end)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> We do not need to handle .bss in 16KiB compat mode since the mapping</span></span><br><span class="line">  <span class="comment">// reservation is anonymous and RW to begin with.</span></span><br><span class="line">  <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// seg_file_end is now the first page address after the file content.</span></span><br><span class="line">  seg_file_end = <span class="built_in">page_end</span>(seg_file_end);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (seg_page_end &lt;= seg_file_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If seg_page_end is larger than seg_file_end, we need to zero</span></span><br><span class="line">  <span class="comment">// anything between them. This is done by using a private anonymous</span></span><br><span class="line">  <span class="comment">// map for all extra pages</span></span><br><span class="line">  <span class="type">size_t</span> zeromap_size = seg_page_end - seg_file_end;</span><br><span class="line">  <span class="type">void</span>* zeromap =</span><br><span class="line">      <span class="built_in">mmap</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(seg_file_end), zeromap_size, <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags),</span><br><span class="line">           MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (zeromap == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t map .bss section for \&quot;%s\&quot;: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the VMA name using prctl</span></span><br><span class="line">  <span class="built_in">prctl</span>(PR_SET_VMA, PR_SET_VMA_ANON_NAME, zeromap, zeromap_size, <span class="string">&quot;.bss&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三预链接">三、预链接</h1>
<p>这里读取dynamic中的信息将符号表信息、重定位（rela）节、构造器、hash节、字符串节等信息的地址提前计算出来记录到soinfo中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An empty list of soinfos</span></span><br><span class="line"><span class="type">static</span> <span class="type">soinfo_list_t</span> g_empty_list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::prelink_image</span><span class="params">(<span class="type">bool</span> dlext_use_relro)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flags_ &amp; FLAG_PRELINKED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">/* Extract dynamic section */</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Word) dynamic_flags = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取PT_DYNAMIC段的地址和flags</span></span><br><span class="line">  <span class="comment">// PT_DYNAMIC：描述的是 .dynamic 段的信息，本身通常也位于 某个 PT_LOAD segment 里面。</span></span><br><span class="line">  <span class="built_in">phdr_table_get_dynamic_section</span>(phdr, phnum, load_bias, &amp;dynamic, &amp;dynamic_flags);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__arm__)</span></span><br><span class="line">  (<span class="type">void</span>) <span class="built_in">phdr_table_get_arm_exidx</span>(phdr, phnum, load_bias,</span><br><span class="line">                                  &amp;ARM_exidx, &amp;ARM_exidx_count);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  TlsSegment tls_segment;</span><br><span class="line">  <span class="keyword">if</span> (__bionic_get_tls_segment(phdr, phnum, load_bias, &amp;tls_segment)) &#123;</span><br><span class="line">    <span class="comment">// The loader does not (currently) support ELF TLS, so it shouldn&#x27;t have</span></span><br><span class="line">    <span class="comment">// a TLS segment.</span></span><br><span class="line">    <span class="built_in">CHECK</span>(!relocating_linker &amp;&amp; <span class="string">&quot;TLS not supported in loader&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!__bionic_check_tls_align(tls_segment.aligned_size.align.value)) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;TLS segment alignment in \&quot;%s\&quot; is not a power of 2: %zu&quot;</span>, <span class="built_in">get_realpath</span>(),</span><br><span class="line">             tls_segment.aligned_size.align.value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tls_ = std::<span class="built_in">make_unique</span>&lt;soinfo_tls&gt;();</span><br><span class="line">    tls_-&gt;segment = tls_segment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取dynamic中的所有section信息</span></span><br><span class="line">  <span class="comment">// Extract useful information from dynamic section.</span></span><br><span class="line">  <span class="comment">// Note that: &quot;Except for the DT_NULL element at the end of the array,</span></span><br><span class="line">  <span class="comment">// and the relative order of DT_NEEDED elements, entries may appear in any order.&quot;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// source: http://www.sco.com/developers/gabi/1998-04-29/ch5.dynamic.html</span></span><br><span class="line">  <span class="type">uint32_t</span> needed_count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">ElfW</span>(Dyn)* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;dynamic entry @%p: d_tag=%p, d_val=%p&quot;</span>,</span><br><span class="line">             d, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_tag), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_un.d_val));</span><br><span class="line">    <span class="keyword">switch</span> (d-&gt;d_tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> DT_SONAME: </span><br><span class="line">        <span class="comment">// this is parsed after we have strtab initialized (see below).</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取DT_HASH表信息</span></span><br><span class="line">      <span class="keyword">case</span> DT_HASH:</span><br><span class="line">        nbucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">0</span>];</span><br><span class="line">        nchain_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">1</span>];</span><br><span class="line">        bucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="number">8</span>);</span><br><span class="line">        chain_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="number">8</span> + nbucket_ * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_GNU_HASH:</span><br><span class="line">        gnu_nbucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// skip symndx</span></span><br><span class="line">        gnu_maskwords_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">2</span>];</span><br><span class="line">        gnu_shift2_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        gnu_bloom_filter_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="number">16</span>);</span><br><span class="line">        gnu_bucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(gnu_bloom_filter_ + gnu_maskwords_);</span><br><span class="line">        <span class="comment">// amend chain for symndx = header[1]</span></span><br><span class="line">        gnu_chain_ = gnu_bucket_ + gnu_nbucket_ -</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">powerof2</span>(gnu_maskwords_)) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid maskwords for gnu_hash = 0x%x, in \&quot;%s\&quot; expecting power to two&quot;</span>,</span><br><span class="line">              gnu_maskwords_, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --gnu_maskwords_;</span><br><span class="line"></span><br><span class="line">        flags_ |= FLAG_GNU_HASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取字符串表信息</span></span><br><span class="line">      <span class="keyword">case</span> DT_STRTAB:</span><br><span class="line">        strtab_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_STRSZ:</span><br><span class="line">        strtab_size_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取符号表</span></span><br><span class="line">      <span class="keyword">case</span> DT_SYMTAB:</span><br><span class="line">        symtab_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Sym)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_SYMENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Sym))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_SYMENT: %zd in \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val), <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 重定位表</span></span><br><span class="line">      <span class="keyword">case</span> DT_PLTREL:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != DT_RELA) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_RELA&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != DT_REL) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_REL&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_JMPREL:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">        plt_rela_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rela)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        plt_rel_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rel)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_PLTRELSZ:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">        plt_rela_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rela));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        plt_rel_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rel));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// PLTGOT表，直接忽略了... Andorid不支持</span></span><br><span class="line">      <span class="keyword">case</span> DT_PLTGOT:</span><br><span class="line">        <span class="comment">// Ignored (because RTLD_LAZY is not supported).</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_DEBUG:</span><br><span class="line">        <span class="comment">// Set the DT_DEBUG entry to the address of _r_debug for GDB</span></span><br><span class="line">        <span class="comment">// if the dynamic table is writable</span></span><br><span class="line">        <span class="keyword">if</span> ((dynamic_flags &amp; PF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">          d-&gt;d_un.d_val = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;_r_debug);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">      <span class="keyword">case</span> DT_RELA:</span><br><span class="line">        rela_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rela)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELASZ:</span><br><span class="line">        rela_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rela));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELA:</span><br><span class="line">        android_relocs_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELASZ:</span><br><span class="line">        android_relocs_size_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_REL:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_REL in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELSZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_RELSZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELAENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rela))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_RELAENT: %zd&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ignored (see DT_RELCOUNT comments for details).</span></span><br><span class="line">      <span class="keyword">case</span> DT_RELACOUNT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_REL:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_REL in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELSZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_RELSZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">case</span> DT_REL:</span><br><span class="line">        rel_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rel)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELSZ:</span><br><span class="line">        rel_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rel));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rel))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_RELENT: %zd&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_REL:</span><br><span class="line">        android_relocs_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELSZ:</span><br><span class="line">        android_relocs_size_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELA:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_RELA in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELASZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_RELASZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// &quot;Indicates that all RELATIVE relocations have been concatenated together,</span></span><br><span class="line">      <span class="comment">// and specifies the RELATIVE relocation count.&quot;</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Spec also mentions that this can be used to optimize relocation process;</span></span><br><span class="line">      <span class="comment">// Not currently used by bionic linker - ignored.</span></span><br><span class="line">      <span class="keyword">case</span> DT_RELCOUNT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELA:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_RELA in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELASZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_RELASZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">case</span> DT_RELR:</span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELR:</span><br><span class="line">        relr_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Relr)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELRSZ:</span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELRSZ:</span><br><span class="line">        relr_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Relr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELRENT:</span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELRENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Relr))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_RELRENT: %zd&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ignored (see DT_RELCOUNT comments for details).</span></span><br><span class="line">      <span class="comment">// There is no DT_RELRCOUNT specifically because it would only be ignored.</span></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELRCOUNT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取init_func_</span></span><br><span class="line">      <span class="keyword">case</span> DT_INIT:</span><br><span class="line">        init_func_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_ctor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s constructors (DT_INIT) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), init_func_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取fini_func_</span></span><br><span class="line">      <span class="keyword">case</span> DT_FINI:</span><br><span class="line">        fini_func_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_dtor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s destructors (DT_FINI) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), fini_func_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取init_array_的地址信息</span></span><br><span class="line">      <span class="keyword">case</span> DT_INIT_ARRAY:</span><br><span class="line">        init_array_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s constructors (DT_INIT_ARRAY) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), init_array_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_INIT_ARRAYSZ:</span><br><span class="line">        init_array_count_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FINI_ARRAY:</span><br><span class="line">        fini_array_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_dtor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s destructors (DT_FINI_ARRAY) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), fini_array_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FINI_ARRAYSZ:</span><br><span class="line">        fini_array_count_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_PREINIT_ARRAY:</span><br><span class="line">        preinit_array_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s constructors (DT_PREINIT_ARRAY) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), preinit_array_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_PREINIT_ARRAYSZ:</span><br><span class="line">        preinit_array_count_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_TEXTREL:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        has_text_relocations = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_SYMBOLIC:</span><br><span class="line">        has_DT_SYMBOLIC = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_NEEDED:</span><br><span class="line">        ++needed_count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FLAGS:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val &amp; DF_TEXTREL) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          has_text_relocations = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val &amp; DF_SYMBOLIC) &#123;</span><br><span class="line">          has_DT_SYMBOLIC = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FLAGS_1:</span><br><span class="line">        <span class="built_in">set_dt_flags_1</span>(d-&gt;d_un.d_val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((d-&gt;d_un.d_val &amp; ~SUPPORTED_DT_FLAGS_1) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">DL_WARN</span>(<span class="string">&quot;Warning: \&quot;%s\&quot; has unsupported flags DT_FLAGS_1=%p &quot;</span></span><br><span class="line">                  <span class="string">&quot;(ignoring unsupported flags)&quot;</span>,</span><br><span class="line">                  <span class="built_in">get_realpath</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_un.d_val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ignored: &quot;Its use has been superseded by the DF_BIND_NOW flag&quot;</span></span><br><span class="line">      <span class="keyword">case</span> DT_BIND_NOW:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERSYM:</span><br><span class="line">        versym_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Versym)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERDEF:</span><br><span class="line">        verdef_ptr_ = load_bias + d-&gt;d_un.d_ptr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_VERDEFNUM:</span><br><span class="line">        verdef_cnt_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERNEED:</span><br><span class="line">        verneed_ptr_ = load_bias + d-&gt;d_un.d_ptr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERNEEDNUM:</span><br><span class="line">        verneed_cnt_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RUNPATH:</span><br><span class="line">        <span class="comment">// this is parsed after we have strtab initialized (see below).</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_TLSDESC_GOT:</span><br><span class="line">      <span class="keyword">case</span> DT_TLSDESC_PLT:</span><br><span class="line">        <span class="comment">// These DT entries are used for lazy TLSDESC relocations. Bionic</span></span><br><span class="line">        <span class="comment">// resolves everything eagerly, so these can be ignored.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__)</span></span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_BTI_PLT:</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_PAC_PLT:</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_VARIANT_PCS:</span><br><span class="line">        <span class="comment">// Ignored: AArch64 processor-specific dynamic array tags.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_MODE:</span><br><span class="line">        memtag_dynamic_entries_.has_memtag_mode = <span class="literal">true</span>;</span><br><span class="line">        memtag_dynamic_entries_.memtag_mode = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_HEAP:</span><br><span class="line">        memtag_dynamic_entries_.memtag_heap = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// The AArch64 MemtagABI originally erroneously defined</span></span><br><span class="line">      <span class="comment">// DT_AARCH64_MEMTAG_STACK as `d_ptr`, which is why the dynamic tag value</span></span><br><span class="line">      <span class="comment">// is odd (`0x7000000c`). `d_val` is clearly the correct semantics, and so</span></span><br><span class="line">      <span class="comment">// this was fixed in the ABI, but the value (0x7000000c) didn&#x27;t change</span></span><br><span class="line">      <span class="comment">// because we already had Android binaries floating around with dynamic</span></span><br><span class="line">      <span class="comment">// entries, and didn&#x27;t want to create a whole new dynamic entry and</span></span><br><span class="line">      <span class="comment">// reserve a value just to fix that tiny mistake. P.S. lld was always</span></span><br><span class="line">      <span class="comment">// outputting DT_AARCH64_MEMTAG_STACK as `d_val` anyway.</span></span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_STACK:</span><br><span class="line">        memtag_dynamic_entries_.memtag_stack = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// Same as above, except DT_AARCH64_MEMTAG_GLOBALS was incorrectly defined</span></span><br><span class="line">      <span class="comment">// as `d_val` (hence an even value of `0x7000000d`), when it should have</span></span><br><span class="line">      <span class="comment">// been `d_ptr` all along. lld has always outputted this as `d_ptr`.</span></span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_GLOBALS:</span><br><span class="line">        memtag_dynamic_entries_.memtag_globals = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_GLOBALSSZ:</span><br><span class="line">        memtag_dynamic_entries_.memtag_globalssz = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!relocating_linker) &#123;</span><br><span class="line">          <span class="type">const</span> <span class="type">char</span>* tag_name;</span><br><span class="line">          <span class="keyword">if</span> (d-&gt;d_tag == DT_RPATH) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;DT_RPATH&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;d_tag == DT_ENCODING) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;DT_ENCODING&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;d_tag &gt;= DT_LOOS &amp;&amp; d-&gt;d_tag &lt;= DT_HIOS) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;unknown OS-specific&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;d_tag &gt;= DT_LOPROC &amp;&amp; d-&gt;d_tag &lt;= DT_HIPROC) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;unknown processor-specific&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">DL_WARN</span>(<span class="string">&quot;Warning: \&quot;%s\&quot; unused DT entry: %s (type %p arg %p) (ignoring)&quot;</span>,</span><br><span class="line">                  <span class="built_in">get_realpath</span>(),</span><br><span class="line">                  tag_name,</span><br><span class="line">                  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_tag),</span><br><span class="line">                  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_un.d_val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;si-&gt;base = %p, si-&gt;strtab = %p, si-&gt;symtab = %p&quot;</span>,</span><br><span class="line">           <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base), strtab_, symtab_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validity checks.</span></span><br><span class="line">  <span class="keyword">if</span> (relocating_linker &amp;&amp; needed_count != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;linker cannot have DT_NEEDED dependencies on other libraries&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nbucket_ == <span class="number">0</span> &amp;&amp; gnu_nbucket_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;empty/missing DT_HASH/DT_GNU_HASH in \&quot;%s\&quot; &quot;</span></span><br><span class="line">        <span class="string">&quot;(new hash type from the future?)&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (strtab_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;empty/missing DT_STRTAB in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (symtab_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;empty/missing DT_SYMTAB in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Second pass - parse entries relying on strtab. Skip this while relocating the linker so as to</span></span><br><span class="line">  <span class="comment">// avoid doing heap allocations until later in the linker&#x27;s initialization.</span></span><br><span class="line">  <span class="keyword">if</span> (!relocating_linker) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">ElfW</span>(Dyn)* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (d-&gt;d_tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> DT_SONAME:</span><br><span class="line">          <span class="built_in">set_soname</span>(<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RUNPATH:</span><br><span class="line">          <span class="built_in">set_dt_runpath</span>(<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before API 23, the linker used the basename in place of DT_SONAME.</span></span><br><span class="line">  <span class="comment">// After we switched, apps with libraries without a DT_SONAME stopped working:</span></span><br><span class="line">  <span class="comment">// they could no longer be found by DT_NEEDED from another library.</span></span><br><span class="line">  <span class="comment">// The main executable does not need to have a DT_SONAME.</span></span><br><span class="line">  <span class="comment">// The linker has a DT_SONAME, but the soname_ field is initialized later on.</span></span><br><span class="line">  <span class="keyword">if</span> (soname_.<span class="built_in">empty</span>() &amp;&amp; <span class="keyword">this</span> != <span class="built_in">solist_get_somain</span>() &amp;&amp; !relocating_linker &amp;&amp;</span><br><span class="line">      <span class="built_in">get_application_target_sdk_version</span>() &lt; <span class="number">23</span>) &#123;</span><br><span class="line">    soname_ = <span class="built_in">basename</span>(realpath_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// The `if` above means we don&#x27;t get here for targetSdkVersion &gt;= 23,</span></span><br><span class="line">    <span class="comment">// so no need to check the return value of DL_ERROR_AFTER().</span></span><br><span class="line">    <span class="comment">// We still call it rather than DL_WARN() to get the extra clarification.</span></span><br><span class="line">    <span class="built_in">DL_ERROR_AFTER</span>(<span class="number">23</span>, <span class="string">&quot;\&quot;%s\&quot; has no DT_SONAME (will use %s instead)&quot;</span>,</span><br><span class="line">                   <span class="built_in">get_realpath</span>(), soname_.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate each library&#x27;s verdef section once, so we don&#x27;t have to validate</span></span><br><span class="line">  <span class="comment">// it each time we look up a symbol with a version.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">validate_verdef_section</span>(<span class="keyword">this</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MTE globals requires remapping data segments with PROT_MTE as anonymous mappings, because file</span></span><br><span class="line">  <span class="comment">// based mappings may not be backed by tag-capable memory (see &quot;MAP_ANONYMOUS&quot; on</span></span><br><span class="line">  <span class="comment">// https://www.kernel.org/doc/html/latest/arch/arm64/memory-tagging-extension.html). This is only</span></span><br><span class="line">  <span class="comment">// done if the binary has MTE globals (evidenced by the dynamic table entries), as it destroys</span></span><br><span class="line">  <span class="comment">// page sharing. It&#x27;s also only done on devices that support MTE, because the act of remapping</span></span><br><span class="line">  <span class="comment">// pages is unnecessary on non-MTE devices (where we might still run MTE-globals enabled code).</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">should_tag_memtag_globals</span>() &amp;&amp;</span><br><span class="line">      <span class="built_in">remap_memtag_globals_segments</span>(phdr, phnum, base) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">tag_globals</span>(dlext_use_relro);</span><br><span class="line">    <span class="built_in">protect_memtag_globals_ro_segments</span>(phdr, phnum, base);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flags_ |= FLAG_PRELINKED;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the address and size of the ELF file&#x27;s .dynamic section in memory,</span></span><br><span class="line"><span class="comment"> * or null if missing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> *   phdr_table  -&gt; program header table</span></span><br><span class="line"><span class="comment"> *   phdr_count  -&gt; number of entries in tables</span></span><br><span class="line"><span class="comment"> *   load_bias   -&gt; load bias</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> *   dynamic       -&gt; address of table in memory (null on failure).</span></span><br><span class="line"><span class="comment"> *   dynamic_flags -&gt; protection flags for section (unset on failure)</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> *   void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">phdr_table_get_dynamic_section</span><span class="params">(<span class="type">const</span> ElfW(Phdr)* phdr_table, <span class="type">size_t</span> phdr_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ElfW(Addr) load_bias, ElfW(Dyn)** dynamic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ElfW(Word)* dynamic_flags)</span> </span>&#123;</span><br><span class="line">  *dynamic = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;phdr_count; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>&amp; phdr </span>= phdr_table[i];</span><br><span class="line">    <span class="keyword">if</span> (phdr.p_type == PT_DYNAMIC) &#123;</span><br><span class="line">      *dynamic = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Dyn)*&gt;(load_bias + phdr.p_vaddr);</span><br><span class="line">      <span class="keyword">if</span> (dynamic_flags) &#123;</span><br><span class="line">        *dynamic_flags = phdr.p_flags;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四链接">四、链接</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::link_image</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list, soinfo* local_group_root,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> android_dlextinfo* extinfo, <span class="type">size_t</span>* relro_fd_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_image_linked</span>()) &#123; <span class="comment">// 如果已经link了就返回</span></span><br><span class="line">    <span class="comment">// already linked.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_is_ldd &amp;&amp; !<span class="built_in">is_main_executable</span>()) &#123;</span><br><span class="line">    <span class="built_in">async_safe_format_fd</span>(STDOUT_FILENO, <span class="string">&quot;\t%s =&gt; %s (%p)\n&quot;</span>, <span class="built_in">get_soname</span>(),</span><br><span class="line">                         <span class="built_in">get_realpath</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  local_group_root_ = local_group_root;</span><br><span class="line">  <span class="keyword">if</span> (local_group_root_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    local_group_root_ = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags_ &amp; FLAG_LINKER) == <span class="number">0</span> &amp;&amp; local_group_root_ == <span class="keyword">this</span>) &#123;</span><br><span class="line">    target_sdk_version_ = <span class="built_in">get_application_target_sdk_version</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (has_text_relocations) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">23</span>, <span class="string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, <span class="built_in">get_realpath</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(<span class="built_in">get_realpath</span>(), <span class="string">&quot;text relocations&quot;</span>);</span><br><span class="line">    <span class="comment">// Make segments writable to allow text relocations to work properly. We will later call</span></span><br><span class="line">    <span class="comment">// phdr_table_protect_segments() after all of them are applied.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_unprotect_segments</span>(phdr, phnum, load_bias, should_pad_segments_,</span><br><span class="line">                                      should_use_16kib_app_compat_) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t unprotect loadable segments for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定位</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="built_in">solist_get_vdso</span>() &amp;&amp; !<span class="built_in">relocate</span>(lookup_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;[ finished linking %s ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (has_text_relocations) &#123;</span><br><span class="line">    <span class="comment">// All relocations are done, we can protect our segments back to read-only.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_protect_segments</span>(phdr, phnum, load_bias, should_pad_segments_,</span><br><span class="line">                                    should_use_16kib_app_compat_) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t protect segments for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can also turn on GNU RELRO protection if we&#x27;re not linking the dynamic linker</span></span><br><span class="line">  <span class="comment">// itself --- it can&#x27;t make system calls yet, and will have to call protect_relro later.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_linker</span>() &amp;&amp; !<span class="built_in">protect_relro</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">should_tag_memtag_globals</span>()) &#123;</span><br><span class="line">    std::list&lt;std::string&gt;* vma_names_ptr = <span class="built_in">vma_names</span>();</span><br><span class="line">    <span class="comment">// should_tag_memtag_globals -&gt; __aarch64__ -&gt; vma_names() != nullptr</span></span><br><span class="line">    <span class="built_in">CHECK</span>(vma_names_ptr);</span><br><span class="line">    <span class="built_in">name_memtag_globals_segments</span>(phdr, phnum, base, <span class="built_in">get_realpath</span>(), vma_names_ptr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Handle serializing/sharing the RELRO segment */</span></span><br><span class="line">  <span class="keyword">if</span> (extinfo &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_WRITE_RELRO)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_serialize_gnu_relro</span>(phdr, phnum, load_bias,</span><br><span class="line">                                       extinfo-&gt;relro_fd, relro_fd_offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;failed serializing GNU RELRO section for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (extinfo &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_RELRO)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_map_gnu_relro</span>(phdr, phnum, load_bias,</span><br><span class="line">                                 extinfo-&gt;relro_fd, relro_fd_offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;failed mapping GNU RELRO section for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++g_module_load_counter;</span><br><span class="line">  <span class="built_in">notify_gdb_of_load</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 标记当前的so已经link了。</span></span><br><span class="line">  <span class="built_in">set_image_linked</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定位</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::relocate</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// For ldd, don&#x27;t apply relocations because TLS segments are not registered.</span></span><br><span class="line">  <span class="comment">// We don&#x27;t care whether ldd diagnoses unresolved symbols.</span></span><br><span class="line">  <span class="keyword">if</span> (g_is_ldd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在创建一个VersionTraker用来辅助符号的查找</span></span><br><span class="line">  VersionTracker version_tracker;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!version_tracker.<span class="built_in">init</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个“重定位器”，将version_tracker和lookup_list传给它，它将负责符号的重定位</span></span><br><span class="line">  <span class="function">Relocator <span class="title">relocator</span><span class="params">(version_tracker, lookup_list)</span></span>;</span><br><span class="line">  relocator.si = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 给它设置字符表</span></span><br><span class="line">  relocator.si_strtab = strtab_;</span><br><span class="line">  relocator.si_strtab_size = <span class="built_in">is_lp64_or_has_min_version</span>(<span class="number">1</span>) ? strtab_size_ : SIZE_MAX;</span><br><span class="line">  <span class="comment">// 设置符号表</span></span><br><span class="line">  relocator.si_symtab = symtab_;</span><br><span class="line">  relocator.tlsdesc_args = &amp;tlsdesc_args_;</span><br><span class="line">  relocator.tls_tp_base = __libc_shared_globals()-&gt;static_tls_layout.<span class="built_in">offset_thread_pointer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The linker already applied its RELR relocations in an earlier pass, so</span></span><br><span class="line">  <span class="comment">// skip the RELR relocations for the linker.</span></span><br><span class="line">  <span class="keyword">if</span> (relr_ != <span class="literal">nullptr</span> &amp;&amp; !<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s relr ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Relr)</span>* begin </span>= relr_;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Relr)</span>* end </span>= relr_ + relr_count_;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">relocate_relr</span>(begin, end, load_bias, <span class="built_in">should_tag_memtag_globals</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (android_relocs_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// check signature</span></span><br><span class="line">    <span class="keyword">if</span> (android_relocs_size_ &gt; <span class="number">3</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">1</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">2</span>] == <span class="string">&#x27;S&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">3</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s android rel/rela ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="type">uint8_t</span>* packed_relocs = android_relocs_ + <span class="number">4</span>;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> packed_relocs_size = android_relocs_size_ - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">packed_relocate</span>&lt;RelocMode::Typical&gt;(relocator, <span class="built_in">sleb128_decoder</span>(packed_relocs, packed_relocs_size))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;bad android relocation header.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line"><span class="comment">// 根据rela_表进行重定位</span></span><br><span class="line">  <span class="keyword">if</span> (rela_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s rela ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::Typical&gt;(relocator, rela_, rela_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (plt_rela_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s plt rela ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::JumpTable&gt;(relocator, plt_rela_, plt_rela_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (rel_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s rel ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::Typical&gt;(relocator, rel_, rel_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (plt_rel_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s plt rel ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::JumpTable&gt;(relocator, plt_rel_, plt_rel_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the tlsdesc_args_ vector&#x27;s size is finalized, we can write the addresses of its elements</span></span><br><span class="line">  <span class="comment">// into the TLSDESC relocations.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__) || defined(__riscv)</span></span><br><span class="line">  <span class="comment">// Bionic currently only implements TLSDESC for arm64 and riscv64.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;TlsDescriptor*, <span class="type">size_t</span>&gt;&amp; pair : relocator.deferred_tlsdesc_relocs) &#123;</span><br><span class="line">    TlsDescriptor* desc = pair.first;</span><br><span class="line">    desc-&gt;func = tlsdesc_resolver_dynamic;</span><br><span class="line">    desc-&gt;arg = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">size_t</span>&gt;(&amp;tlsdesc_args_[pair.second]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// defined(__aarch64__) || defined(__riscv)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定位">重定位</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode OptMode, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">plain_relocate</span><span class="params">(Relocator&amp; relocator, Args ...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">needs_slow_relocate_loop</span>(relocator) ?</span><br><span class="line">      <span class="built_in">plain_relocate_impl</span>&lt;RelocMode::General&gt;(relocator, args...) :</span><br><span class="line">      <span class="built_in">plain_relocate_impl</span>&lt;OptMode&gt;(relocator, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有rela项进行处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">plain_relocate_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">rel_t</span>* rels, <span class="type">size_t</span> rel_count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rel_count; ++i) &#123; <span class="comment">// for循环遍历所有重定位表项，进行重定位</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">process_relocation</span>&lt;Mode&gt;(relocator, rels[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理rel</span></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">process_relocation</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mode == RelocMode::General ?</span><br><span class="line">      <span class="built_in">process_relocation_general</span>(relocator, reloc) :</span><br><span class="line">      <span class="built_in">process_relocation_impl</span>&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rel_t就是ElfW(Rela)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ElfW</span><span class="params">(Rela)</span> <span class="type">rel_t</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ElfW</span><span class="params">(Rel)</span> <span class="type">rel_t</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_general</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">process_relocation_impl</span>&lt;RelocMode::General&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理该符号的重定位</span></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得符号信息中所指向的目标地址，例如指向GOT槽</span></span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> rel_target = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">      relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(reloc.r_offset + relocator.si-&gt;load_bias));</span><br><span class="line"><span class="comment">// 获得符号的type和sym, r_sym就是.dynsym表中的符号的索引    </span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_type = <span class="built_in">ELFW</span>(R_TYPE)(reloc.r_info);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_sym = <span class="built_in">ELFW</span>(R_SYM)(reloc.r_info);</span><br><span class="line"></span><br><span class="line">  soinfo* found_in = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* sym_name = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) sym_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r_sym != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 利用r_sym找到.dynamic中的符号信息，并获得名称信息。（名称信息通过查字符表获取）</span></span><br><span class="line">    sym_name = relocator.<span class="built_in">get_string</span>(relocator.si_symtab[r_sym].st_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While relocating a DSO with text relocations (obsolete and 32-bit only), the .text segment is</span></span><br><span class="line">  <span class="comment">// writable (but not executable). To call an ifunc, temporarily remap the segment as executable</span></span><br><span class="line">  <span class="comment">// (but not writable). Then switch it back to continue applying relocations in the segment.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> handle_text_relocs = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> protect_segments = []() &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> unprotect_segments = []() &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> handle_text_relocs = IsGeneral &amp;&amp; relocator.si-&gt;has_text_relocations;</span><br><span class="line">  <span class="keyword">auto</span> protect_segments = [&amp;]() &#123;</span><br><span class="line">    <span class="comment">// Make .text executable.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_protect_segments</span>(relocator.si-&gt;phdr, relocator.si-&gt;phnum,</span><br><span class="line">                                    relocator.si-&gt;load_bias, relocator.si-&gt;<span class="built_in">should_pad_segments</span>(),</span><br><span class="line">                                    relocator.si-&gt;<span class="built_in">should_use_16kib_app_compat</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t protect segments for \&quot;%s\&quot;: %m&quot;</span>, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> unprotect_segments = [&amp;]() &#123;</span><br><span class="line">    <span class="comment">// Make .text writable.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_unprotect_segments</span>(relocator.si-&gt;phdr, relocator.si-&gt;phnum,</span><br><span class="line">                                      relocator.si-&gt;load_bias, relocator.si-&gt;<span class="built_in">should_pad_segments</span>(),</span><br><span class="line">                                      relocator.si-&gt;<span class="built_in">should_use_16kib_app_compat</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t unprotect loadable segments for \&quot;%s\&quot;: %m&quot;</span>,</span><br><span class="line">             relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip symbol lookup for R_GENERIC_NONE relocations.</span></span><br><span class="line">  <span class="keyword">if</span> (__predict_false(r_type == R_GENERIC_NONE)) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO NONE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line"><span class="comment">// 如果是rela，获取到r_addend信息</span></span><br><span class="line">  <span class="keyword">auto</span> get_addend_rel   = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> reloc.r_addend; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> get_addend_norel = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> reloc.r_addend; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">auto</span> get_addend_rel   = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target); &#125;;</span><br><span class="line">  <span class="keyword">auto</span> get_addend_norel = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IsGeneral &amp;&amp; __predict_false(<span class="built_in">is_tls_reloc</span>(r_type))) &#123;</span><br><span class="line">    <span class="comment">// Always process TLS relocations using the slow code path, so that STB_LOCAL symbols are</span></span><br><span class="line">    <span class="comment">// diagnosed, and ifunc processing is skipped.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process_relocation_general</span>(relocator, reloc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IsGeneral &amp;&amp; <span class="built_in">is_tls_reloc</span>(r_type)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// By convention in ld.bfd and lld, an omitted symbol on a TLS relocation</span></span><br><span class="line">      <span class="comment">// is a reference to the current module.</span></span><br><span class="line">      found_in = relocator.si;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ELF_ST_BIND</span>(relocator.si_symtab[r_sym].st_info) == STB_LOCAL) &#123;</span><br><span class="line">      <span class="comment">// In certain situations, the Gold linker accesses a TLS symbol using a</span></span><br><span class="line">      <span class="comment">// relocation to an STB_LOCAL symbol in .dynsym of either STT_SECTION or</span></span><br><span class="line">      <span class="comment">// STT_TLS type. Bionic doesn&#x27;t support these relocations, so issue an</span></span><br><span class="line">      <span class="comment">// error. References:</span></span><br><span class="line">      <span class="comment">//  - https://groups.google.com/d/topic/generic-abi/dJ4_Y78aQ2M/discussion</span></span><br><span class="line">      <span class="comment">//  - https://sourceware.org/bugzilla/show_bug.cgi?id=17699</span></span><br><span class="line">      sym = &amp;relocator.si_symtab[r_sym];</span><br><span class="line">      <span class="keyword">auto</span> sym_type = <span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info);</span><br><span class="line">      <span class="keyword">if</span> (sym_type == STT_SECTION) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unexpected TLS reference to local section in \&quot;%s\&quot;: sym type %d, rel type %u&quot;</span>,</span><br><span class="line">               relocator.si-&gt;<span class="built_in">get_realpath</span>(), sym_type, r_type);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(</span><br><span class="line">            <span class="string">&quot;unexpected TLS reference to local symbol \&quot;%s\&quot; in \&quot;%s\&quot;: sym type %d, rel type %u&quot;</span>,</span><br><span class="line">            sym_name, relocator.si-&gt;<span class="built_in">get_realpath</span>(), sym_type, r_type);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">lookup_symbol</span>&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found_in != <span class="literal">nullptr</span> &amp;&amp; found_in-&gt;<span class="built_in">get_tls</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// sym_name can be nullptr if r_sym is 0. A linker should never output an ELF file like this.</span></span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;TLS relocation refers to symbol \&quot;%s\&quot; in solib \&quot;%s\&quot; with no TLS segment&quot;</span>,</span><br><span class="line">             sym_name, found_in-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info) != STT_TLS) &#123;</span><br><span class="line">        <span class="comment">// A toolchain should never output a relocation like this.</span></span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;reference to non-TLS symbol \&quot;%s\&quot; from TLS relocation in \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">               sym_name, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sym_addr = sym-&gt;st_value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 查找符号        </span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">lookup_symbol</span>&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> should_protect_segments = handle_text_relocs &amp;&amp;</span><br><span class="line">                                             found_in == relocator.si &amp;&amp;</span><br><span class="line">                                             <span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info) == STT_GNU_IFUNC;</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !<span class="built_in">protect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到符号后，resolve出它的地址。</span></span><br><span class="line">        sym_addr = found_in-&gt;<span class="built_in">resolve_symbol_address</span>(sym);</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !<span class="built_in">unprotect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (IsGeneral) &#123;</span><br><span class="line">        <span class="comment">// A weak reference to an undefined symbol. We typically use a zero symbol address, but</span></span><br><span class="line">        <span class="comment">// use the relocation base for PC-relative relocations, so that the value written is zero.</span></span><br><span class="line">        <span class="keyword">switch</span> (r_type) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">          <span class="keyword">case</span> R_X86_64_PC32:</span><br><span class="line">            sym_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__i386__)</span></span><br><span class="line">          <span class="keyword">case</span> R_386_PC32:</span><br><span class="line">            sym_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::JumpTable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_JUMP_SLOT) &#123; <span class="comment">// 如果是SLOT类型</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="comment">// 计算出符号对应的目标地址（如外部so中该符号的地址），并加上addend</span></span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_norel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO JMP_SLOT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">    <span class="comment">// 将根据符号找出的地址赋值给，符号表的target地址（如GOT槽）</span></span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::Typical)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Almost all dynamic relocations are of one of these types, and most will be</span></span><br><span class="line">    <span class="comment">// R_GENERIC_ABSOLUTE. The platform typically uses RELR instead, but R_GENERIC_RELATIVE is</span></span><br><span class="line">    <span class="comment">// common in non-platform binaries.</span></span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_ABSOLUTE) &#123; <span class="comment">// 如果时ABS类型，直接进行计算</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO ABSOLUTE %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_GLOB_DAT) &#123;</span><br><span class="line">      <span class="comment">// The i386 psABI specifies that R_386_GLOB_DAT doesn&#x27;t have an addend. The ARM ELF ABI</span></span><br><span class="line">      <span class="comment">// document (IHI0044F) specifies that R_ARM_GLOB_DAT has an addend, but Bionic isn&#x27;t adding</span></span><br><span class="line">      <span class="comment">// it.</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_norel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO GLOB_DAT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_RELATIVE) &#123;</span><br><span class="line">      <span class="comment">// In practice, r_sym is always zero, but if it weren&#x27;t, the linker would still look up the</span></span><br><span class="line">      <span class="comment">// referenced symbol (and abort if the symbol isn&#x27;t found), even though it isn&#x27;t used.</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      <span class="built_in">ElfW</span>(Addr) result = relocator.si-&gt;load_bias + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">      <span class="comment">// MTE globals reuses the place bits for additional tag-derivation metadata for</span></span><br><span class="line">      <span class="comment">// R_AARCH64_RELATIVE relocations, which makes it incompatible with</span></span><br><span class="line">      <span class="comment">// `-Wl,--apply-dynamic-relocs`. This is enforced by lld, however there&#x27;s nothing stopping</span></span><br><span class="line">      <span class="comment">// Android binaries (particularly prebuilts) from building with this linker flag if they&#x27;re</span></span><br><span class="line">      <span class="comment">// not built with MTE globals. Thus, don&#x27;t use the new relocation semantics if this DSO</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t have MTE globals.</span></span><br><span class="line">      <span class="keyword">if</span> (relocator.si-&gt;<span class="built_in">should_tag_memtag_globals</span>()) &#123;</span><br><span class="line">        <span class="type">int64_t</span>* place = <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>*&gt;(rel_target);</span><br><span class="line">        <span class="type">int64_t</span> offset = *place;</span><br><span class="line">        result = relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(result + offset) - offset;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO RELATIVE %16p &lt;- %16p&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result));</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!IsGeneral)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Almost all relocations are handled above. Handle the remaining relocations below, in a</span></span><br><span class="line">    <span class="comment">// separate function call. The symbol lookup will be repeated, but the result should be served</span></span><br><span class="line">    <span class="comment">// from the 1-symbol lookup cache.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process_relocation_general</span>(relocator, reloc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_IRELATIVE:</span><br><span class="line">      <span class="comment">// In the linker, ifuncs are called as soon as possible so that string functions work. We must</span></span><br><span class="line">      <span class="comment">// not call them again. (e.g. On arm32, resolving an ifunc changes the meaning of the addend</span></span><br><span class="line">      <span class="comment">// from a resolver function to the implementation.)</span></span><br><span class="line">      <span class="keyword">if</span> (!relocator.si-&gt;<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">        <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> ifunc_addr </span>= relocator.si-&gt;load_bias + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO IRELATIVE %16p &lt;- %16p&quot;</span>,</span><br><span class="line">                 rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(ifunc_addr));</span><br><span class="line">        <span class="keyword">if</span> (handle_text_relocs &amp;&amp; !<span class="built_in">protect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= <span class="built_in">call_ifunc_resolver</span>(ifunc_addr);</span><br><span class="line">        <span class="keyword">if</span> (handle_text_relocs &amp;&amp; !<span class="built_in">unprotect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_COPY:</span><br><span class="line">      <span class="comment">// Copy relocations allow read-only data or code in a non-PIE executable to access a</span></span><br><span class="line">      <span class="comment">// variable from a DSO. The executable reserves extra space in its .bss section, and the</span></span><br><span class="line">      <span class="comment">// linker copies the variable into the extra space. The executable then exports its copy</span></span><br><span class="line">      <span class="comment">// to interpose the copy in the DSO.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Bionic only supports PIE executables, so copy relocations aren&#x27;t supported. The ARM and</span></span><br><span class="line">      <span class="comment">// AArch64 ABI documents only allow them for ET_EXEC (non-PIE) objects. See IHI0056B and</span></span><br><span class="line">      <span class="comment">// IHI0044F.</span></span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;%s COPY relocations are not supported&quot;</span>, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLS_TPREL:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ElfW</span>(Addr) tpoff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (found_in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="comment">// Unresolved weak relocation. Leave tpoff at 0 to resolve</span></span><br><span class="line">          <span class="comment">// &amp;weak_tls_symbol to __get_tls().</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CHECK</span>(found_in-&gt;<span class="built_in">get_tls</span>() != <span class="literal">nullptr</span>); <span class="comment">// We rejected a missing TLS segment above.</span></span><br><span class="line">          <span class="type">const</span> TlsModule&amp; mod = <span class="built_in">get_tls_module</span>(found_in-&gt;<span class="built_in">get_tls</span>()-&gt;module_id);</span><br><span class="line">          <span class="keyword">if</span> (mod.static_offset != SIZE_MAX) &#123;</span><br><span class="line">            tpoff += mod.static_offset - relocator.tls_tp_base;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">DL_ERR</span>(<span class="string">&quot;TLS symbol \&quot;%s\&quot; in dlopened \&quot;%s\&quot; referenced from \&quot;%s\&quot; using IE access model&quot;</span>,</span><br><span class="line">                   sym_name, found_in-&gt;<span class="built_in">get_realpath</span>(), relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tpoff += sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLS_TPREL %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">                 rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(tpoff), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = tpoff;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLS_DTPMOD:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">size_t</span> module_id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (found_in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="comment">// Unresolved weak relocation. Evaluate the module ID to 0.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CHECK</span>(found_in-&gt;<span class="built_in">get_tls</span>() != <span class="literal">nullptr</span>); <span class="comment">// We rejected a missing TLS segment above.</span></span><br><span class="line">          module_id = found_in-&gt;<span class="built_in">get_tls</span>()-&gt;module_id;</span><br><span class="line">          <span class="built_in">CHECK</span>(module_id != kTlsUninitializedModuleId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLS_DTPMOD %16p &lt;- %zu %s&quot;</span>,</span><br><span class="line">                 rel_target, module_id, sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = module_id;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLS_DTPREL:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_rel</span>() - TLS_DTV_OFFSET;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLS_DTPREL %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">                 rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__) || defined(__riscv)</span></span><br><span class="line">    <span class="comment">// Bionic currently implements TLSDESC for arm64 and riscv64. This implementation should work</span></span><br><span class="line">    <span class="comment">// with other architectures, as long as the resolver functions are implemented.</span></span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLSDESC:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ElfW</span>(Addr) addend = reloc.r_addend;</span><br><span class="line">        TlsDescriptor* desc = <span class="built_in">static_cast</span>&lt;TlsDescriptor*&gt;(rel_target);</span><br><span class="line">        <span class="keyword">if</span> (found_in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="comment">// Unresolved weak relocation.</span></span><br><span class="line">          desc-&gt;func = tlsdesc_resolver_unresolved_weak;</span><br><span class="line">          desc-&gt;arg = addend;</span><br><span class="line">          <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLSDESC %16p &lt;- unresolved weak, addend 0x%zx %s&quot;</span>,</span><br><span class="line">                   rel_target, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(addend), sym_name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CHECK</span>(found_in-&gt;<span class="built_in">get_tls</span>() != <span class="literal">nullptr</span>); <span class="comment">// We rejected a missing TLS segment above.</span></span><br><span class="line">          <span class="type">size_t</span> module_id = found_in-&gt;<span class="built_in">get_tls</span>()-&gt;module_id;</span><br><span class="line">          <span class="type">const</span> TlsModule&amp; mod = <span class="built_in">get_tls_module</span>(module_id);</span><br><span class="line">          <span class="keyword">if</span> (mod.static_offset != SIZE_MAX) &#123;</span><br><span class="line">            desc-&gt;func = tlsdesc_resolver_static;</span><br><span class="line">            desc-&gt;arg = mod.static_offset - relocator.tls_tp_base + sym_addr + addend;</span><br><span class="line">            <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLSDESC %16p &lt;- static (0x%zx - 0x%zx + 0x%zx + 0x%zx) %s&quot;</span>,</span><br><span class="line">                     rel_target, mod.static_offset, relocator.tls_tp_base,</span><br><span class="line">                     <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(sym_addr), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(addend),</span><br><span class="line">                     sym_name);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            relocator.tlsdesc_args-&gt;<span class="built_in">push_back</span>(&#123;</span><br><span class="line">              .generation = mod.first_generation,</span><br><span class="line">              .index.module_id = module_id,</span><br><span class="line">              .index.offset = sym_addr + addend,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// Defer the TLSDESC relocation until the address of the TlsDynamicResolverArg object</span></span><br><span class="line">            <span class="comment">// is finalized.</span></span><br><span class="line">            relocator.deferred_tlsdesc_relocs.<span class="built_in">push_back</span>(&#123;</span><br><span class="line">              desc, relocator.tlsdesc_args-&gt;<span class="built_in">size</span>() - <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">const</span> TlsDynamicResolverArg&amp; desc_arg = relocator.tlsdesc_args-&gt;<span class="built_in">back</span>();</span><br><span class="line">            <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLSDESC %16p &lt;- dynamic (gen %zu, mod %zu, off %zu) %s&quot;</span>,</span><br><span class="line">                     rel_target, desc_arg.generation, desc_arg.index.module_id,</span><br><span class="line">                     desc_arg.index.offset, sym_name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(__aarch64__) || defined(__riscv)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">case</span> R_X86_64_32:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">const</span> Elf32_Addr result = sym_addr + reloc.r_addend;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO R_X86_64_32 %16p &lt;- 0x%08x %s&quot;</span>,</span><br><span class="line">                 rel_target, result, sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;Elf32_Addr*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_X86_64_PC32:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> target </span>= sym_addr + reloc.r_addend;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> base </span>= <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">        <span class="type">const</span> Elf32_Addr result = target - base;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO R_X86_64_PC32 %16p &lt;- 0x%08x (%16p - %16p) %s&quot;</span>,</span><br><span class="line">                 rel_target, result, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(target),</span><br><span class="line">                 <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;Elf32_Addr*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__i386__)</span></span><br><span class="line">    <span class="keyword">case</span> R_386_PC32:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> target </span>= sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> base </span>= <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= target - base;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO R_386_PC32 %16p &lt;- 0x%08x (%16p - %16p) %s&quot;</span>,</span><br><span class="line">                 rel_target, result, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(target),</span><br><span class="line">                 <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;unknown reloc type %d in \&quot;%s\&quot;&quot;</span>, r_type, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="符号查找">符号查找</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> DoLogging&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">lookup_symbol</span><span class="params">(Relocator&amp; relocator, <span class="type">uint32_t</span> r_sym, <span class="type">const</span> <span class="type">char</span>* sym_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 soinfo** found_in, <span class="type">const</span> ElfW(Sym)** sym)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 看看是否在cache中                                    </span></span><br><span class="line">  <span class="keyword">if</span> (r_sym == relocator.cache_sym_val) &#123;</span><br><span class="line">    *found_in = relocator.cache_si;</span><br><span class="line">    *sym = relocator.cache_sym;</span><br><span class="line">    <span class="built_in">count_relocation_if</span>&lt;DoLogging&gt;(kRelocSymbolCached);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果有版本信息的话，获取版本信息</span></span><br><span class="line">    <span class="type">const</span> version_info* vi = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!relocator.si-&gt;<span class="built_in">lookup_version_info</span>(relocator.version_tracker, r_sym, sym_name, &amp;vi)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的lib查找符号</span></span><br><span class="line">    soinfo* local_found_in = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* local_sym </span>= <span class="built_in">soinfo_do_lookup</span>(sym_name, vi, &amp;local_found_in, relocator.lookup_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把找到的结果缓存一下，并将查找到的信息返回出去</span></span><br><span class="line">    relocator.cache_sym_val = r_sym;</span><br><span class="line">    relocator.cache_si = local_found_in;</span><br><span class="line">    relocator.cache_sym = local_sym;</span><br><span class="line">    *found_in = local_found_in;</span><br><span class="line">    *sym = local_sym;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*sym == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果没有找到，并且符号类型不是弱符号则查找失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ELF_ST_BIND</span>(relocator.si_symtab[r_sym].st_info) != STB_WEAK) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;cannot locate symbol \&quot;%s\&quot; referenced by \&quot;%s\&quot;...&quot;</span>, sym_name, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">count_relocation_if</span>&lt;DoLogging&gt;(kRelocSymbol);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的soinfo,查找符号</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* <span class="title">soinfo_do_lookup</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> version_info* vi,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  soinfo** si_found_in, <span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lookup_list.<span class="built_in">needs_slow_path</span>() ?</span><br><span class="line">      <span class="built_in">soinfo_do_lookup_impl</span>&lt;<span class="literal">true</span>&gt;(name, vi, si_found_in, lookup_list) :</span><br><span class="line">      <span class="built_in">soinfo_do_lookup_impl</span>&lt;<span class="literal">false</span>&gt;(name, vi, si_found_in, lookup_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsGeneral&gt;</span><br><span class="line">__attribute__((noinline)) <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>*</span></span><br><span class="line"><span class="function"><span class="title">soinfo_do_lookup_impl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> version_info* vi,</span></span></span><br><span class="line"><span class="params"><span class="function">                      soinfo** si_found_in, <span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算符号名的hash,名称长度                        </span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> [ hash, name_len ] = <span class="built_in">calculate_gnu_hash</span>(name);</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">uint32_t</span> kBloomMaskBits = <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr)) * <span class="number">8</span>;</span><br><span class="line">  <span class="function">SymbolName <span class="title">elf_symbol_name</span><span class="params">(name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得起始位置和结束位置，进行迭代查询。</span></span><br><span class="line">  <span class="type">const</span> SymbolLookupLib* end = lookup_list.<span class="built_in">end</span>();</span><br><span class="line">  <span class="type">const</span> SymbolLookupLib* it = lookup_list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前指向的lib</span></span><br><span class="line">    <span class="type">const</span> SymbolLookupLib* lib;</span><br><span class="line">    <span class="type">uint32_t</span> sym_idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over libraries until we find one whose Bloom filter matches the symbol we&#x27;re</span></span><br><span class="line">    <span class="comment">// searching for.</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果遍历完了，还没找到返回nullptr</span></span><br><span class="line">      <span class="keyword">if</span> (it == end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      lib = it++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral &amp;&amp; lib-&gt;<span class="built_in">needs_sysv_lookup</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="built_in">ElfW</span>(Sym)* sym = lib-&gt;si_-&gt;<span class="built_in">find_symbol_by_name</span>(elf_symbol_name, vi)) &#123;</span><br><span class="line">          *si_found_in = lib-&gt;si_;</span><br><span class="line">          <span class="keyword">return</span> sym;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral) &#123;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(lookup, <span class="string">&quot;SEARCH %s in %s@%p (gnu)&quot;</span>,</span><br><span class="line">                 name, lib-&gt;si_-&gt;<span class="built_in">get_realpath</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(lib-&gt;si_-&gt;base));</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// bloom过滤加快查找过程</span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; lib-&gt;gnu_maskwords_;</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> bloom_word </span>= lib-&gt;gnu_bloom_filter_[word_num];</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> h1 = hash % kBloomMaskBits;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> h2 = (hash &gt;&gt; lib-&gt;gnu_shift2_) % kBloomMaskBits;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) == <span class="number">1</span>) &#123;</span><br><span class="line">        sym_idx = lib-&gt;gnu_bucket_[hash % lib-&gt;gnu_nbucket_];</span><br><span class="line">        <span class="keyword">if</span> (sym_idx != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the library&#x27;s hash table chain.</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Versym) verneed = kVersymNotNeeded;</span><br><span class="line">    <span class="type">bool</span> calculated_verneed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> chain_value = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      sym = lib-&gt;symtab_ + sym_idx;</span><br><span class="line">      chain_value = lib-&gt;gnu_chain_[sym_idx];</span><br><span class="line">      <span class="keyword">if</span> ((chain_value &gt;&gt; <span class="number">1</span>) == (hash &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vi != <span class="literal">nullptr</span> &amp;&amp; !calculated_verneed) &#123;</span><br><span class="line">          calculated_verneed = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 查找匹配到的版本信息</span></span><br><span class="line">          verneed = <span class="built_in">find_verdef_version_index</span>(lib-&gt;si_, vi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看版本是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_symbol_version</span>(lib-&gt;versym_, sym_idx, verneed) &amp;&amp;</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(sym-&gt;st_name) + name_len + <span class="number">1</span> &lt;= lib-&gt;strtab_size_ &amp;&amp;</span><br><span class="line">            <span class="comment">// 比较名称是否相等</span></span><br><span class="line">            <span class="built_in">memcmp</span>(lib-&gt;strtab_ + sym-&gt;st_name, name, name_len + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// 判断符号是否是GLOBAL的，类型为（STB_GLOBAL或STB_WEAK）</span></span><br><span class="line">            <span class="built_in">is_symbol_global_and_defined</span>(lib-&gt;si_, sym)) &#123;</span><br><span class="line">            <span class="comment">// 如果都匹配就找到了，否则继续遍历    </span></span><br><span class="line">          *si_found_in = lib-&gt;si_;</span><br><span class="line">          <span class="keyword">return</span> sym;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++sym_idx;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((chain_value &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash计算</span></span><br><span class="line">__attribute__((unused))</span><br><span class="line"><span class="function"><span class="type">static</span> std::pair&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title">calculate_gnu_hash_simple</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* name_bytes = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(name);</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> unroll 8</span></span><br><span class="line">  <span class="keyword">while</span> (*name_bytes != <span class="number">0</span>) &#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">5</span>) + *name_bytes++; <span class="comment">// h*33 + c = h + h * 32 + c = h + h &lt;&lt; 5 + c</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; h, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(name_bytes) - name &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> std::pair&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title">calculate_gnu_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_GNU_HASH_NEON</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">calculate_gnu_hash_neon</span>(name);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">calculate_gnu_hash_simple</span>(name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_symbol_global_and_defined</span><span class="params">(<span class="type">const</span> soinfo* si, <span class="type">const</span> ElfW(Sym)* s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__predict_true(<span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info) == STB_GLOBAL ||</span><br><span class="line">                     <span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info) == STB_WEAK)) &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;st_shndx != SHN_UNDEF;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__predict_false(<span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info) != STB_LOCAL)) &#123;</span><br><span class="line">    <span class="built_in">DL_WARN</span>(<span class="string">&quot;Warning: unexpected ST_BIND value: %d for \&quot;%s\&quot; in \&quot;%s\&quot; (ignoring)&quot;</span>,</span><br><span class="line">            <span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info), si-&gt;<span class="built_in">get_string</span>(s-&gt;st_name), si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五调用构造器">五、调用构造器</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">soinfo::call_constructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We set constructors_called before actually calling the constructors, otherwise it doesn&#x27;t</span></span><br><span class="line">  <span class="comment">// protect against recursive constructor calls. One simple example of constructor recursion</span></span><br><span class="line">  <span class="comment">// is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so:</span></span><br><span class="line">  <span class="comment">// 1. The program depends on libc, so libc&#x27;s constructor is called here.</span></span><br><span class="line">  <span class="comment">// 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 3. dlopen() calls the constructors on the newly created</span></span><br><span class="line">  <span class="comment">//    soinfo for libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 4. The debug .so depends on libc, so CallConstructors is</span></span><br><span class="line">  <span class="comment">//    called again with the libc soinfo. If it doesn&#x27;t trigger the early-</span></span><br><span class="line">  <span class="comment">//    out above, the libc constructor will be called again (recursively!).</span></span><br><span class="line">  constructors_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_main_executable</span>() &amp;&amp; preinit_array_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// The GNU dynamic linker silently ignores these, but we warn the developer.</span></span><br><span class="line">    <span class="built_in">DL_WARN</span>(<span class="string">&quot;\&quot;%s\&quot;: ignoring DT_PREINIT_ARRAY in shared library!&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用所以子依赖的构造器</span></span><br><span class="line">  <span class="built_in">get_children</span>().for_each([] (soinfo* si) &#123;</span><br><span class="line">    si-&gt;<span class="built_in">call_constructors</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">    <span class="built_in">bionic_trace_begin</span>((std::<span class="built_in">string</span>(<span class="string">&quot;calling constructors: &quot;</span>) + <span class="built_in">get_realpath</span>()).<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用DT_INIT函数和DT_INIT_ARRAY中的所有函数</span></span><br><span class="line">  <span class="comment">// DT_INIT should be called before DT_INIT_ARRAY if both are present.</span></span><br><span class="line">  <span class="built_in">call_function</span>(<span class="string">&quot;DT_INIT&quot;</span>, init_func_, <span class="built_in">get_realpath</span>());</span><br><span class="line">  <span class="built_in">call_array</span>(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="literal">false</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">    <span class="built_in">bionic_trace_end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p>Android的namespace机制: <a
target="_blank" rel="noopener" href="https://zhenhuaw.me/blog/2017/namespace-based-dynamic-linking.html"
class="uri">https://zhenhuaw.me/blog/2017/namespace-based-dynamic-linking.html</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/code/" rel="tag"># code</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/09/06/android/native_dynamic/" rel="prev" title="Android动态链接技术一（ELF文件）">
                  <i class="fa fa-angle-left"></i> Android动态链接技术一（ELF文件）
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">blueberry · All rights reserved.</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
