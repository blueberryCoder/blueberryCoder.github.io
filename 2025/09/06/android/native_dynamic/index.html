<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blueberrycoder.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="前言 Android开发中涉及Native（C&#x2F;C++等）程序、接入外部动态库、处理线上崩溃、Native Hook、加固、逆向等，都需要了解到动态链接技术。 动态库与位置⽆关代码 共享库 使用一些高级语言（C&#x2F;C++）最终编译后产物是二进制文件。我们通常引用第三方库，会使用它的动态共享库。同时我们自己开发的二方库本身时也可能依赖其他的共享库，我们也可能给别人提供共享库。 我们为了代码复用，多个M">
<meta property="og:type" content="article">
<meta property="og:title" content="Android动态链接技术一（ELF文件）">
<meta property="og:url" content="https://blueberrycoder.github.io/2025/09/06/android/native_dynamic/index.html">
<meta property="og:site_name" content="Keep learning">
<meta property="og:description" content="前言 Android开发中涉及Native（C&#x2F;C++等）程序、接入外部动态库、处理线上崩溃、Native Hook、加固、逆向等，都需要了解到动态链接技术。 动态库与位置⽆关代码 共享库 使用一些高级语言（C&#x2F;C++）最终编译后产物是二进制文件。我们通常引用第三方库，会使用它的动态共享库。同时我们自己开发的二方库本身时也可能依赖其他的共享库，我们也可能给别人提供共享库。 我们为了代码复用，多个M">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_shared_library.png">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_static_shared_library.png">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_dynamic_shared_library.png">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_elf_brief.png">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_c_compilation.png">
<meta property="og:image" content="https://blueberrycoder.github.io/images/android/native_elf_ident.png">
<meta property="article:published_time" content="2025-09-06T02:43:41.000Z">
<meta property="article:modified_time" content="2025-11-02T06:54:24.311Z">
<meta property="article:author" content="blueberry">
<meta property="article:tag" content="code">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blueberrycoder.github.io/images/android/native_shared_library.png">


<link rel="canonical" href="https://blueberrycoder.github.io/2025/09/06/android/native_dynamic/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://blueberrycoder.github.io/2025/09/06/android/native_dynamic/","path":"2025/09/06/android/native_dynamic/","title":"Android动态链接技术一（ELF文件）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Android动态链接技术一（ELF文件） | Keep learning</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<script>
    console.log("head", JSON.stringify(``))
</script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Keep learning</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E4%BD%8D%E7%BD%AE%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">动态库与位置⽆关代码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">2.1.</span> <span class="nav-text">共享库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">2.2.</span> <span class="nav-text">静态共享库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">2.3.</span> <span class="nav-text">动态共享库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="nav-number">2.4.</span> <span class="nav-text">位置无关代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E5%9C%B0%E5%9D%80%E8%B7%B3%E8%BD%AC"><span class="nav-number">2.5.</span> <span class="nav-text">绝对地址跳转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">ELF文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">编译链接流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ehdr"><span class="nav-number">3.2.</span> <span class="nav-text">Ehdr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shdr"><span class="nav-number">3.3.</span> <span class="nav-text">Shdr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84section"><span class="nav-number">3.4.</span> <span class="nav-text">常见的Section</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#phdr"><span class="nav-number">3.5.</span> <span class="nav-text">Phdr</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">符号与符号表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8"><span class="nav-number">4.1.</span> <span class="nav-text">符号表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hash%E8%A1%A8"><span class="nav-number">4.2.</span> <span class="nav-text">Hash表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="nav-number">5.</span> <span class="nav-text">重定位</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E4%BF%A1%E6%81%AF"><span class="nav-number">5.1.</span> <span class="nav-text">重定位信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">重定位表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">重定位过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#r_aarch64_jump_slot"><span class="nav-number">5.3.1.</span> <span class="nav-text">R_AARCH64_JUMP_SLOT</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r_aarch64_glob_dat"><span class="nav-number">5.4.</span> <span class="nav-text">R_AARCH64_GLOB_DAT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r_aarch64_relative"><span class="nav-number">5.5.</span> <span class="nav-text">R_AARCH64_RELATIVE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r_aarch64_abs64"><span class="nav-number">5.6.</span> <span class="nav-text">R_AARCH64_ABS64</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dynamic%E6%AE%B5"><span class="nav-number">6.</span> <span class="nav-text">Dynamic段</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">blueberry</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blueberrycoder.github.io/2025/09/06/android/native_dynamic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blueberry">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep learning">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Android动态链接技术一（ELF文件） | Keep learning">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android动态链接技术一（ELF文件）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-06 10:43:41" itemprop="dateCreated datePublished" datetime="2025-09-06T10:43:41+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-02 14:54:24" itemprop="dateModified" datetime="2025-11-02T14:54:24+08:00">2025-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言">前言</h1>
<p>Android开发中涉及Native（C/C++等）程序、接入外部动态库、处理线上崩溃、Native
Hook、加固、逆向等，都需要了解到动态链接技术。</p>
<h1 id="动态库与位置关代码">动态库与位置⽆关代码</h1>
<h2 id="共享库">共享库</h2>
<p>使用一些高级语言（C/C++）最终编译后产物是二进制文件。我们通常引用第三方库，会使用它的动态共享库。同时我们自己开发的二方库本身时也可能依赖其他的共享库，我们也可能给别人提供共享库。</p>
<p>我们为了代码复用，多个Module复用同样的代码时，我们可以将这些代码剥离处理做成一个共享库供其使用。
<img src="/images/android/native_shared_library.png" alt="shared_library" width="720">
共享库又分为静态库库和动态共享库。</p>
<h2 id="静态共享库">静态共享库</h2>
<p>静态库是编译时依赖，即编译程序时，会将共享库的内容打包到可执行程序中（假设我们是一个可执行程序，依赖一个共享库）。而静态库不会作为单独的文件和可执行程序发布。
<img src="/images/android/native_static_shared_library.png" alt="static_shared" width="720"></p>
<h2 id="动态共享库">动态共享库</h2>
<p>动态库是运行时依赖，即编译程序时，不会将共享库的内容打包到可执行程序。发布程序时需要将动态库一起发布。
<img src="/images/android/native_dynamic_shared_library.png" alt="dynamic_shared" width="720"></p>
<h2 id="位置无关代码">位置无关代码</h2>
<p>因为动态库是要运行时动态加载，其加载位置即运行时地址是不固定的。因此需要保证代码时位置无关的(PIC,
Position Idependent Code)。 为了接下来的演示，我在Android
Arm64平台写下如下代码: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SayHelloWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (i++ % <span class="number">2</span>  == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_blueberry_anative_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SayHelloWrapper</span>();</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这段代码编译完后，我们可以在arm64-v8a目录中得到动态(libanative.so)。</p>
<p>我们使用<code>objdump -d libanative.so</code>
对产物进行反汇编。可以得到： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   1dc68:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000001dc6c &lt;SayHelloWrapper&gt;:</span><br><span class="line">// 指令地址    机器码           汇编指令                 符号名（可选）</span><br><span class="line">   1dc6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!</span><br><span class="line">   1dc70:	910003fd 	mov	x29, sp</span><br><span class="line">   1dc74:	14000001 	b	1dc78 &lt;SayHelloWrapper+0xc&gt;</span><br><span class="line">   1dc78:	f000014a 	adrp	x10, 48000 &lt;_DYNAMIC+0x12b8&gt;</span><br><span class="line">   1dc7c:	b9446148 	ldr	w8, [x10, #1120]</span><br><span class="line">   1dc80:	11000509 	add	w9, w8, #0x1</span><br><span class="line">   1dc84:	b9046149 	str	w9, [x10, #1120]</span><br><span class="line">   1dc88:	5280004a 	mov	w10, #0x2                   	// #2</span><br><span class="line">   1dc8c:	1aca0d09 	sdiv	w9, w8, w10</span><br><span class="line">   1dc90:	1b0a7d29 	mul	w9, w9, w10</span><br><span class="line">   1dc94:	6b090108 	subs	w8, w8, w9</span><br><span class="line">   1dc98:	35000068 	cbnz	w8, 1dca4 &lt;SayHelloWrapper+0x38&gt;</span><br><span class="line">   1dc9c:	14000001 	b	1dca0 &lt;SayHelloWrapper+0x34&gt;</span><br><span class="line">   1dca0:	14000002 	b	1dca8 &lt;SayHelloWrapper+0x3c&gt;</span><br><span class="line">   1dca4:	17fffff5 	b	1dc78 &lt;SayHelloWrapper+0xc&gt;</span><br><span class="line">   1dca8:	9400920e 	bl	424e0 &lt;SayHello@plt&gt;</span><br><span class="line">   1dcac:	a8c17bfd 	ldp	x29, x30, [sp], #16</span><br><span class="line">   1dcb0:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000001dcb4 &lt;Java_com_blueberry_anative_MainActivity_stringFromJNI&gt;:</span><br><span class="line">   1dcb4:	d10183ff 	sub	sp, sp, #0x60</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
上面的是SayHelloWrapper这个函数对应的汇编指令，我们来看这一行：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1dca0:	14000002 	b	1dca8 &lt;SayHelloWrapper+0x3c&gt;</span><br></pre></td></tr></table></figure>
这条指令对应的汇编语言是跳转到1dca8地址，即当前指令地址+2的位置，这里+2的单位是指令长度。虽然反汇编的结果是直接指向这个地址值，但它的指令其实用的是相对偏移。这一点从它的机器码的地位其实可以看出端倪（它的末尾是2）。另外这些指令的地址都是相对地址并不是动态库被加载后的运行时的地址。运行时的真实地址是基地址(load_bias)+这里的相对地址。load_bias为加载动态库后的执行段的起始地址。</p>
<p>这里的指令集是AArch64指令集，其中b指令的格式为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">31  30........5    0</span><br><span class="line">|  opcode=000101   | imm26 |</span><br><span class="line">- 高 6 位固定 = 000101 (0x05)</span><br><span class="line">- 剩下 26 位是带符号偏移量 imm26（相对于当前指令地址，单位是 4 字节）</span><br></pre></td></tr></table></figure>
0x14000002的二进制是：<code>0001 0100 0000 0000 0000 0000 0000 0010</code>
这条指令的opcode = 000101，imm26 = 0x0000002的偏移量 = 2 * 4 = 8
字节，也就是跳转的目标地址是距离当前指令地址+8字节的地址，因为当前指令的地址是：1dca0，所有目标地址是：1dca8。那么无论这个动态库被加载在什么位置都不影响这个跳转指令的正确性。</p>
<h2 id="绝对地址跳转">绝对地址跳转</h2>
<p>当跨模块调用时，比如我们上面的代码在SayHello中使用了libc的printf函数。编译器在编译期间是无法知道这个函数的地址的，它是怎么保证跳转的正确呢？
那么我们先来使用objdump看下SayHello函数的汇编指令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">000000000001dc50 &lt;SayHello&gt;:</span><br><span class="line">   1dc50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!</span><br><span class="line">   1dc54:	910003fd 	mov	x29, sp</span><br><span class="line">   1dc58:	d0ffffa0 	adrp	x0, 13000 &lt;GCC_except_table133+0x14&gt;</span><br><span class="line">   1dc5c:	913be000 	add	x0, x0, #0xef8</span><br><span class="line">   1dc60:	94009224 	bl	424f0 &lt;printf@plt&gt;</span><br><span class="line">   1dc64:	a8c17bfd 	ldp	x29, x30, [sp], #16</span><br><span class="line">   1dc68:	d65f03c0 	ret</span><br></pre></td></tr></table></figure> 其中：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1dc60:	94009224 	bl	424f0 &lt;printf@plt&gt;  </span><br></pre></td></tr></table></figure>
是想跳转到printf函数，它跳转的地址是424f0，对应的符号是printf@plt。
我们使用<code>objdump -d -j .plt libanative.so</code>查看对应plt表，得到：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">00000000000424f0 &lt;printf@plt&gt;:</span><br><span class="line">   424f0:	b0000030 	adrp	x16, 47000 &lt;_ZTVSt9bad_alloc@@Base+0x740&gt;</span><br><span class="line">   424f4:	f9402e11 	ldr	x17, [x16, #88]</span><br><span class="line">   424f8:	91016210 	add	x16, x16, #0x58</span><br><span class="line">   424fc:	d61f0220 	br	x17</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
可以看到地址00000000000424f0对应的代码段，它只有4条指令。这段代码通常被称为“蹦床（trampoline”或跳板函数(stubs)。下面我们逐行解释下这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">00000000000424f0 &lt;printf@plt&gt;:</span><br><span class="line">   // 将47000（.got.plt表的基址）放到x16寄存器。</span><br><span class="line">   424f0:	b0000030 	adrp	x16, 47000 &lt;_ZTVSt9bad_alloc@@Base+0x740&gt;</span><br><span class="line">   // 将x16寄存器的值+88得到的地址存放到x17寄存器。（即got表中这个函数对应的slot地址）</span><br><span class="line">   424f4:	f9402e11 	ldr	x17, [x16, #88]</span><br><span class="line">   // 将x16寄存器的值加0x58也就是十进制88,（即got表中这个函数对应的slot地址）用户之后的resolve回填函数地址。</span><br><span class="line">   424f8:	91016210 	add	x16, x16, #0x58</span><br><span class="line">   // 跳转到x17中存放的地址（即got表中对应的地址）。</span><br><span class="line">   424fc:	d61f0220 	br	x17</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的代码首先会找到GOT表的基地址，然后加上当前函数对应在got表slot槽的偏移。然后往这个slot对应的地址跳转，并且用x16保存了slot的地址。即x16存放的是slot的地址，x17存放的是slot中值。slot中存放的值是目标函数的地址即printf函数的地址（假设已经完成延时绑定的话）。</p>
<p>下面我们来看got表的信息，着重看got表0x58偏移对应的内容（got表的基地址为0x47000）。
因为.got.plt是数据段，我们用<code>objdump -s -j .got -j .got.plt libanative.so</code>来查看：</p>
<p>.got用来保存全局变量引用的地址，.got.plt用来保存函数引用的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a objdump -s -j .got  -j .got.plt libanative.so</span><br><span class="line"></span><br><span class="line">libanative.so:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Contents of section .got:</span><br><span class="line"> 46f18 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f28 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f38 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f48 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f58 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f68 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f78 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f88 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f98 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fa8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fb8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fc8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fd8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fe8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46ff8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 47008 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 47018 00000000 00000000                    ........</span><br><span class="line">Contents of section .got.plt:</span><br><span class="line"> 47020 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 47030 00000000 00000000 90240400 00000000  .........$......</span><br><span class="line"> 47040 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47050 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47060 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47070 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47080 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47090 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 470a0 90240400 00000000 90240400 00000000  .$.......$......</span><br></pre></td></tr></table></figure>
<p>最左边一列是数据的地址，后面的4列是数据，数据是以小端方式排列的。一行显示16字节，那么0x47000
+ 0x58对应的槽的就在数据的第4行第3列。 它的值为90240400
00000000，另外我们可以看到got表中前0x47038前的都是0，后面每个槽的值都是90240400
00000000。（这里每个槽都是8个字节）。</p>
<p>这里是因为，GOT表中的前几个槽都时预留的不给我们的代码使用，后续的槽默认都PLT0(PLT表的基地址)。</p>
<p>具体来讲，我通过查资料得到在linux系统中动态库被加载后动态加载器会给他们赋值：</p>
<p>GOT[0]:保存的是.dynamic段的地址（即动态段的起始地址）。动态链接器ld.so启动时会用这个地址来获取需要解析的动态信息，比如
.dynsym、.dynstr、.rel.plt等表。</p>
<p>GOT[1]:保存的是linker/loader的解析函数地址，即_dl_runtime_resolve（或平台相关的
resolver stub）。当你第一次调用某个外部函数时，PLT
entry会跳到GOT[1]指向的解析器。解析器会根据GOT[2]+槽地址找到具体要解析的符号，然后去加载对应的动态库函数地址。</p>
<p>GOT[2]:保存的是link_map
结构体指针，这是动态链接器内部维护的ELF链接状态表（每个已加载的共享对象有一个link_map节点）。_dl_runtime_resolve通过GOT[2]能够知道“当前进程有哪些已加载的库”，从而去符号查找、重定位。</p>
<p>但通过我们这个Android平台的so文件，我发现GOT[6]（这个例子中就是地址0x47030）应该存储的是linker/loader的解析函数地址，即_dl_runtime_resolve。
另外我们也可以通过readelf查看槽位的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r libanative.so</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x11d88 contains 122 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000047038  000100000402 R_AARCH64_JUMP_SL 0000000000000000 __cxa_finalize@LIBC + 0</span><br><span class="line">000000047040  000200000402 R_AARCH64_JUMP_SL 0000000000000000 __cxa_atexit@LIBC + 0</span><br><span class="line">000000047048  000300000402 R_AARCH64_JUMP_SL 0000000000000000 __register_atfork@LIBC + 0</span><br><span class="line">000000047050  021400000402 R_AARCH64_JUMP_SL 000000000001dc50 SayHello + 0</span><br><span class="line">000000047058  000400000402 R_AARCH64_JUMP_SL 0000000000000000 printf@LIBC + 0</span><br><span class="line">000000047060  018900000402 R_AARCH64_JUMP_SL 000000000001dc6c SayHelloWrapper + 0</span><br><span class="line">000000047068  01aa00000402 R_AARCH64_JUMP_SL 000000000001dd64 _ZNSt6__ndk112bas[...</span><br></pre></td></tr></table></figure>
<p>我们可以看到printf函数对应的槽信息，它的类型为：R_AARCH64_JUMP_SLOT
表示“这个 GOT 条目需要在运行时被填充成目标函数的真实地址”。</p>
<p>90240400 00000000
因为是小端存储的，所以对应的值是：0x402490，它就是PLT0的地址。
我们使用<code>objdump -d -j .plt libanative.so</code>来看.plt表来验证。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// PLT 表头（PLT0）</span><br><span class="line">0000000000042490 &lt;__cxa_finalize@plt-0x20&gt;:</span><br><span class="line">//  入栈保存 x16/IP0 与 LR（x30）</span><br><span class="line">   42490:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!</span><br><span class="line">// x16 = .got.plt 所在页基址   </span><br><span class="line">   42494:	b0000030 	adrp	x16, 47000 &lt;_ZTVSt9bad_alloc@@Base+0x740&gt;</span><br><span class="line">// x17 = [.got.plt + 0x30（48）]（解析器入口指针 _dl_runtime_resolve）   </span><br><span class="line">   42498:	f9401a11 	ldr	x17, [x16, #48]</span><br><span class="line">// x16 =  .got.plt + 0x30（把“当前槽地址”传给解析器）   </span><br><span class="line">   4249c:	9100c210 	add	x16, x16, #0x30</span><br><span class="line">//  跳到解析器（_dl_runtime_resolve 的桩）   </span><br><span class="line">   424a0:	d61f0220 	br	x17</span><br><span class="line">   424a4:	d503201f 	nop</span><br><span class="line">   424a8:	d503201f 	nop</span><br><span class="line">   424ac:	d503201f 	nop</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
从上面的分析，我们得到我们在第一次调用print这个外部函数时，由于GOT表中的条目是指向PLT0，所以我们最终调用了_dl_runtime_resolve函数。</p>
<p>_dl_runtime_resolve因为知道GOT表的槽（保存在x16寄存器的槽位置）并且通过.rela.plt也能知道我们调用的函数的符号信息，找到对应的外部函数的地址。然后执行，并且将查到的地址写入到我们槽。那么下次再调用这个函数就不用再执行解析操作了。这个机制也叫延时绑定机制(lazy
binding)。</p>
<p>_dl_runtime_resolve是一个glibc中的一个汇编段，它在dl-trampoline.S文件中。
它的大致实现为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* RELA relocatons are 3 pointers */</span><br><span class="line">#define RELA_SIZE (PTR_SIZE * 3)</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.globl _dl_runtime_resolve</span><br><span class="line">	.type _dl_runtime_resolve, #function</span><br><span class="line">	cfi_startproc</span><br><span class="line">	.align 2</span><br><span class="line">_dl_runtime_resolve:</span><br><span class="line">	/* AArch64 we get called with:</span><br><span class="line">	   ip0		&amp;PLTGOT[2]</span><br><span class="line">	   ip1		temp(dl resolver entry point)</span><br><span class="line">	   [sp, #8]	lr</span><br><span class="line">	   [sp, #0]	&amp;PLTGOT[n]</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	cfi_rel_offset (lr, 8)</span><br><span class="line"></span><br><span class="line">	/* Save arguments.  */</span><br><span class="line">	stp	x8, x9, [sp, #-(80+8*16)]!</span><br><span class="line">	cfi_adjust_cfa_offset (80+8*16)</span><br><span class="line">	cfi_rel_offset (x8, 0)</span><br><span class="line">	cfi_rel_offset (x9, 8)</span><br></pre></td></tr></table></figure> <a
target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.29/source/sysdeps/aarch64/dl-trampoline.S"
class="uri">https://elixir.bootlin.com/glibc/glibc-2.29/source/sysdeps/aarch64/dl-trampoline.S</a></p>
<p>但是Android使用的bionic的libc，它没有_dl_runtime_resolve函数的定义，上述代码PLT[0]，以及调用_dl_runtime_resolve的方式是我查资料，并且在linux的gcc
libc中看到实现。
而Android默认并没有开启延时绑定（RTLD_LAZY），它在so加载时直接进行了绑定。</p>
<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/bionic/"
class="uri">https://android.googlesource.com/platform/bionic/</a></p>
<h1 id="elf文件格式">ELF文件格式</h1>
<p>ELF（Executable and Linkable
Format）常见发音：(/ɛlf/)，elf的中文意义也有小精灵、精灵族的意思。ELF文件是linux平台使用的一个二进制文件格式。我们平时的.o文件(可重定位文件)、so文件、可执行文件、coredump文件都是ELF文件格式。</p>
<p><img src="/images/android/native_elf_brief.png" alt="elf_brief" width="720"></p>
<h2 id="编译链接流程">编译链接流程</h2>
<p>如图描述了c/c++程序编译&amp;链接的流程。
<img src="/images/android/native_c_compilation.png" alt="elf_brief" width="720"></p>
<h2 id="ehdr">Ehdr</h2>
<p>Ehdr，定义了文件基础信息，它在整个文件的开头，它拥有文件的标识（Magic
为’E’,‘L’,‘F’）、ELF版本号、CPU架构类型、程序入的虚拟地址、Promgram
header表的偏移、数量、Section Header表的偏移、数量、Section
String表的偏移、大小等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#define EI_NIDENT (16)</span><br><span class="line">// 32 bit</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */</span><br><span class="line">  Elf32_Half	e_type;			/* Object file type */</span><br><span class="line">  Elf32_Half	e_machine;		/* Architecture */</span><br><span class="line">  Elf32_Word	e_version;		/* Object file version */</span><br><span class="line">  Elf32_Addr	e_entry;		/* Entry point virtual address */</span><br><span class="line">  Elf32_Off	e_phoff;		/* Program header table file offset */</span><br><span class="line">  Elf32_Off	e_shoff;		/* Section header table file offset */</span><br><span class="line">  Elf32_Word	e_flags;		/* Processor-specific flags */</span><br><span class="line">  Elf32_Half	e_ehsize;		/* ELF header size in bytes */</span><br><span class="line">  Elf32_Half	e_phentsize;		/* Program header table entry size */</span><br><span class="line">  Elf32_Half	e_phnum;		/* Program header table entry count */</span><br><span class="line">  Elf32_Half	e_shentsize;		/* Section header table entry size */</span><br><span class="line">  Elf32_Half	e_shnum;		/* Section header table entry count */</span><br><span class="line">  Elf32_Half	e_shstrndx;		/* Section header string table index */</span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line">// 64bit</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */</span><br><span class="line">  Elf64_Half	e_type;			/* Object file type */</span><br><span class="line">  Elf64_Half	e_machine;		/* Architecture */</span><br><span class="line">  Elf64_Word	e_version;		/* Object file version */</span><br><span class="line">  Elf64_Addr	e_entry;		/* Entry point virtual address */</span><br><span class="line">  Elf64_Off	e_phoff;		/* Program header table file offset */</span><br><span class="line">  Elf64_Off	e_shoff;		/* Section header table file offset */</span><br><span class="line">  Elf64_Word	e_flags;		/* Processor-specific flags */</span><br><span class="line">  Elf64_Half	e_ehsize;		/* ELF header size in bytes */</span><br><span class="line">  Elf64_Half	e_phentsize;		/* Program header table entry size */</span><br><span class="line">  Elf64_Half	e_phnum;		/* Program header table entry count */</span><br><span class="line">  Elf64_Half	e_shentsize;		/* Section header table entry size */</span><br><span class="line">  Elf64_Half	e_shnum;		/* Section header table entry count */</span><br><span class="line">  Elf64_Half	e_shstrndx;		/* Section header string table index */</span><br><span class="line">&#125; Elf64_Ehdr;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e_ident的结构为：
<img src="/images/android/native_elf_ident.png" alt="ident" width="720"></p>
<p>通过<code>readelf -h libanative.so</code>我们也能查看文件的头信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -h libanative.so</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          1897688 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         34</span><br><span class="line">  Section header string table index: 32</span><br></pre></td></tr></table></figure>
<p>文件头信息中，多数信息是固定不变的（Margic、Version、Machine等）。所以我们重点关注下e_phoff
、 e_shoff 、 e_phnum 、 e_shnum 、
e_shstrndx这些值。这几个字段描述了三类信息：Section头、Program头、字符串。</p>
<p>Section和Program是对这个文件的两种不同视角的描述，Section为不加载的情况下的静态分析视角、Pragma描述的是文件加载后的运行时视角。</p>
<h2 id="shdr">Shdr</h2>
<p>Section Header,
ELF文件中的代码(code)、数据(data)分为了一些连续的块。Section
Header就是描述这些块的名称、类型、在文件中的偏移、被加载后的虚拟地址（应该被加载在什么地方）、大小等。为了节省篇幅，我后续只贴出64位的数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word	sh_name;		/* Section name (string tbl index) */</span><br><span class="line">  Elf64_Word	sh_type;		/* Section type */</span><br><span class="line">  Elf64_Xword	sh_flags;		/* Section flags */</span><br><span class="line">  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */</span><br><span class="line">  Elf64_Off	sh_offset;		/* Section file offset */</span><br><span class="line">  Elf64_Xword	sh_size;		/* Section size in bytes */</span><br><span class="line">  Elf64_Word	sh_link;		/* Link to another section */</span><br><span class="line">  Elf64_Word	sh_info;		/* Additional section information */</span><br><span class="line">  Elf64_Xword	sh_addralign;		/* Section alignment */</span><br><span class="line">  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p>这里的sh_name描述了Section的名称，但它并不是一个字符串而是指向字符串表的索引。字符串表也是一个Section，它是一个字符串池，也有自己的压缩方式。
我们可以使用<code>readelf -S libanative.so</code>来查看ELF文件中的所有Section
Header: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -S libanative.so</span><br><span class="line">There are 34 section headers, starting at offset 0x1cf4d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.androi[...] NOTE             0000000000000238  00000238</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .note.gnu.bu[...] NOTE             00000000000002d0  000002d0</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .dynsym           DYNSYM           00000000000002f8  000002f8</span><br><span class="line">       0000000000003708  0000000000000018   A       7     1     8</span><br><span class="line">  [ 4] .gnu.version      VERSYM           0000000000003a00  00003a00</span><br><span class="line">       0000000000000496  0000000000000002   A       3     0     2</span><br><span class="line">  [ 5] .gnu.version_r    VERNEED          0000000000003e98  00003e98</span><br><span class="line">       0000000000000040  0000000000000000   A       7     2     4</span><br><span class="line">  [ 6] .gnu.hash         GNU_HASH         0000000000003ed8  00003ed8</span><br><span class="line">       0000000000000e2c  0000000000000000   A       3     0     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000004d04  00004d04</span><br><span class="line">       000000000000484a  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .rela.dyn         RELA             0000000000009550  00009550</span><br><span class="line">       0000000000008838  0000000000000018   A       3     0     8</span><br><span class="line">  [ 9] .rela.plt         RELA             0000000000011d88  00011d88</span><br><span class="line">       0000000000000b70  0000000000000018  AI       3    21     8</span><br><span class="line">  [10] .gcc_except_table PROGBITS         00000000000128f8  000128f8</span><br><span class="line">       0000000000000bc0  0000000000000000   A       0     0     4</span><br><span class="line">  [11] .rodata           PROGBITS         00000000000134c0  000134c0</span><br><span class="line">       000000000000364c  0000000000000000 AMS       0     0     16</span><br><span class="line">  [12] .eh_frame_hdr     PROGBITS         0000000000016b0c  00016b0c</span><br><span class="line">       0000000000001534  0000000000000000   A       0     0     4</span><br><span class="line">  [13] .eh_frame         PROGBITS         0000000000018040  00018040</span><br><span class="line">       0000000000005ba4  0000000000000000   A       0     0     8</span><br><span class="line">  [14] .text             PROGBITS         000000000001dbf0  0001dbf0</span><br><span class="line">       0000000000024894  0000000000000000  AX       0     0     16</span><br><span class="line">  [15] .plt              PROGBITS         0000000000042490  00042490</span><br><span class="line">       00000000000007c0  0000000000000000  AX       0     0     16</span><br><span class="line">  [16] .data.rel.ro      PROGBITS         0000000000043c50  00042c50</span><br><span class="line">       00000000000030e0  0000000000000000  WA       0     0     8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY       0000000000046d30  00045d30</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000046d40  00045d40</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [19] .dynamic          DYNAMIC          0000000000046d48  00045d48</span><br><span class="line">       00000000000001d0  0000000000000010  WA       7     0     8</span><br><span class="line">  [20] .got              PROGBITS         0000000000046f18  00045f18</span><br><span class="line">       0000000000000108  0000000000000000  WA       0     0     8</span><br><span class="line">  [21] .got.plt          PROGBITS         0000000000047020  00046020</span><br><span class="line">       00000000000003e8  0000000000000000  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         0000000000048408  00046408</span><br><span class="line">       0000000000000058  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           0000000000048460  00046460</span><br><span class="line">       0000000000000ac0  0000000000000000  WA       0     0     16</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  00046460</span><br><span class="line">       00000000000000b1  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .debug_abbrev     PROGBITS         0000000000000000  00046511</span><br><span class="line">       0000000000004286  0000000000000000           0     0     1</span><br><span class="line">  [26] .debug_info       PROGBITS         0000000000000000  0004a797</span><br><span class="line">       000000000006df30  0000000000000000           0     0     1</span><br><span class="line">  [27] .debug_ranges     PROGBITS         0000000000000000  000b86c7</span><br><span class="line">       0000000000022bd0  0000000000000000           0     0     1</span><br><span class="line">  [28] .debug_str        PROGBITS         0000000000000000  000db297</span><br><span class="line">       000000000003acd0  0000000000000001  MS       0     0     1</span><br><span class="line">  [29] .debug_line       PROGBITS         0000000000000000  00115f67</span><br><span class="line">       0000000000025b35  0000000000000000           0     0     1</span><br><span class="line">  [30] .debug_loc        PROGBITS         0000000000000000  0013ba9c</span><br><span class="line">       000000000006f3b4  0000000000000000           0     0     1</span><br><span class="line">  [31] .symtab           SYMTAB           0000000000000000  001aae50</span><br><span class="line">       0000000000010ed8  0000000000000018          33   2303     8</span><br><span class="line">  [32] .shstrtab         STRTAB           0000000000000000  001bbd28</span><br><span class="line">       0000000000000163  0000000000000000           0     0     1</span><br><span class="line">  [33] .strtab           STRTAB           0000000000000000  001bbe8b</span><br><span class="line">       0000000000013649  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure></p>
<p>重点看下字段的类型吧，</p>
<p><strong>sh_type</strong></p>
<pre><code>- SHT_NULL ：Section入口（未使用）
- SHT_PROGBITS ：存放指令、常量。
- SHT_SYMTAB ： 静态符号表
- SHT_STRTAB： 字符串表
- SHT_RELA： 重定位信息(有addends)
- SHT_HASH： 哈希表
- SHT_DYNAMIC： 动态链接信息
- SHT_NOTE： Note
- SHT_NOBITS： 未初始化数据
- SHT_REL: 重定位信息(无addends)
- SHT_DYNSYM：动态链接符号表</code></pre>
<p><strong>sh_flags</strong></p>
<pre><code>- SHF_WRITE：运行时可写入。
- SHF_ALLOC：运行时将被加载到虚拟内存。
- SHF_EXECINSTR： 包含可执行指令。</code></pre>
<p><strong>sh_addr</strong></p>
<p>该Section在运行时的虚拟地址。</p>
<p><strong>sh_offset</strong></p>
<p>该Section在ELF文件中的偏移。</p>
<h2 id="常见的section">常见的Section</h2>
<ul>
<li>.init
存放程序最开始执行时的任务。（可执行文件中，这里面的程序会运行在main函数之前）。</li>
<li>.fini 存放程序结束时需要运行的代码。</li>
<li>.text 存放用户写的代码。</li>
<li>.bss
存放没有初始化的数据，它不占用磁盘（避免空间开销）所以它的数据会在运行时被初始化为0。编译器/链接器只需要知道
.bss 这块区域需要多大。</li>
<li>.data 存放程序的初始化数据。</li>
<li>.rodata 存放程序的只读数据，如程序中用到的字符串。</li>
<li>.plt 即 Procedure Linkage
Table上文已经提到，它和GOT表一起来实现调用外部函数。</li>
<li>.got.plt 用于延时绑定，上文已经提到。</li>
<li>.rel.* 包含重定向的信息，_dl_runtime_resolv
借助它来寻找外部函数以及修改GOT表。</li>
<li>.rela.* 同上，只是它有addend信息。</li>
<li>.dynamic
动态链接的数据结构和对象，用来描述依赖库、符号表、重定位信息、初始化/析构函数等；它是动态链接工作的“说明书”。</li>
<li>.init_array
存放一组函数指针，这组函数会在可执行文件初始化后立即执行。C语言中<code>__attribute__((constructor)</code>标记的函数就会存放在这里。</li>
<li>.fini_array 与.init_array相反，程序销毁的时候执行。</li>
<li>.shstrtab 字符串表，存放一些节区名（.text、.data 等）</li>
<li>.symtab 符号表，如存放函数、变量的符号。</li>
<li>.strtab 字符串表，符号名（函数、变量、文件名等）</li>
<li>.dynsym 动态链接符号表。</li>
<li>.dynstr 字符串表，用于动态链接时。</li>
<li>.interp RTLD_* 是一组 动态加载标志（flags），用于 dlopen()
这个函数。如：RTLD_LAZY，懒解析：只在第一次调用符号时才解析。RTLD_NOW
立即解析：dlopen() 时就把所有未定义符号解析完（性能差但安全）。</li>
<li>.rel.dyn 全局变量可重定位表。</li>
<li>.rel.plt 函数可重定位表。</li>
<li>.eh_frame 发生crash后，用于栈展开（unwind）。</li>
</ul>
<p>为了加载可执行文件，我们需要以不同的方式组织code和data，所有ELF有另一种逻辑视图（运行视图），它叫做segments，它用在运行时。相对应的上面讲的Section它可能用在静态链接时，以及我们用工具分析二进制文件时。</p>
<p>所有理论上Section信息时，在运行时是可选的（我分析bionic时，如果有section
信息，加载器也会读取）。程序通过Pragma
header就可以知道如何去加载这个ELF文件到内存中。</p>
<h2 id="phdr">Phdr</h2>
<p>与Shdr相对，Phdr是提供segments视图(运行视图)，它给操作系统或动态链接器（dynamic-linker）提供了如何去加载这个程序的信息。与之相对的Shdr可以看作是提供给程序静态链接用的。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word	p_type;		/* Segment type */</span><br><span class="line">  Elf64_Word	p_flags;		/* Segment flags */</span><br><span class="line">  Elf64_Off	p_offset;		/* Segment file offset */</span><br><span class="line">  Elf64_Addr	p_vaddr;		/* Segment virtual address */</span><br><span class="line">  Elf64_Addr	p_paddr;		/* Segment physical address */</span><br><span class="line">  Elf64_Xword	p_filesz;		/* Segment size in file */</span><br><span class="line">  Elf64_Xword	p_memsz;		/* Segment size in memory */</span><br><span class="line">  Elf64_Xword	p_align;		/* Segment alignment */</span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
这个头信息描述了Segemnt的类型、标志、在ELF文件中的偏移、被加载的虚拟的地址、物理地址、该Segement在文件中的大小、在内存中的占用大小等。</p>
<p><strong>p_offset</strong></p>
<p>Segment在文件中的偏移。</p>
<p><strong>p_vaddr</strong></p>
<p>Segment在内存中的虚拟地址，（对于可加载段，p_vaddr % PAGE_SIZE 必须和
p_offset % PAGE_SIZE相等）。</p>
<p><strong>p_paddr</strong></p>
<p>物理地址，适用于没有MMU的操作系统，对于现代的操作系统无用。</p>
<p><strong>p_memsz</strong></p>
<p>Segment在内存中的大小。（一些Section只指定了需要在内存中分配多大空间，并不要求将Section中的数据映射到内存，比如.bss）。</p>
<p>同样我们可以用readelf查看Segments Header的信息。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -l libanative.so</span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R      0x8</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000042c50 0x0000000000042c50  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000037b8  RW     0x1000</span><br><span class="line">  LOAD           0x0000000000046408 0x0000000000048408 0x0000000000048408</span><br><span class="line">                 0x0000000000000058 0x0000000000000b18  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000045d48 0x0000000000046d48 0x0000000000046d48</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  GNU_RELRO      0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000043b0  R      0x1</span><br><span class="line">  GNU_EH_FRAME   0x0000000000016b0c 0x0000000000016b0c 0x0000000000016b0c</span><br><span class="line">                 0x0000000000001534 0x0000000000001534  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x0</span><br><span class="line">  NOTE           0x0000000000000238 0x0000000000000238 0x0000000000000238</span><br><span class="line">                 0x00000000000000bc 0x00000000000000bc  R      0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .note.android.ident .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .gcc_except_table .rodata .eh_frame_hdr .eh_frame .text .plt</span><br><span class="line">   02     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   03     .data .bss</span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .note.android.ident .note.gnu.build-id</span><br></pre></td></tr></table></figure>
从上面的信息中，我们可以看到Segemnts的被映射的地址范围、标记、权限信息。以及每个Segment与Sections的对应关系。
这个so文件中：</p>
<p>PHDR：是Program Header自身。</p>
<p>GNU_STACK：
表示的是程序的栈是否允许有可执⾏权限，其p_flags⼀般是RW，表示栈不允许有可执⾏权限。</p>
<p>LOAD: 有3个LOAD Segments他们的执行权限分别是：R、RE、RW。</p>
<p>DYNAMIC： 内存映射结束后，dynamic
linker还会去查找外部符号（函数、变量）的地址，并填写GOT表的Slot，这个过程叫重定向，其相关的信息都在.dynamic中。</p>
<p>NOTE：
是一些非必要的注释信息，其中.note.gnu.build-id是动态库的build-id信息。</p>
<p>GNU_EH_FRAME：用于栈回溯。</p>
<h1 id="符号与符号表">符号与符号表</h1>
<p>符号是一些data或code的一种符号化引用，例如一些函数、变量的引用。</p>
<p>它的结构如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word	st_name;		/* Symbol name (string tbl index) */</span><br><span class="line">  unsigned char	st_info;		/* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;		/* Symbol visibility */</span><br><span class="line">  Elf64_Section	st_shndx;		/* Section index */</span><br><span class="line">  Elf64_Addr	st_value;		/* Symbol value */</span><br><span class="line">  Elf64_Xword	st_size;		/* Symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></p>
<p><strong>st_name</strong></p>
<p>符号名称。</p>
<p><strong>st_info</strong></p>
<p>符号的binding和类型，binging有：</p>
<ul>
<li>STB_LOCAL：局部符号（仅当前文件可见）</li>
<li>STB_GLOBAL：全局符号（可导出/可被其他文件引用）</li>
<li>STB_WEAK：弱符号（可被同名全局符号覆盖）</li>
</ul>
<p>常见的类型有：</p>
<ul>
<li>STT_NOTYPE： 未定义类型</li>
<li>STT_FUNC： 函数类型、或其它可执行代码类型。</li>
<li>STT_OBJECT：数据对象类型</li>
<li>STT_SECTION： Section类型</li>
</ul>
<p><strong>st_other</strong></p>
<p>符号的可见性：</p>
<ul>
<li>STV_DEFAULT： 由符号的binding来决定。</li>
<li>STV_PROTECTED：符号对其他模块可见，但不能被重定义</li>
<li>STV_HIDDEN：符号对其他模块不可见，但在本模块内可用</li>
<li>STV_INTERNAL：内部可见性（保留，通常不用）</li>
</ul>
<h2 id="符号表">符号表</h2>
<p>符号存放在符号表中，其中.dynsym存放GLOBAL和WEAK类的符号、.symtab存放GLOBAL、WEAK、LOCAL符号。因此.dynsym是.symtab的一个子集。每个符号表都有与之对应的字符串池，如.shstrtab、.strtab。
使用命令<code>readelf --dyn-sym -W  libanative.so</code>
可以查看符号表中的符号信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf --dyn-sym -W  libanative.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 587 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)</span><br><span class="line">     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __register_atfork@LIBC (2)</span><br><span class="line">     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@LIBC (2)</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@LIBC (2)</span><br><span class="line">     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@LIBC (2)</span><br><span class="line">     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memmove@LIBC (2)</span><br><span class="line">     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memcpy@LIBC (2)</span><br><span class="line">     9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memchr@LIBC (2)</span><br><span class="line">    10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memset@LIBC (2)</span><br><span class="line">    ...</span><br><span class="line">   532: 000000000001dc50    28 FUNC    GLOBAL DEFAULT   14 SayHello</span><br><span class="line">   ...    </span><br></pre></td></tr></table></figure>
也可以使用<code>readelf -s</code> 将.dynsym和.symtab中的符号都打印出来：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -s -W  libanative.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 587 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)</span><br><span class="line">     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __register_atfork@LIBC (2)</span><br><span class="line">     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@LIBC (2)</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@LIBC (2)</span><br><span class="line">     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@LIBC (2)</span><br><span class="line">...</span><br><span class="line">   292: 00000000000248a0     0 NOTYPE  LOCAL  DEFAULT   14 $x.170</span><br><span class="line">   293: 0000000000024a44     0 NOTYPE  LOCAL  DEFAULT   14 $x.171</span><br><span class="line">   294: 0000000000024b84     0 NOTYPE  LOCAL  DEFAULT   14 $x.172</span><br><span class="line">   295: 0000000000024cc4     0 NOTYPE  LOCAL  DEFAULT   14 $x.173</span><br><span class="line">   296: 0000000000024e04     0 NOTYPE  LOCAL  DEFAULT   14 $x.174</span><br><span class="line">   297: 0000000000012f74     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table129</span><br><span class="line">   298: 0000000000012f74     0 NOTYPE  LOCAL  DEFAULT   10 $d.175</span><br><span class="line">   299: 0000000000024fb4     0 NOTYPE  LOCAL  DEFAULT   14 $x.176</span><br><span class="line">   300: 0000000000012f8c     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table130</span><br><span class="line">   301: 0000000000012f8c     0 NOTYPE  LOCAL  DEFAULT   10 $d.177</span><br><span class="line">   302: 0000000000025164     0 NOTYPE  LOCAL  DEFAULT   14 $x.178</span><br><span class="line">   303: 0000000000012fa4     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table131</span><br><span class="line">   304: 0000000000012fa4     0 NOTYPE  LOCAL  DEFAULT   10 $d.179</span><br><span class="line">   305: 00000000000148a0     0 NOTYPE  LOCAL  DEFAULT   11 $d.180</span><br><span class="line">   306: 000000000002530c     0 NOTYPE  LOCAL  DEFAULT   14 $x.181</span><br><span class="line">   307: 0000000000012fbc     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table132</span><br><span class="line">   308: 0000000000012fbc     0 NOTYPE  LOCAL  DEFAULT   10 $d.182</span><br><span class="line">   309: 0000000000025510     0 NOTYPE  LOCAL  DEFAULT   14 $x.183</span><br><span class="line">   310: 0000000000012fec     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table133</span><br><span class="line">   311: 0000000000012fec     0 NOTYPE  LOCAL  DEFAULT   10 $d.184</span><br><span class="line">   312: 0000000000025710     0 NOTYPE  LOCAL  DEFAULT   14 $x.185</span><br><span class="line">   313: 000000000001301c     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table134</span><br><span class="line">   314: 000000000001301c     0 NOTYPE  LOCAL  DEFAULT   10 $d.186</span><br><span class="line">   315: 0000000000025908     0 NOTYPE  LOCAL  DEFAULT   14 $x.187</span><br><span class="line">   316: 0000000000025940     0 NOTYPE  LOCAL  DEFAULT   14 $x.188     </span><br></pre></td></tr></table></figure> 可以看到.symtab中的符号的数量远比.dynsym
中的符号数量多的多，而多出来的符号只是用于调试，不会影响程序的正常运行。因此一般的release的动态库中，都会把
.symtab 给裁剪掉。所以局部符号是外部不可见的。</p>
<h2 id="hash表">Hash表</h2>
<p>我们知道dlsym等接口可以通过符号名查找符号的地址，这是如何实现的呢？</p>
<p>最简单的，我们可以通过Section Headers等信息，获取 .dynsym 或者
.symtab
的地址，然后遍历一下符号表中的所有符号，并匹配符号名即可。显然这种方式效率太低。</p>
<p>为了提升程序的加载速度和运行效率，ELF采用了hash查找方式，传入符号名，就可以通过hash算法算得符号在符号表中得index。</p>
<p>有两种hash表，分别为 .hash 和 .gnu_hash
，可以只存在一种，也可以同时存在两种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -S  libanative.so</span><br><span class="line">There are 34 section headers, starting at offset 0x1cf4d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.androi[...] NOTE             0000000000000238  00000238</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .note.gnu.bu[...] NOTE             00000000000002d0  000002d0</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .dynsym           DYNSYM           00000000000002f8  000002f8</span><br><span class="line">       0000000000003708  0000000000000018   A       7     1     8</span><br><span class="line">  [ 4] .gnu.version      VERSYM           0000000000003a00  00003a00</span><br><span class="line">       0000000000000496  0000000000000002   A       3     0     2</span><br><span class="line">  [ 5] .gnu.version_r    VERNEED          0000000000003e98  00003e98</span><br><span class="line">       0000000000000040  0000000000000000   A       7     2     4</span><br><span class="line">// Hash表       </span><br><span class="line">  [ 6] .gnu.hash         GNU_HASH         0000000000003ed8  00003ed8</span><br><span class="line">       0000000000000e2c  0000000000000000   A       3     0     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000004d04  00004d04</span><br><span class="line">       000000000000484a  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .rela.dyn         RELA             0000000000009550  00009550</span><br><span class="line">       0000000000008838  0000000000000018   A       3     0     8</span><br><span class="line">  [ 9] .rela.plt         RELA             0000000000011d88  00011d88</span><br></pre></td></tr></table></figure>
<p>已GNU hash为例，大致算法实现如下：</p>
<ul>
<li>来自bionic libc:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker_soinfo.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span>* <span class="title function_">soinfo::find_symbol_by_name</span><span class="params">(SymbolName&amp; symbol_name,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> version_info* vi)</span> <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> is_gnu_hash() ? gnu_lookup(symbol_name, vi) : elf_lookup(symbol_name, vi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span>* <span class="title function_">soinfo::gnu_lookup</span><span class="params">(SymbolName&amp; symbol_name, <span class="type">const</span> version_info* vi)</span> <span class="type">const</span> &#123;</span><br><span class="line">     <span class="comment">// 先计算符号的HASH</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> hash = symbol_name.gnu_hash();</span><br><span class="line"></span><br><span class="line">  <span class="type">constexpr</span> <span class="type">uint32_t</span> kBloomMaskBits = <span class="keyword">sizeof</span>(ElfW(Addr)) * <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; gnu_maskwords_;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> bloom_word = gnu_bloom_filter_[word_num];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> h1 = hash % kBloomMaskBits;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> h2 = (hash &gt;&gt; gnu_shift2_) % kBloomMaskBits;</span><br><span class="line"></span><br><span class="line">  LD_DEBUG(lookup, <span class="string">&quot;SEARCH %s in %s@%p (gnu)&quot;</span>,</span><br><span class="line">           symbol_name.get_name(), get_realpath(), reinterpret_cast&lt;<span class="type">void</span>*&gt;(base));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// test against bloom filter</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先bloom筛选，加速</span></span><br><span class="line">  <span class="comment">// bloom test says &quot;probably yes&quot;...</span></span><br><span class="line">  <span class="type">uint32_t</span> n = gnu_bucket_[hash % gnu_nbucket_];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Versym)</span> verneed = find_verdef_version_index(this, vi);</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Versym)</span>* versym = get_versym_table();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ElfW(Sym)* s = symtab_ + n;</span><br><span class="line">    <span class="comment">// 计算出桶</span></span><br><span class="line">    <span class="keyword">if</span> (((gnu_chain_[n] ^ hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        check_symbol_version(versym, n, verneed) &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(get_string(s-&gt;st_name), symbol_name.get_name()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        is_symbol_global_and_defined(this, s)) &#123;</span><br><span class="line">      <span class="keyword">return</span> symtab_ + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ((gnu_chain_[n++] &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算HASH, HASH算法如下：</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SymbolName::gnu_hash</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_gnu_hash_) &#123;</span><br><span class="line">    gnu_hash_ = calculate_gnu_hash(name_).first;</span><br><span class="line">    has_gnu_hash_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gnu_hash_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title function_">calculate_gnu_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_GNU_HASH_NEON</span></span><br><span class="line">  <span class="keyword">return</span> calculate_gnu_hash_neon(name);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> calculate_gnu_hash_simple(name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">__attribute__((unused))</span><br><span class="line"><span class="type">static</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title function_">calculate_gnu_hash_simple</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* name_bytes = reinterpret_cast&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(name);</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> unroll 8</span></span><br><span class="line">  <span class="keyword">while</span> (*name_bytes != <span class="number">0</span>) &#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">5</span>) + *name_bytes++; <span class="comment">// h*33 + c = h + h * 32 + c = h + h &lt;&lt; 5 + c</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; h, reinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(name_bytes) - name &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是，只有 .dynsym 有hash表， .symtab
是没有hash表只能遍历查找。</p>
<h1 id="重定位">重定位</h1>
<p>前文讲到调用外部函数时，会获取GOT表槽中的值作为地址然后跳转过去，而这个地址在编译时无法确定，所以运行时会被dynamic
linker设置位真正的函数地址。这个给GOT表设置真实地址的过程就叫做重定位。</p>
<h2 id="重定位信息">重定位信息</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p><strong>r_offset</strong>
指向需要执行重定位操作的位置。如GOT表重定位的case下，这个值就是被需要被重定位的函数对应的GOT表Slot的相对地址。</p>
<ul>
<li><p>对于 ET_REL
类型的二进制文件，此值表示节（section）内的偏移量，即需要进行重定位的节内位置。</p></li>
<li><p>对于 ET_EXEC
类型的二进制文件，此值表示受重定位影响的虚拟地址。</p></li>
</ul>
<p><strong>r_info</strong>
同时提供了符号表索引（指明此次重定位所依据的符号）以及需要应用的重定位类型。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_R_SYM(i) ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_R_TYPE(i) ((i) &amp; 0xffffffff)</span></span><br></pre></td></tr></table></figure>
info中包含了类型、符号信息。其中符号就是上文提到的.dynsym表中的符号的索引。
重定位的类型有很多，arm64常见的有：</p>
<ul>
<li>R_AARCH64_JUMP_SLOT</li>
<li>R_AARCH64_GLOB_DAT</li>
<li>R_AARCH64_ABS64</li>
</ul>
<p>不同类型的重定位信息存储在不同的重定位表中。</p>
<p><strong>r_addend</strong>
指定一个常量加数，用于计算写入可重定位字段的最终值。</p>
<h2 id="重定位表">重定位表</h2>
<p>可以通过 <code>readelf -S libanative.so</code>
查看重定位表的信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -S libanative.so</span><br><span class="line">There are 34 section headers, starting at offset 0x1cf4d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  ...   </span><br><span class="line">  [ 8] .rela.dyn         RELA             0000000000009550  00009550</span><br><span class="line">       0000000000008838  0000000000000018   A       3     0     8</span><br><span class="line">  [ 9] .rela.plt         RELA             0000000000011d88  00011d88</span><br><span class="line">       0000000000000b70  0000000000000018  AI       3    21     8</span><br><span class="line">  ...</span><br><span class="line">  [16] .data.rel.ro      PROGBITS         0000000000043c50  00042c50</span><br><span class="line">       00000000000030e0  0000000000000000  WA       0     0     8</span><br><span class="line">  [19] .dynamic          DYNAMIC          0000000000046d48  00045d48</span><br><span class="line">       00000000000001d0  0000000000000010  WA       7     0     8</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>其中.rela.plt
存放函数跳转相关的R_AARCH64_JUMP_SLOT类型的重定位信息。.rela.dyn存放非函数跳转相关的其他类型重定位信息。
可以通过<code>readelf -rW libanative.so</code>
工具重新打印重定位表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -rW libanative.so</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.dyn&#x27;</span> at offset 0x9550 contains 1453 entries:</span><br><span class="line">    Offset             Info             Type               Symbol<span class="string">&#x27;s Value  Symbol&#x27;</span>s Name + Addend</span><br><span class="line">0000000000043c50  0000000000000403 R_AARCH64_RELATIVE                        43c50</span><br><span class="line">0000000000043c60  0000000000000403 R_AARCH64_RELATIVE                        43cc0</span><br><span class="line">0000000000043c68  0000000000000403 R_AARCH64_RELATIVE                        2ab48</span><br><span class="line">0000000000043c70  0000000000000403 R_AARCH64_RELATIVE                        2ab54</span><br><span class="line">...</span><br><span class="line">0000000000048458  0000000000000403 R_AARCH64_RELATIVE                        48f20</span><br><span class="line">0000000000046fa0  0000002700000401 R_AARCH64_GLOB_DAT     0000000000000000 __sF@LIBC + 0</span><br><span class="line">0000000000046aa8  0000004500000101 R_AARCH64_ABS64        0000000000046ac8 _ZTISt12length_error + 0</span><br><span class="line">0000000000046f18  0000004500000401 R_AARCH64_GLOB_DAT     0000000000046ac8 _ZTISt12length_error + 0</span><br><span class="line">0000000000046088  0000004600000101 R_AARCH64_ABS64        00000000000163b2 _ZTSs + 0</span><br><span class="line">00000000000460d8  0000004900000101 R_AARCH64_ABS64        00000000000163bb _ZTSt + 0</span><br><span class="line">0000000000046598  0000004a00000101 R_AARCH64_ABS64        000000000001644b _ZTSPDs + 0</span><br><span class="line">0000000000047010  0000004b00000401 R_AARCH64_GLOB_DAT     0000000000046bf8 _ZTVSt8bad_cast</span><br><span class="line">...</span><br><span class="line">Relocation section <span class="string">&#x27;.rela.plt&#x27;</span> at offset 0x11d88 contains 122 entries:</span><br><span class="line">    Offset             Info             Type               Symbol<span class="string">&#x27;s Value  Symbol&#x27;</span>s Name + Addend</span><br><span class="line">0000000000047038  0000000100000402 R_AARCH64_JUMP_SLOT    0000000000000000 __cxa_finalize@LIBC + 0</span><br><span class="line">0000000000047040  0000000200000402 R_AARCH64_JUMP_SLOT    0000000000000000 __cxa_atexit@LIBC + 0</span><br><span class="line">0000000000047048  0000000300000402 R_AARCH64_JUMP_SLOT    0000000000000000 __register_atfork@LIBC + 0</span><br><span class="line">0000000000047050  0000021400000402 R_AARCH64_JUMP_SLOT    000000000001dc50 SayHello + 0</span><br><span class="line">0000000000047058  0000000400000402 R_AARCH64_JUMP_SLOT    0000000000000000 <span class="built_in">printf</span>@LIBC + 0</span><br></pre></td></tr></table></figure>
<p>上图表中：</p>
<ul>
<li>Offset,对应Elf64_Rela中的r_offset字段。</li>
<li>Info,对应Elf64_Rela中的r_info字段。</li>
<li>Type,对应r_info中的重定位类型信息。</li>
<li>Symbol’s Value,对对应r_info中计算出的符号地址信息。</li>
<li>Symbol’s Name + Addend，对应r_info中查找符号表的符号名信息。
通过上面的打印，不难发现：，除了外部符号（Symbol’s
Value等于0）外，很多内部符号也需要重新定位。</li>
</ul>
<h2 id="重定位过程">重定位过程</h2>
<h3 id="r_aarch64_jump_slot">R_AARCH64_JUMP_SLOT</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic linker_info.h</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">soinfo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">soinfo</span>(<span class="type">android_namespace_t</span>* ns, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="keyword">struct</span> stat* file_stat,</span><br><span class="line">         <span class="type">off64_t</span> file_offset, <span class="type">int</span> rtld_flags);</span><br><span class="line">  ~<span class="built_in">soinfo</span>();</span><br><span class="line"> soinfo* next;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">relocate</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list)</span></span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::relocate</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">packed_relocate</span>&lt;RelocMode::Typical&gt;(relocator, <span class="built_in">sleb128_decoder</span>(packed_relocs, packed_relocs_size))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode OptMode, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">packed_relocate</span><span class="params">(Relocator&amp; relocator, Args ...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">needs_slow_relocate_loop</span>(relocator) ?</span><br><span class="line">      <span class="built_in">packed_relocate_impl</span>&lt;RelocMode::General&gt;(relocator, args...) :</span><br><span class="line">      <span class="built_in">packed_relocate_impl</span>&lt;OptMode&gt;(relocator, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">packed_relocate_impl</span><span class="params">(Relocator&amp; relocator, sleb128_decoder decoder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> for_all_packed_relocs(decoder, [&amp;](<span class="type">const</span> <span class="type">rel_t</span>&amp; reloc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process_relocation</span>&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">process_relocation</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mode == RelocMode::General ?</span><br><span class="line">      <span class="built_in">process_relocation_general</span>(relocator, reloc) :</span><br><span class="line">      <span class="built_in">process_relocation_impl</span>&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_general</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">process_relocation_impl</span>&lt;RelocMode::General&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (__aarch64__)</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R_GENERIC_JUMP_SLOT     R_AARCH64_JUMP_SLOT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line">  <span class="comment">// 计算出 r_offse的真实虚拟地址 = 基地址（load_bias) +  r_offset</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> rel_target = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">      relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(reloc.r_offset + relocator.si-&gt;load_bias));</span><br><span class="line">  <span class="comment">// 存放该符号，对应的地址    </span></span><br><span class="line">   <span class="built_in">ElfW</span>(Addr) sym_addr = <span class="number">0</span>;   </span><br><span class="line">   ... </span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">lookup_symbol</span>&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> should_protect_segments = handle_text_relocs &amp;&amp;</span><br><span class="line">                                             found_in == relocator.si &amp;&amp;</span><br><span class="line">                                             <span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info) == STT_GNU_IFUNC;</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !<span class="built_in">protect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 寻找到与符号对应的外部函数地址</span></span><br><span class="line">        sym_addr = found_in-&gt;<span class="built_in">resolve_symbol_address</span>(sym);</span><br><span class="line">     &#125;</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::JumpTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里R_GENERIC_JUMP_SLOT在arm64平台就是R_AARCH64_JUMP_SLOT</span></span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_JUMP_SLOT) &#123;</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="comment">// 将寻找到的函数地址，赋值给符号信息中r_offset对应的地址</span></span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + get_addend  _norel();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO JMP_SLOT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="r_aarch64_glob_dat">R_AARCH64_GLOB_DAT</h2>
<p>这类是全局变量的地址。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker_relocate.cpp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R_GENERIC_GLOB_DAT      R_AARCH64_GLOB_DAT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> rel_target = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">      relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(reloc.r_offset + relocator.si-&gt;load_bias));</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_type = <span class="built_in">ELFW</span>(R_TYPE)(reloc.r_info);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_sym = <span class="built_in">ELFW</span>(R_SYM)(reloc.r_info);</span><br><span class="line"></span><br><span class="line">  soinfo* found_in = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* sym_name = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) sym_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (r_type == R_GENERIC_ABSOLUTE) &#123;</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO ABSOLUTE %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_GLOB_DAT) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="comment">// 将寻找到的地址，赋值给reloc.r_offset对应的虚拟地址</span></span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_norel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO GLOB_DAT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_RELATIVE) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="r_aarch64_relative">R_AARCH64_RELATIVE</h2>
<p>基址修正、无外部符号依赖。即它的重定位不依赖符号解析。计算方式： B +
A;</p>
<h2 id="r_aarch64_abs64">R_AARCH64_ABS64</h2>
<p>64
位绝对地址重定位，需要符号解析。常见于需要存放全局变量或函数的真实指针的场景。计算方式：B
+ S;</p>
<h1 id="dynamic段">Dynamic段</h1>
<p>Phdr中的LOAD和GNU_RELRO只负责动态库的地址映射。而Sections
Header中信息主要都存入了dynamic段，它包含了linker需要的大多数信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -l libanative.so</span><br><span class="line"></span><br><span class="line">Elf file <span class="built_in">type</span> is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R      0x8</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000042c50 0x0000000000042c50  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000037b8  RW     0x1000</span><br><span class="line">  LOAD           0x0000000000046408 0x0000000000048408 0x0000000000048408</span><br><span class="line">                 0x0000000000000058 0x0000000000000b18  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000045d48 0x0000000000046d48 0x0000000000046d48</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  GNU_RELRO      0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000043b0  R      0x1</span><br><span class="line">  GNU_EH_FRAME   0x0000000000016b0c 0x0000000000016b0c 0x0000000000016b0c</span><br><span class="line">                 0x0000000000001534 0x0000000000001534  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x0</span><br><span class="line">  NOTE           0x0000000000000238 0x0000000000000238 0x0000000000000238</span><br><span class="line">                 0x00000000000000bc 0x00000000000000bc  R      0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .note.android.ident .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .gcc_except_table .rodata .eh_frame_hdr .eh_frame .text .plt</span><br><span class="line">   02     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   03     .data .bss</span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .note.android.ident .note.gnu.build-id</span><br></pre></td></tr></table></figure>
<p>.dynamic也是一个表，每个表项的结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>
<p><strong>d_tag</strong></p>
<ul>
<li>DT_NEEDED,依赖的共享库名（索引到字符串表）</li>
<li>DT_SYMTAB,指向符号表</li>
<li>DT_HASH,符号哈希表，用于快速符号查找</li>
<li>DT_STRTAB,指向字符串表，用于存储库名、符号名</li>
<li>DT_PLTGOT,PLT/GOT 表地址</li>
<li>SONAME,当前动态库名称的索引，索引是相对于.dynstr表的偏移</li>
<li>SYMTAB,.dynsym表起始地址</li>
<li>SYMENT,.dynsym表表项大小</li>
<li>STRTAB,.dynstr表起始地址</li>
<li>STRSZ,.dynstr表的字节数大小</li>
<li>INIT_ARRAY .init_array表的起始地址</li>
<li>.INIT_ARRAYSZ .init_array表的字节数大小</li>
</ul>
<p><strong>d_val</strong>
保存一个整数值，其含义视具体情况而定，例如可以表示单个重定位条目的大小等。
<strong>d_ptr</strong>
保存一个虚拟内存地址，可指向链接器所需的各种位置；一个典型示例是，当
d_tag 为 DT_SYMTAB 时，它指向符号表的地址。</p>
<p>执行<code>arm64-v8a readelf -d libanative.so</code> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -d libanative.so</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x45d48 contains 29 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [liblog.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libm.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so]</span><br><span class="line"> 0x000000000000000e (SONAME)             Library soname: [libanative.so]</span><br><span class="line"> 0x000000000000001e (FLAGS)              BIND_NOW</span><br><span class="line"> 0x000000006ffffffb (FLAGS_1)            Flags: NOW</span><br><span class="line"> 0x0000000000000007 (RELA)               0x9550</span><br><span class="line"> 0x0000000000000008 (RELASZ)             34872 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffff9 (RELACOUNT)          989</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x11d88</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           2928 (bytes)</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x47020</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x2f8</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x4d04</span><br><span class="line"> 0x000000000000000a (STRSZ)              18506 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x3ed8</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x46d40</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x46d30</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       16 (bytes)</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x3a00</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x3e98</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         2</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure>
可见.dynamic 和Section Headers类似，指向的是参与动态链接的Sections</p>
<h1 id="参考">参考</h1>
<p>https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-48031.html#scrolltoc</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/code/" rel="tag"># code</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/08/25/graphic/colormodel/" rel="prev" title="色彩模型">
                  <i class="fa fa-angle-left"></i> 色彩模型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/09/20/android/native_dynamic_process/" rel="next" title="Android动态链接技术二（动态库的加载过程）">
                  Android动态链接技术二（动态库的加载过程） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">blueberry · All rights reserved.</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
