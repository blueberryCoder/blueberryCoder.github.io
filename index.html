<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blueberrycoder.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Keep learning">
<meta property="og:url" content="https://blueberrycoder.github.io/index.html">
<meta property="og:site_name" content="Keep learning">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="blueberry">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blueberrycoder.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Keep learning</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.9.0/mermaid.min.js","integrity":"sha256-Cz7UN0EXNjgV2u/a38wg/3BNfdRRO1XtgDq93L2GqJg="}}</script>
  <script src="/js/third-party/tags/mermaid.js" defer></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<script>
    console.log("head", JSON.stringify(``))
</script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Keep learning</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">blueberry</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blueberrycoder.github.io/2025/09/20/android/native_dynamic_process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blueberry">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep learning">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Keep learning">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/20/android/native_dynamic_process/" class="post-title-link" itemprop="url">Android动态链接技术二（动态库的加载过程）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-20 10:01:42" itemprop="dateCreated datePublished" datetime="2025-09-20T10:01:42+08:00">2025-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-10-02 21:43:05" itemprop="dateModified" datetime="2025-10-02T21:43:05+08:00">2025-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="动态库的链接过程">动态库的链接过程</h1>
<p>我之前写了简单的C++文件然后用Android
Ndk构建除了一个动态库，通过readelf可以查看到这个动态库依赖了5个其他的动态库。根据以往的经验，一个工程依赖库应该是一个DAG（有向不循环图）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [liblog.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libm.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libdl.so]</span><br><span class="line">0x0000000000000001 (NEEDED)             Shared library: [libc.so]</span><br></pre></td></tr></table></figure>
<pre>
<code class="mermaid">
sequenceDiagram
participant libdl 
participant linker
participant LoadTask
participant soinfo
participant ElfReader 


libdl-&gt;&gt;+libdl: dlopen
libdl-&gt;&gt;+linker: find_library
linker-&gt;&gt;linker: find_libraries
linker-&gt;&gt;linker: prepare LoadTask list
Note right of linker: Step 1. prepare loadtasks
linker-&gt;&gt;+LoadTask: create
Note over linker, LoadTask: Create a loadTask for current so that will be load 
LoadTask-&gt;&gt;-linker: return
Note right of linker: Step 2. bfs dependencies
loop bfs dependencies
  
    linker-&gt;&gt;linker: load_library
    linker-&gt;&gt;+soinfo: alloc
    soinfo-&gt;&gt;soinfo: generate_handle and add to ns
    soinfo-&gt;&gt;-linker: return
    linker-&gt;&gt;+ElfReader: construct 
    linker-&gt;&gt;+LoadTask: read
    LoadTask-&gt;&gt;+ElfReader: Read
    ElfReader-&gt;&gt;ElfReader:ReadElfHeader
    ElfReader-&gt;&gt;ElfReader:VerifyElfHeader
    ElfReader-&gt;&gt;ElfReader:ReadProgramHeaders
    ElfReader-&gt;&gt;ElfReader:CheckProgramHeaderAlignment
    ElfReader-&gt;&gt;ElfReader:ReadSectionHeaders
    ElfReader-&gt;&gt;ElfReader:ReadDynamicSection
    ElfReader-&gt;&gt;ElfReader:ReadPadSegmentNote
    ElfReader-&gt;&gt;-LoadTask: return
    LoadTask-&gt;&gt;linker: return
    linker-&gt;&gt;ElfReader: Get DT_NEEDED
    linker-&gt;&gt;LoadTask: create
    LoadTask-&gt;&gt;linker: return
    linker-&gt;&gt;linker: add to LoadTask list
    Note right of linker: Create a LoadTask for dependency and add it to list.

end
linker-&gt;&gt;linker: shuffle loadtasks
Note right of linker: Step 3. foreach soinfos to prelink libraries
loop loadtasks
    linker-&gt;&gt;soinfo:prelink_image
    Note right of soinfo: Get all information from elf dynamic section.
end
linker-&gt;&gt;linker:Construct the global group
Note right of linker: Step 4. Construct the global group
linker-&gt;&gt;linker: Step 5. Collect roots of local_groups
Note right of linker: Step 6. Link all local groups
loop local_group_roots
    linker-&gt;&gt;linker: walk_dependencies_tree
    Note right of linker: Collect soinfo to a local_group
    loop local_group
        linker-&gt;&gt;soinfo:link_image
        soinfo-&gt;&gt;soinfo:relocate
        Note right of soinfo: Relocate by rel&#x2F;rela
    end
end
linker-&gt;&gt;linker: mark linked
Note right of linker: Step 7. Mark libraries as linked
linker-&gt;&gt;soinfo: call_constructors
linker-&gt;&gt;-libdl: return handle
libdl-&gt;&gt;-libdl: return 

</code>
</pre>
<p>上面是一个动态库被加载的大致流程，我们有时候会使用dlopen一个外部库，然后通过dlsym根据符号查找某个函数进行调用。这里就通过dlopen这个函数的调用作为切入点来分析动态库的加载过程。</p>
<p>上图描述的动态库的加载流程粗略概括为：</p>
<ol type="1">
<li>获取调用方传入的要加载的库的名称、调用者的namespace。创建一个load_tasks列表。</li>
<li>根据库的名称创建一个LoadTask，放到遍历列表中。并开始遍历列表，通过LoadTask、创建soinfo、解析so文件，读取Shdrs、Phdrs、获取依赖库信息，然后对依赖的so库也创建一个LoadTask，并放到遍历列表load_tasks中，然后继续遍历列表。</li>
<li>打乱LoadTask列表的顺序、继续通过LoadTask预链接库。</li>
<li>根据Android中的namespace机制，构建一个local_group树，收集roots以便后续遍历。</li>
<li>遍历local_group树，对库进行重定位。</li>
<li>标记所有的库状态为已链接。调用每个库的构造器。</li>
</ol>
<h1 id="打开一个动态库">打开一个动态库</h1>
<p>dlopen函数的使用方式：<a
target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man3/dlopen.3.html"
class="uri">https://man7.org/linux/man-pages/man3/dlopen.3.html</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libdl.cpp</span></span><br><span class="line"><span class="comment">// 加载一个动态库，filename为库的名称，flag可以为：RTLD_LAZY、RTLD_NOW、RTLD_GLOBAL...</span></span><br><span class="line">__attribute__((__weak__))</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前函数的返回地址</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span>* caller_addr = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __loader_dlopen(filename, flag, caller_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* __loader_dlopen(<span class="type">const</span> <span class="type">char</span>* filename, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">void</span>* caller_addr) &#123;</span><br><span class="line">  <span class="comment">// android_dlextinfo传nullptr</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dlopen_ext</span>(filename, flags, <span class="literal">nullptr</span>, caller_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">dlopen_ext</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> android_dlextinfo* extinfo,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> <span class="type">void</span>* caller_addr)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedPthreadMutexLocker <span class="title">locker</span><span class="params">(&amp;g_dl_mutex)</span></span>;</span><br><span class="line">  g_linker_logger.<span class="built_in">ResetState</span>();</span><br><span class="line">  <span class="type">void</span>* result = <span class="built_in">do_dlopen</span>(filename, flags, extinfo, caller_addr);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    __bionic_format_dlerror(<span class="string">&quot;dlopen failed&quot;</span>, <span class="built_in">linker_get_error_buffer</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">do_dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name,  <span class="comment">// 要加载的库名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">int</span> flags, <span class="comment">// flag</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> android_dlextinfo* extinfo, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> <span class="type">void</span>* caller_addr  <span class="comment">// dlopen中的函数返回地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">                )</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 找出调用者的soinfo（谁发起的dlopen)           </span></span><br><span class="line">     soinfo* <span class="type">const</span> caller = <span class="built_in">find_containing_library</span>(caller_addr); </span><br><span class="line">     <span class="comment">// 调用者的namespace</span></span><br><span class="line">     <span class="type">android_namespace_t</span>* ns = <span class="built_in">get_caller_namespace</span>(caller);   </span><br><span class="line">     ...</span><br><span class="line">       <span class="keyword">if</span> (g_is_asan &amp;&amp; translated_name != <span class="literal">nullptr</span> &amp;&amp; translated_name[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="type">char</span> original_path[PATH_MAX];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">realpath</span>(name, original_path) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">file_exists</span>(translated_name_holder.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="comment">// 存放加载后的动态信息  </span></span><br><span class="line">        soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line">         <span class="comment">// 根据路径加载动态库 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find_loaded_library_by_realpath</span>(ns, original_path, <span class="literal">true</span>, &amp;si)) &#123;</span><br><span class="line">          <span class="built_in">DL_WARN</span>(<span class="string">&quot;linker_asan dlopen NOT translating \&quot;%s\&quot; -&gt; \&quot;%s\&quot;: library already loaded&quot;</span>, name,</span><br><span class="line">                  translated_name_holder.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;       </span><br><span class="line">  ProtectedDataGuard guard;</span><br><span class="line">  <span class="comment">// 加载动态库</span></span><br><span class="line">  soinfo* si = <span class="built_in">find_library</span>(ns, translated_name, flags, extinfo, caller);</span><br><span class="line">  loading_trace.<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 转成handle</span></span><br><span class="line">    <span class="type">void</span>* handle = si-&gt;<span class="built_in">to_handle</span>();</span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;... dlopen calling constructors: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;, handle=%p&quot;</span>,</span><br><span class="line">           si-&gt;<span class="built_in">get_realpath</span>(), si-&gt;<span class="built_in">get_soname</span>(), handle);</span><br><span class="line">    <span class="comment">// 调用初始构造,调用DT_INIT节和DT_INIT_ARRAY的函数</span></span><br><span class="line">    si-&gt;<span class="built_in">call_constructors</span>();</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="寻找加载整体流程">寻找加载整体流程</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找动态库</span></span><br><span class="line"><span class="function"><span class="type">static</span> soinfo* <span class="title">find_library</span><span class="params">(<span class="type">android_namespace_t</span>* ns,<span class="comment">// caller所处的namespace</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> <span class="type">char</span>* name,  <span class="comment">// 要加载的so名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">int</span> rtld_flags, <span class="comment">// flag</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> android_dlextinfo* extinfo, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            soinfo* needed_by <span class="comment">// caller的soinfo</span></span></span></span><br><span class="line"><span class="params"><span class="function">                            )</span> </span>&#123;</span><br><span class="line">  soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    si = <span class="built_in">solist_get_somain</span>();</span><br><span class="line">    <span class="comment">// 加载目标库</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">find_libraries</span>(ns,</span><br><span class="line">                             needed_by,</span><br><span class="line">                             &amp;name,</span><br><span class="line">                             <span class="number">1</span>,</span><br><span class="line">                             &amp;si,</span><br><span class="line">                             <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="number">0</span>,</span><br><span class="line">                             rtld_flags,</span><br><span class="line">                             extinfo,</span><br><span class="line">                             <span class="literal">false</span> <span class="comment">/* add_as_children */</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">soinfo_unload</span>(si);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  si-&gt;<span class="built_in">increment_ref_count</span>();</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker.cpp</span></span><br><span class="line"><span class="comment">// 加载动态库，主要分下面几步：</span></span><br><span class="line"><span class="comment">// 1. 根据so的名称找到要加载的库，然后通过DT_NEED找出它的第一层依赖，然后创建加载任务，然后通过BFS遍历的方式继续加载二级、三级...依赖。</span></span><br><span class="line"><span class="comment">// 2. 打乱加载顺序，加载所有的so。</span></span><br><span class="line"><span class="comment">// 3. 预链接所有库。</span></span><br><span class="line"><span class="comment">// 5. 根据所有库的namespce构建构建查找树（影响符号寻找顺序）。</span></span><br><span class="line"><span class="comment">// 6. 遍历树，链接所有的动态库。</span></span><br><span class="line"><span class="comment">// add_as_children - add first-level loaded libraries (i.e. library_names[], but</span></span><br><span class="line"><span class="comment">// not their transitive dependencies) as children of the start_with library.</span></span><br><span class="line"><span class="comment">// This is false when find_libraries is called for dlopen(), when newly loaded</span></span><br><span class="line"><span class="comment">// libraries must form a disjoint tree.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_libraries</span><span class="params">(<span class="type">android_namespace_t</span>* ns,<span class="comment">// caller的ns</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    soinfo* start_with, <span class="comment">// caller的soinfo</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> library_names[], <span class="comment">// 就存放一个当前要加载的so名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">size_t</span> library_names_count, <span class="comment">// 1</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    soinfo* soinfos[],<span class="comment">// 输出soinfo</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::vector&lt;soinfo*&gt;* ld_preloads, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">size_t</span> ld_preloads_count, <span class="comment">// 0</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">int</span> rtld_flags, <span class="comment">// rtld_flags</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> android_dlextinfo* extinfo, <span class="comment">// nullptr</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">bool</span> add_as_children, <span class="comment">// false</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    std::vector&lt;<span class="type">android_namespace_t</span>*&gt;* namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Step 0: prepare.</span></span><br><span class="line">  std::unordered_map&lt;<span class="type">const</span> soinfo*, ElfReader&gt; readers_map;</span><br><span class="line">  <span class="comment">// 创建LoadTaskList; typedef std::vector&lt;LoadTask*&gt; LoadTaskList;</span></span><br><span class="line">  LoadTaskList load_tasks;</span><br><span class="line">  <span class="comment">// 首次这里的 library_names_count = 1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; library_names_count; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name = library_names[i];</span><br><span class="line">    <span class="comment">// 为要加载的动态库创建一个加载任务</span></span><br><span class="line">    load_tasks.<span class="built_in">push_back</span>(LoadTask::<span class="built_in">create</span>(name, start_with, ns, &amp;readers_map));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 遍历load_tasks，load_tasks允许扩张，可以将DT_NEED中的子库添加到load_tasks，这里是一种BFS遍历算法。</span></span><br><span class="line">  <span class="comment">// Step 1: expand the list of load_tasks to include</span></span><br><span class="line">  <span class="comment">// all DT_NEEDED libraries (do not load them just yet)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;load_tasks.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    LoadTask* task = load_tasks[i];</span><br><span class="line">    soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_dt_needed = needed_by != <span class="literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);</span><br><span class="line">    task-&gt;<span class="built_in">set_extinfo</span>(is_dt_needed ? <span class="literal">nullptr</span> : extinfo);</span><br><span class="line">    task-&gt;<span class="built_in">set_dt_needed</span>(is_dt_needed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: start from the namespace that is stored in the LoadTask. This namespace</span></span><br><span class="line">    <span class="comment">// is different from the current namespace when the LoadTask is for a transitive</span></span><br><span class="line">    <span class="comment">// dependency and the lib that created the LoadTask is not found in the</span></span><br><span class="line">    <span class="comment">// current namespace but in one of the linked namespaces.</span></span><br><span class="line">    <span class="type">android_namespace_t</span>* start_ns = <span class="built_in">const_cast</span>&lt;<span class="type">android_namespace_t</span>*&gt;(task-&gt;<span class="built_in">get_start_from</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;find_library_internal(ns=%s@%p): task=%s, is_dt_needed=%d&quot;</span>,</span><br><span class="line">           start_ns-&gt;<span class="built_in">get_name</span>(), start_ns, task-&gt;<span class="built_in">get_name</span>(), is_dt_needed);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取ELF文件，将Shdrs和Phdrs等映射进来，并为依赖创建load_task放到load_tasks列表中。这是一种BFS遍历</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">find_library_internal</span>(start_ns, task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    <span class="keyword">if</span> (is_dt_needed) &#123;</span><br><span class="line">      needed_by-&gt;<span class="built_in">add_child</span>(si);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When ld_preloads is not null, the first</span></span><br><span class="line">    <span class="comment">// ld_preloads_count libs are in fact ld_preloads.</span></span><br><span class="line">    <span class="type">bool</span> is_ld_preload = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ld_preloads != <span class="literal">nullptr</span> &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123;</span><br><span class="line">      ld_preloads-&gt;<span class="built_in">push_back</span>(si);</span><br><span class="line">      is_ld_preload = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (soinfos_count &lt; library_names_count) &#123;</span><br><span class="line">      soinfos[soinfos_count++] = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the new global group members to all initial namespaces. Do this secondary namespace setup</span></span><br><span class="line">    <span class="comment">// at the same time that libraries are added to their primary namespace so that the order of</span></span><br><span class="line">    <span class="comment">// global group members is the same in the every namespace. Only add a library to a namespace</span></span><br><span class="line">    <span class="comment">// once, even if it appears multiple times in the dependency graph.</span></span><br><span class="line">    <span class="keyword">if</span> (is_ld_preload || (si-&gt;<span class="built_in">get_dt_flags_1</span>() &amp; DF_1_GLOBAL) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; namespaces != <span class="literal">nullptr</span> &amp;&amp; !new_global_group_members.<span class="built_in">contains</span>(si)) &#123;</span><br><span class="line">        new_global_group_members.<span class="built_in">push_back</span>(si);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> linked_ns : *namespaces) &#123;</span><br><span class="line">          <span class="keyword">if</span> (si-&gt;<span class="built_in">get_primary_namespace</span>() != linked_ns) &#123;</span><br><span class="line">            linked_ns-&gt;<span class="built_in">add_soinfo</span>(si);</span><br><span class="line">            si-&gt;<span class="built_in">add_secondary_namespace</span>(linked_ns);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打乱加载的顺序</span></span><br><span class="line">  <span class="comment">// Step 2: Load libraries in random order (see b/24047022)</span></span><br><span class="line">  LoadTaskList load_list;</span><br><span class="line">  <span class="comment">// 找出还没有linked的so</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    <span class="keyword">auto</span> pred = [&amp;](<span class="type">const</span> LoadTask* t) &#123;</span><br><span class="line">      <span class="keyword">return</span> t-&gt;<span class="built_in">get_soinfo</span>() == si;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp;</span><br><span class="line">        std::<span class="built_in">find_if</span>(load_list.<span class="built_in">begin</span>(), load_list.<span class="built_in">end</span>(), pred) == load_list.<span class="built_in">end</span>() ) &#123;</span><br><span class="line">      load_list.<span class="built_in">push_back</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> reserved_address_recursive = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (extinfo) &#123;</span><br><span class="line">    reserved_address_recursive = extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!reserved_address_recursive) &#123;</span><br><span class="line">    <span class="comment">// 打乱加载顺序</span></span><br><span class="line">    <span class="comment">// Shuffle the load order in the normal case, but not if we are loading all</span></span><br><span class="line">    <span class="comment">// the libraries to a reserved address range.</span></span><br><span class="line">    <span class="built_in">shuffle</span>(&amp;load_list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up address space parameters.</span></span><br><span class="line">  address_space_params extinfo_params, default_params;</span><br><span class="line">  <span class="type">size_t</span> relro_fd_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (extinfo) &#123;</span><br><span class="line">    <span class="keyword">if</span> (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123;</span><br><span class="line">      extinfo_params.start_addr = extinfo-&gt;reserved_addr;</span><br><span class="line">      extinfo_params.reserved_size = extinfo-&gt;reserved_size;</span><br><span class="line">      extinfo_params.must_use_address = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (extinfo-&gt;flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123;</span><br><span class="line">      extinfo_params.start_addr = extinfo-&gt;reserved_addr;</span><br><span class="line">      extinfo_params.reserved_size = extinfo-&gt;reserved_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_list) &#123;</span><br><span class="line">    address_space_params* address_space =</span><br><span class="line">        (reserved_address_recursive || !task-&gt;<span class="built_in">is_dt_needed</span>()) ? &amp;extinfo_params : &amp;default_params;</span><br><span class="line">    <span class="comment">// 加载so,可以通过address_space影响加载地址</span></span><br><span class="line">    <span class="keyword">if</span> (!task-&gt;<span class="built_in">load</span>(address_space)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The WebView loader uses RELRO sharing in order to promote page sharing of the large RELRO</span></span><br><span class="line">  <span class="comment">// segment, as it&#x27;s full of C++ vtables. Because MTE globals, by default, applies random tags to</span></span><br><span class="line">  <span class="comment">// each global variable, the RELRO segment is polluted and unique for each process. In order to</span></span><br><span class="line">  <span class="comment">// allow sharing, but still provide some protection, we use deterministic global tagging schemes</span></span><br><span class="line">  <span class="comment">// for DSOs that are loaded through android_dlopen_ext, such as those loaded by WebView.</span></span><br><span class="line">  <span class="type">bool</span> dlext_use_relro =</span><br><span class="line">      extinfo &amp;&amp; extinfo-&gt;flags &amp; (ANDROID_DLEXT_WRITE_RELRO | ANDROID_DLEXT_USE_RELRO);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 预链接</span></span><br><span class="line">  <span class="comment">// Step 3: pre-link all DT_NEEDED libraries in breadth first order.</span></span><br><span class="line">  <span class="type">bool</span> any_memtag_stack = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; !si-&gt;<span class="built_in">prelink_image</span>(dlext_use_relro)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// si-&gt;memtag_stack() needs to be called after si-&gt;prelink_image() which populates</span></span><br><span class="line">    <span class="comment">// the dynamic section.</span></span><br><span class="line">    <span class="keyword">if</span> (si-&gt;<span class="built_in">memtag_stack</span>()) &#123;</span><br><span class="line">      any_memtag_stack = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;... load_library requesting stack MTE for: realpath=\&quot;%s\&quot;, soname=\&quot;%s\&quot;&quot;</span>,</span><br><span class="line">             si-&gt;<span class="built_in">get_realpath</span>(), si-&gt;<span class="built_in">get_soname</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">register_soinfo_tls</span>(si);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (any_memtag_stack) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span>* cb = __libc_shared_globals()-&gt;memtag_stack_dlopen_callback) &#123;</span><br><span class="line">      <span class="built_in">cb</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// find_library is used by the initial linking step, so we communicate that we</span></span><br><span class="line">      <span class="comment">// want memtag_stack enabled to __libc_init_mte.</span></span><br><span class="line">      __libc_shared_globals()-&gt;initial_memtag_stack_abi = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4: Construct the global group. DF_1_GLOBAL bit is force set for LD_PRELOADed libs because</span></span><br><span class="line">  <span class="comment">// they must be added to the global group. Note: The DF_1_GLOBAL bit for a library is normally set</span></span><br><span class="line">  <span class="comment">// in step 3.</span></span><br><span class="line">  <span class="keyword">if</span> (ld_preloads != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; si : *ld_preloads) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_dt_flags_1</span>(si-&gt;<span class="built_in">get_dt_flags_1</span>() | DF_1_GLOBAL);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 收集所有local_groups的根</span></span><br><span class="line">  <span class="comment">// Step 5: Collect roots of local_groups.</span></span><br><span class="line">  <span class="comment">// Whenever needed_by-&gt;si link crosses a namespace boundary it forms its own local_group.</span></span><br><span class="line">  <span class="comment">// Here we collect new roots to link them separately later on. Note that we need to avoid</span></span><br><span class="line">  <span class="comment">// collecting duplicates. Also the order is important. They need to be linked in the same</span></span><br><span class="line">  <span class="comment">// BFS order we link individual libraries.</span></span><br><span class="line">  std::vector&lt;soinfo*&gt; local_group_roots;</span><br><span class="line">  <span class="keyword">if</span> (start_with != <span class="literal">nullptr</span> &amp;&amp; add_as_children) &#123;</span><br><span class="line">    local_group_roots.<span class="built_in">push_back</span>(start_with);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">CHECK</span>(soinfos_count == <span class="number">1</span>);</span><br><span class="line">    local_group_roots.<span class="built_in">push_back</span>(soinfos[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">    <span class="type">bool</span> is_dt_needed = needed_by != <span class="literal">nullptr</span> &amp;&amp; (needed_by != start_with || add_as_children);</span><br><span class="line">    <span class="type">android_namespace_t</span>* needed_by_ns =</span><br><span class="line">        is_dt_needed ? needed_by-&gt;<span class="built_in">get_primary_namespace</span>() : ns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; si-&gt;<span class="built_in">get_primary_namespace</span>() != needed_by_ns) &#123;</span><br><span class="line">      <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(local_group_roots.<span class="built_in">begin</span>(), local_group_roots.<span class="built_in">end</span>(), si);</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s&quot;</span>,</span><br><span class="line">             si-&gt;<span class="built_in">get_realpath</span>(),</span><br><span class="line">             si,</span><br><span class="line">             si-&gt;<span class="built_in">get_primary_namespace</span>()-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">             si-&gt;<span class="built_in">get_primary_namespace</span>(),</span><br><span class="line">             needed_by == <span class="literal">nullptr</span> ? <span class="string">&quot;(nullptr)&quot;</span> : needed_by-&gt;<span class="built_in">get_realpath</span>(),</span><br><span class="line">             needed_by,</span><br><span class="line">             ns-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">             ns,</span><br><span class="line">             needed_by_ns-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">             needed_by_ns,</span><br><span class="line">             it == local_group_roots.<span class="built_in">end</span>() ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (it == local_group_roots.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        local_group_roots.<span class="built_in">push_back</span>(si);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 6: Link all local groups</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> root : local_group_roots) &#123;</span><br><span class="line">    <span class="type">soinfo_list_t</span> local_group;</span><br><span class="line">    <span class="type">android_namespace_t</span>* local_group_ns = root-&gt;<span class="built_in">get_primary_namespace</span>();</span><br><span class="line"><span class="comment">// 从各个group的root开始遍历，并放到local_group列表</span></span><br><span class="line">    <span class="built_in">walk_dependencies_tree</span>(root,</span><br><span class="line">      [&amp;] (soinfo* si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (local_group_ns-&gt;<span class="built_in">is_accessible</span>(si)) &#123;</span><br><span class="line">          local_group.<span class="built_in">push_back</span>(si);</span><br><span class="line">          <span class="keyword">return</span> kWalkContinue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> kWalkSkip;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">soinfo_list_t</span> global_group = local_group_ns-&gt;<span class="built_in">get_global_group</span>();</span><br><span class="line">    <span class="comment">// 创建符号寻找器 SymbolLookupList</span></span><br><span class="line">    <span class="function">SymbolLookupList <span class="title">lookup_list</span><span class="params">(global_group, local_group)</span></span>;</span><br><span class="line">    soinfo* local_group_root = local_group.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> linked = local_group.<span class="built_in">visit</span>([&amp;](soinfo* si) &#123;</span><br><span class="line">      <span class="comment">// Even though local group may contain accessible soinfos from other namespaces</span></span><br><span class="line">      <span class="comment">// we should avoid linking them (because if they are not linked -&gt; they</span></span><br><span class="line">      <span class="comment">// are in the local_group_roots and will be linked later).</span></span><br><span class="line">      <span class="keyword">if</span> (!si-&gt;<span class="built_in">is_linked</span>() &amp;&amp; si-&gt;<span class="built_in">get_primary_namespace</span>() == local_group_ns) &#123;</span><br><span class="line">        <span class="type">const</span> android_dlextinfo* link_extinfo = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (si == soinfos[<span class="number">0</span>] || reserved_address_recursive) &#123;</span><br><span class="line">          <span class="comment">// Only forward extinfo for the first library unless the recursive</span></span><br><span class="line">          <span class="comment">// flag is set.</span></span><br><span class="line">          link_extinfo = extinfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (__libc_shared_globals()-&gt;load_hook) &#123;</span><br><span class="line">          __libc_shared_globals()-&gt;<span class="built_in">load_hook</span>(si-&gt;load_bias, si-&gt;phdr, si-&gt;phnum);</span><br><span class="line">        &#125;</span><br><span class="line">        lookup_list.<span class="built_in">set_dt_symbolic_lib</span>(si-&gt;has_DT_SYMBOLIC ? si : <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 链接</span></span><br><span class="line">        <span class="keyword">if</span> (!si-&gt;<span class="built_in">link_image</span>(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) ||</span><br><span class="line">            !<span class="built_in">get_cfi_shadow</span>()-&gt;<span class="built_in">AfterLoad</span>(si, <span class="built_in">solist_get_head</span>())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!linked) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表即soinfo为linked。</span></span><br><span class="line">  <span class="comment">// Step 7: Mark all load_tasks as linked and increment refcounts</span></span><br><span class="line">  <span class="comment">// for references between load_groups (at this point it does not matter if</span></span><br><span class="line">  <span class="comment">// referenced load_groups were loaded by previous dlopen or as part of this</span></span><br><span class="line">  <span class="comment">// one on step 6)</span></span><br><span class="line">  <span class="keyword">if</span> (start_with != <span class="literal">nullptr</span> &amp;&amp; add_as_children) &#123;</span><br><span class="line">    start_with-&gt;<span class="built_in">set_linked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    si-&gt;<span class="built_in">set_linked</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; task : load_tasks) &#123;</span><br><span class="line">    soinfo* si = task-&gt;<span class="built_in">get_soinfo</span>();</span><br><span class="line">    soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">    <span class="keyword">if</span> (needed_by != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        needed_by != start_with &amp;&amp;</span><br><span class="line">        needed_by-&gt;<span class="built_in">get_local_group_root</span>() != si-&gt;<span class="built_in">get_local_group_root</span>()) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">increment_ref_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>find_libraries函数几乎包含了整个动态的加载阶段，它分了7步来加载动态，我们主要看下核心的一些步骤。</p>
<h1 id="一bfs寻找所有的依赖">一、BFS寻找所有的依赖</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker.cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">find_library_internal</span><span class="params">(<span class="type">android_namespace_t</span>* ns, <span class="comment">// 名称空间</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  LoadTask* task,<span class="comment">//当前加载的任务</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  LoadTaskList* load_tasks, <span class="comment">// 任务列表</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">int</span> rtld_flags)</span> </span>&#123;</span><br><span class="line">  soinfo* candidate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 看看当前的名称空间是否已经能访问到这个so。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">find_loaded_library_by_soname</span>(ns, task-&gt;<span class="built_in">get_name</span>(), <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>,</span><br><span class="line">                                    &amp;candidate)) &#123;</span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;find_library_internal(ns=%s, task=%s): Already loaded (by soname): %s&quot;</span>,</span><br><span class="line">           ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), candidate-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">    task-&gt;<span class="built_in">set_soinfo</span>(candidate);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Library might still be loaded, the accurate detection</span></span><br><span class="line">  <span class="comment">// of this fact is done by load_library.</span></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;[ \&quot;%s\&quot; find_loaded_library_by_soname failed (*candidate=%s@%p). Trying harder... ]&quot;</span>,</span><br><span class="line">           task-&gt;<span class="built_in">get_name</span>(), candidate == <span class="literal">nullptr</span> ? <span class="string">&quot;n/a&quot;</span> : candidate-&gt;<span class="built_in">get_realpath</span>(), candidate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载这个动态库</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">load_library</span>(ns, task, zip_archive_cache, load_tasks, rtld_flags,</span><br><span class="line">                   <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(dimitry): workaround for http://b/26394120 (the exempt-list)</span></span><br><span class="line">  <span class="keyword">if</span> (ns-&gt;<span class="built_in">is_exempt_list_enabled</span>() &amp;&amp; <span class="built_in">is_exempt_lib</span>(ns, task-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_needed_by</span>())) &#123;</span><br><span class="line">    <span class="comment">// For the libs in the exempt-list, switch to the default namespace and then</span></span><br><span class="line">    <span class="comment">// try the load again from there. The library could be loaded from the</span></span><br><span class="line">    <span class="comment">// default namespace or from another namespace (e.g. runtime) that is linked</span></span><br><span class="line">    <span class="comment">// from the default namespace.</span></span><br><span class="line">    <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">           <span class="string">&quot;find_library_internal(ns=%s, task=%s): Exempt system library - trying namespace %s&quot;</span>,</span><br><span class="line">           ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), g_default_namespace.<span class="built_in">get_name</span>());</span><br><span class="line">    ns = &amp;g_default_namespace;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">load_library</span>(ns, task, zip_archive_cache, load_tasks, rtld_flags,</span><br><span class="line">                     <span class="literal">true</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// END OF WORKAROUND</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// if a library was not found - look into linked namespaces</span></span><br><span class="line">  <span class="comment">// preserve current dlerror in the case it fails.</span></span><br><span class="line">  DlErrorRestorer dlerror_restorer;</span><br><span class="line">  <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;find_library_internal(ns=%s, task=%s): Trying %zu linked namespaces&quot;</span>,</span><br><span class="line">         ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), ns-&gt;<span class="built_in">linked_namespaces</span>().<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; linked_namespace : ns-&gt;<span class="built_in">linked_namespaces</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_library_in_linked_namespace</span>(linked_namespace, task)) &#123;</span><br><span class="line">      <span class="comment">// Library is already loaded.</span></span><br><span class="line">      <span class="keyword">if</span> (task-&gt;<span class="built_in">get_soinfo</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// n.b. This code path runs when find_library_in_linked_namespace found an already-loaded</span></span><br><span class="line">        <span class="comment">// library by soname. That should only be possible with a exempt-list lookup, where we</span></span><br><span class="line">        <span class="comment">// switch the namespace, because otherwise, find_library_in_linked_namespace is duplicating</span></span><br><span class="line">        <span class="comment">// the soname scan done in this function&#x27;s first call to find_loaded_library_by_soname.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">load_library</span>(linked_namespace.<span class="built_in">linked_namespace</span>(), task, zip_archive_cache, load_tasks,</span><br><span class="line">                       rtld_flags, <span class="literal">false</span> <span class="comment">/* search_linked_namespaces */</span>)) &#123;</span><br><span class="line">        <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;find_library_internal(ns=%s, task=%s): Found in linked namespace %s&quot;</span>,</span><br><span class="line">               ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), linked_namespace.<span class="built_in">linked_namespace</span>()-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">load_library</span><span class="params">(<span class="type">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTask* task,</span></span></span><br><span class="line"><span class="params"><span class="function">                         ZipArchiveCache* zip_archive_cache,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name = task-&gt;<span class="built_in">get_name</span>();</span><br><span class="line">  soinfo* needed_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">  <span class="type">const</span> android_dlextinfo* extinfo = task-&gt;<span class="built_in">get_extinfo</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (extinfo != <span class="literal">nullptr</span> &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">off64_t</span> file_offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != <span class="number">0</span>) &#123;</span><br><span class="line">      file_offset = extinfo-&gt;library_fd_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string realpath;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">realpath_fd</span>(extinfo-&gt;library_fd, &amp;realpath)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_first_stage_init</span>()) &#123;</span><br><span class="line">        <span class="built_in">DL_WARN</span>(<span class="string">&quot;unable to get realpath for the library \&quot;%s\&quot; by extinfo-&gt;library_fd. &quot;</span></span><br><span class="line">                <span class="string">&quot;Will use given name.&quot;</span>,</span><br><span class="line">                name);</span><br><span class="line">      &#125;</span><br><span class="line">      realpath = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task-&gt;<span class="built_in">set_fd</span>(extinfo-&gt;library_fd, <span class="literal">false</span>);</span><br><span class="line">    task-&gt;<span class="built_in">set_file_offset</span>(file_offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">load_library</span>(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">         <span class="string">&quot;load_library(ns=%s, task=%s, flags=0x%x, search_linked_namespaces=%d): calling &quot;</span></span><br><span class="line">         <span class="string">&quot;open_library&quot;</span>,</span><br><span class="line">         ns-&gt;<span class="built_in">get_name</span>(), name, rtld_flags, search_linked_namespaces);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the file.</span></span><br><span class="line">  <span class="type">off64_t</span> file_offset;</span><br><span class="line">  std::string realpath;</span><br><span class="line">  <span class="comment">// 寻找到ELF文件并打开得到fd。</span></span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open_library</span>(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task-&gt;<span class="built_in">is_dt_needed</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (needed_by-&gt;<span class="built_in">is_main_executable</span>()) &#123;</span><br><span class="line">        <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found: needed by main executable&quot;</span>, name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found: needed by %s in namespace %s&quot;</span>, name,</span><br><span class="line">                    needed_by-&gt;<span class="built_in">get_realpath</span>(), task-&gt;<span class="built_in">get_start_from</span>()-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; not found&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将ELF文件的fd设置给task</span></span><br><span class="line">  task-&gt;<span class="built_in">set_fd</span>(fd, <span class="literal">true</span>);</span><br><span class="line">  task-&gt;<span class="built_in">set_file_offset</span>(file_offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">load_library</span>(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">load_library</span><span class="params">(<span class="type">android_namespace_t</span>* ns,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTask* task,</span></span></span><br><span class="line"><span class="params"><span class="function">                         LoadTaskList* load_tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> rtld_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::string&amp; realpath,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">bool</span> search_linked_namespaces)</span> </span>&#123;</span><br><span class="line">  <span class="type">off64_t</span> file_offset = task-&gt;<span class="built_in">get_file_offset</span>();</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name = task-&gt;<span class="built_in">get_name</span>();</span><br><span class="line">  <span class="type">const</span> android_dlextinfo* extinfo = task-&gt;<span class="built_in">get_extinfo</span>();</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Check for symlink and other situations where</span></span><br><span class="line">  <span class="comment">// file can have different names, unless ANDROID_DLEXT_FORCE_LOAD is set</span></span><br><span class="line">  <span class="keyword">if</span> (extinfo == <span class="literal">nullptr</span> || (extinfo-&gt;flags &amp; ANDROID_DLEXT_FORCE_LOAD) == <span class="number">0</span>) &#123;</span><br><span class="line">    soinfo* si = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find_loaded_library_by_inode</span>(ns, file_stat, file_offset, search_linked_namespaces, &amp;si)) &#123;</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen,</span><br><span class="line">             <span class="string">&quot;load_library(ns=%s, task=%s): Already loaded under different name/path \&quot;%s\&quot; - &quot;</span></span><br><span class="line">             <span class="string">&quot;will return existing soinfo&quot;</span>,</span><br><span class="line">             ns-&gt;<span class="built_in">get_name</span>(), name, si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      task-&gt;<span class="built_in">set_soinfo</span>(si);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((rtld_flags &amp; RTLD_NOLOAD) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; wasn&#x27;t loaded and RTLD_NOLOAD prevented it&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">statfs</span> fs_stat;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">fstatfs</span>(task-&gt;<span class="built_in">get_fd</span>(), &amp;fs_stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;unable to fstatfs file for the library \&quot;%s\&quot;: %m&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not check accessibility using realpath if fd is located on tmpfs</span></span><br><span class="line">  <span class="comment">// this enables use of memfd_create() for apps</span></span><br><span class="line">  <span class="keyword">if</span> ((fs_stat.f_type != TMPFS_MAGIC) &amp;&amp; (!ns-&gt;<span class="built_in">is_accessible</span>(realpath))) &#123;</span><br><span class="line">    <span class="comment">// TODO(dimitry): workaround for http://b/26394120 - the exempt-list</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> soinfo* needed_by = task-&gt;<span class="built_in">is_dt_needed</span>() ? task-&gt;<span class="built_in">get_needed_by</span>() : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_exempt_lib</span>(ns, name, needed_by)) &#123;</span><br><span class="line">      <span class="comment">// print warning only if needed by non-system library</span></span><br><span class="line">      <span class="keyword">if</span> (needed_by == <span class="literal">nullptr</span> || !<span class="built_in">is_system_library</span>(needed_by-&gt;<span class="built_in">get_realpath</span>())) &#123;</span><br><span class="line">        <span class="type">const</span> soinfo* needed_or_dlopened_by = task-&gt;<span class="built_in">get_needed_by</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* sopath = needed_or_dlopened_by == <span class="literal">nullptr</span> ? <span class="string">&quot;(unknown)&quot;</span> :</span><br><span class="line">                                                      needed_or_dlopened_by-&gt;<span class="built_in">get_realpath</span>();</span><br><span class="line">        <span class="comment">// is_exempt_lib() always returns true for targetSdkVersion &lt; 24,</span></span><br><span class="line">        <span class="comment">// so no need to check the return value of DL_ERROR_AFTER().</span></span><br><span class="line">        <span class="comment">// We still call it rather than DL_WARN() to get the extra clarification.</span></span><br><span class="line">        <span class="built_in">DL_ERROR_AFTER</span>(<span class="number">24</span>, <span class="string">&quot;library \&quot;%s\&quot; (\&quot;%s\&quot;) needed or dlopened by \&quot;%s\&quot; &quot;</span></span><br><span class="line">                       <span class="string">&quot;is not accessible by namespace \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">                       name, realpath.<span class="built_in">c_str</span>(), sopath, ns-&gt;<span class="built_in">get_name</span>());</span><br><span class="line">        <span class="built_in">add_dlwarning</span>(sopath, <span class="string">&quot;unauthorized access to&quot;</span>,  name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// do not load libraries if they are not accessible for the specified namespace.</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* needed_or_dlopened_by = task-&gt;<span class="built_in">get_needed_by</span>() == <span class="literal">nullptr</span> ?</span><br><span class="line">                                          <span class="string">&quot;(unknown)&quot;</span> :</span><br><span class="line">                                          task-&gt;<span class="built_in">get_needed_by</span>()-&gt;<span class="built_in">get_realpath</span>();</span><br><span class="line"></span><br><span class="line">      <span class="built_in">DL_OPEN_ERR</span>(<span class="string">&quot;library \&quot;%s\&quot; needed or dlopened by \&quot;%s\&quot; is not accessible for the namespace \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">             name, needed_or_dlopened_by, ns-&gt;<span class="built_in">get_name</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// do not print this if a library is in the list of shared libraries for linked namespaces</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">maybe_accessible_via_namespace_links</span>(ns, name)) &#123;</span><br><span class="line">        <span class="built_in">DL_WARN</span>(<span class="string">&quot;library \&quot;%s\&quot; (\&quot;%s\&quot;) needed or dlopened by \&quot;%s\&quot; is not accessible for the&quot;</span></span><br><span class="line">                <span class="string">&quot; namespace: [name=\&quot;%s\&quot;, ld_library_paths=\&quot;%s\&quot;, default_library_paths=\&quot;%s\&quot;,&quot;</span></span><br><span class="line">                <span class="string">&quot; permitted_paths=\&quot;%s\&quot;]&quot;</span>,</span><br><span class="line">                name, realpath.<span class="built_in">c_str</span>(),</span><br><span class="line">                needed_or_dlopened_by,</span><br><span class="line">                ns-&gt;<span class="built_in">get_name</span>(),</span><br><span class="line">                android::base::<span class="built_in">Join</span>(ns-&gt;<span class="built_in">get_ld_library_paths</span>(), <span class="string">&#x27;:&#x27;</span>).<span class="built_in">c_str</span>(),</span><br><span class="line">                android::base::<span class="built_in">Join</span>(ns-&gt;<span class="built_in">get_default_library_paths</span>(), <span class="string">&#x27;:&#x27;</span>).<span class="built_in">c_str</span>(),</span><br><span class="line">                android::base::<span class="built_in">Join</span>(ns-&gt;<span class="built_in">get_permitted_paths</span>(), <span class="string">&#x27;:&#x27;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建出soinfo</span></span><br><span class="line">  soinfo* si = <span class="built_in">soinfo_alloc</span>(ns, realpath.<span class="built_in">c_str</span>(), &amp;file_stat, file_offset, rtld_flags);</span><br><span class="line">  <span class="comment">// 将soinfo设置给加载任务</span></span><br><span class="line">  task-&gt;<span class="built_in">set_soinfo</span>(si);</span><br><span class="line">  <span class="comment">// 注意：创建ELFReader，读取ELF文件.</span></span><br><span class="line">  <span class="comment">// Read the ELF header and some of the segments.</span></span><br><span class="line">  <span class="keyword">if</span> (!task-&gt;<span class="built_in">read</span>(realpath.<span class="built_in">c_str</span>(), file_stat.st_size)) &#123;</span><br><span class="line">    task-&gt;<span class="built_in">remove_cached_elf_reader</span>();</span><br><span class="line">    task-&gt;<span class="built_in">set_soinfo</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">soinfo_free</span>(si);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find and set DT_RUNPATH, DT_SONAME, and DT_FLAGS_1.</span></span><br><span class="line">  <span class="comment">// Note that these field values are temporary and are</span></span><br><span class="line">  <span class="comment">// going to be overwritten on soinfo::prelink_image</span></span><br><span class="line">  <span class="comment">// with values from PT_LOAD segments.</span></span><br><span class="line">  <span class="type">const</span> ElfReader&amp; elf_reader = task-&gt;<span class="built_in">get_elf_reader</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)* d = elf_reader.<span class="built_in">dynamic</span>(); d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_RUNPATH) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_dt_runpath</span>(elf_reader.<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置SoName</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_SONAME) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_soname</span>(elf_reader.<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// We need to identify a DF_1_GLOBAL library early so we can link it to namespaces.</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_FLAGS_1) &#123;</span><br><span class="line">      si-&gt;<span class="built_in">set_dt_flags_1</span>(d-&gt;d_un.d_val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__ANDROID__)</span></span><br><span class="line">  <span class="comment">// Bionic on the host currently uses some Android prebuilts, which don&#x27;t set</span></span><br><span class="line">  <span class="comment">// DT_RUNPATH with any relative paths, so they can&#x27;t find their dependencies.</span></span><br><span class="line">  <span class="comment">// b/118058804</span></span><br><span class="line">  <span class="keyword">if</span> (si-&gt;<span class="built_in">get_dt_runpath</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    si-&gt;<span class="built_in">set_dt_runpath</span>(<span class="string">&quot;$ORIGIN/../lib64:$ORIGIN/lib64&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取dynamic段</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)* d = elf_reader.<span class="built_in">dynamic</span>(); d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;d_tag == DT_NEEDED) &#123; <span class="comment">// 读取DT_NEEDED,获取依赖列表</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">fix_dt_needed</span>(elf_reader.<span class="built_in">get_string</span>(d-&gt;d_un.d_val), elf_reader.<span class="built_in">name</span>());</span><br><span class="line">      <span class="built_in">LD_LOG</span>(kLogDlopen, <span class="string">&quot;load_library(ns=%s, task=%s): Adding DT_NEEDED task: %s&quot;</span>,</span><br><span class="line">             ns-&gt;<span class="built_in">get_name</span>(), task-&gt;<span class="built_in">get_name</span>(), name);</span><br><span class="line">      <span class="comment">// 对依赖的库，创建一个LoadTask，并加入到load_tasks中。从而导致循环不结束。（BFS遍历算法）。</span></span><br><span class="line">      load_tasks-&gt;<span class="built_in">push_back</span>(LoadTask::<span class="built_in">create</span>(name, si, ns, task-&gt;<span class="built_in">get_readers_map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建soinfo，并添加到solist中</span></span><br><span class="line"><span class="function">soinfo* <span class="title">soinfo_alloc</span><span class="params">(<span class="type">android_namespace_t</span>* ns, <span class="type">const</span> <span class="type">char</span>* name,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="keyword">struct</span> stat* file_stat, <span class="type">off64_t</span> file_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">uint32_t</span> rtld_flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(name) &gt;= PATH_MAX) &#123;</span><br><span class="line">    <span class="built_in">async_safe_fatal</span>(<span class="string">&quot;library name \&quot;%s\&quot; too long&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;name %s: allocating soinfo for ns=%p&quot;</span>, name, ns);</span><br><span class="line"></span><br><span class="line">  soinfo* si = <span class="built_in">new</span> (g_soinfo_allocator.<span class="built_in">alloc</span>()) <span class="built_in">soinfo</span>(ns, name, file_stat,</span><br><span class="line">                                                       file_offset, rtld_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将soinfo增加到solist中</span></span><br><span class="line">  <span class="built_in">solist_add_soinfo</span>(si);</span><br><span class="line"><span class="comment">// 生成handle</span></span><br><span class="line">  si-&gt;<span class="built_in">generate_handle</span>();</span><br><span class="line">  ns-&gt;<span class="built_in">add_soinfo</span>(si);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;name %s: allocated soinfo @ %p&quot;</span>, name, si);</span><br><span class="line">  <span class="keyword">return</span> si;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="读取elf文件">读取ELF文件</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linkerphdr.cpp</span></span><br><span class="line"><span class="comment">// 读取ELF文件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::Read</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> fd, <span class="type">off64_t</span> file_offset, <span class="type">off64_t</span> file_size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (did_read_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  name_ = name;</span><br><span class="line">  fd_ = fd;</span><br><span class="line">  file_offset_ = file_offset;</span><br><span class="line">  file_size_ = file_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ReadElfHeader</span>() &amp;&amp; <span class="comment">// 读取ELF文件头</span></span><br><span class="line">      <span class="built_in">VerifyElfHeader</span>() &amp;&amp; <span class="comment">// 验证ELF文件头</span></span><br><span class="line">      <span class="built_in">ReadProgramHeaders</span>() &amp;&amp; <span class="comment">// 映射Phdrs</span></span><br><span class="line">      <span class="built_in">CheckProgramHeaderAlignment</span>() &amp;&amp; <span class="comment">// 对齐</span></span><br><span class="line">      <span class="built_in">ReadSectionHeaders</span>() &amp;&amp; <span class="comment">// 映射Shdrs</span></span><br><span class="line">      <span class="built_in">ReadDynamicSection</span>() &amp;&amp; <span class="comment">// 得到Dynamic信息</span></span><br><span class="line">      <span class="built_in">ReadPadSegmentNote</span>()) &#123; <span class="comment">// pad</span></span><br><span class="line">    did_read_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (kPageSize == <span class="number">16</span>*<span class="number">1024</span> &amp;&amp; min_align_ == <span class="number">4096</span>) &#123;</span><br><span class="line">    <span class="comment">// This prop needs to be read on 16KiB devices for each ELF where min_palign is 4KiB.</span></span><br><span class="line">    <span class="comment">// It cannot be cached since the developer may toggle app compat on/off.</span></span><br><span class="line">    <span class="comment">// This check will be removed once app compat is made the default on 16KiB devices.</span></span><br><span class="line">    should_use_16kib_app_compat_ =</span><br><span class="line">        ::android::base::<span class="built_in">GetBoolProperty</span>(<span class="string">&quot;bionic.linker.16kb.app_compat.enabled&quot;</span>, <span class="literal">false</span>) ||</span><br><span class="line">        <span class="built_in">get_16kb_appcompat_mode</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> did_read_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件头</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">ssize_t</span> rc = <span class="built_in">TEMP_FAILURE_RETRY</span>(<span class="built_in">pread64</span>(fd_, &amp;header_, <span class="built_in">sizeof</span>(header_), file_offset_));</span><br><span class="line">  <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t read file \&quot;%s\&quot;: %s&quot;</span>, name_.<span class="built_in">c_str</span>(), <span class="built_in">strerror</span>(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rc != <span class="built_in">sizeof</span>(header_)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is too small to be an ELF executable: only found %zd bytes&quot;</span>, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(rc));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证ELF文件头</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::VerifyElfHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 对比文件的魔术看是否匹配   </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(header_.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has bad ELF magic: %02x%02x%02x%02x&quot;</span>, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">           header_.e_ident[<span class="number">0</span>], header_.e_ident[<span class="number">1</span>], header_.e_ident[<span class="number">2</span>], header_.e_ident[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看位宽是否匹配</span></span><br><span class="line">  <span class="comment">// Try to give a clear diagnostic for ELF class mismatches, since they&#x27;re</span></span><br><span class="line">  <span class="comment">// an easy mistake to make during the 32-bit/64-bit transition period.</span></span><br><span class="line">  <span class="type">int</span> elf_class = header_.e_ident[EI_CLASS];</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS64) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS32) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is 32-bit instead of 64-bit&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (elf_class != ELFCLASS32) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elf_class == ELFCLASS64) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is 64-bit instead of 32-bit&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), elf_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 查看字节序是否匹配</span></span><br><span class="line">  <span class="keyword">if</span> (header_.e_ident[EI_DATA] != ELFDATA2LSB) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; not little-endian: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), header_.e_ident[EI_DATA]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_type != ET_DYN) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_type: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), header_.e_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_version != EV_CURRENT) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has unexpected e_version: %d&quot;</span>, name_.<span class="built_in">c_str</span>(), header_.e_version);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 校验架构是否匹配</span></span><br><span class="line">  <span class="keyword">if</span> (header_.e_machine != <span class="built_in">GetTargetElfMachine</span>()) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; is for %s (%d) instead of %s (%d)&quot;</span>,</span><br><span class="line">           name_.<span class="built_in">c_str</span>(),</span><br><span class="line">           <span class="built_in">EM_to_string</span>(header_.e_machine), header_.e_machine,</span><br><span class="line">           <span class="built_in">EM_to_string</span>(<span class="built_in">GetTargetElfMachine</span>()), <span class="built_in">GetTargetElfMachine</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_shentsize != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Shdr))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; has unsupported e_shentsize: 0x%x (expected 0x%zx)&quot;</span>,</span><br><span class="line">                       name_.<span class="built_in">c_str</span>(), header_.e_shentsize, <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Shdr)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;has invalid ELF header&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (header_.e_shstrndx == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; has invalid e_shstrndx&quot;</span>, name_.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;has invalid ELF header&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将ELF文件中的phdrs map到私有、只读、匿名内存块</span></span><br><span class="line"><span class="comment">// Loads the program header table from an ELF file into a read-only private</span></span><br><span class="line"><span class="comment">// anonymous mmap-ed block.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadProgramHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  phdr_num_ = header_.e_phnum;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Like the kernel, we only accept program header tables that</span></span><br><span class="line">  <span class="comment">// are smaller than 64KiB.</span></span><br><span class="line">  <span class="keyword">if</span> (phdr_num_ &lt; <span class="number">1</span> || phdr_num_ &gt; <span class="number">65536</span>/<span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Phdr))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid e_phnum: %zd&quot;</span>, name_.<span class="built_in">c_str</span>(), phdr_num_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界检查</span></span><br><span class="line">  <span class="comment">// Boundary checks</span></span><br><span class="line">  <span class="type">size_t</span> size = phdr_num_ * <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Phdr));</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(header_.e_phoff, size, <span class="built_in">alignof</span>(<span class="built_in">ElfW</span>(Phdr)))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid phdr offset/size: %zu/%zu&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                   <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(header_.e_phoff),</span><br><span class="line">                   size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mmap64映射</span></span><br><span class="line">  <span class="keyword">if</span> (!phdr_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, header_.e_phoff, size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; phdr mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 记录映射后的phdr表的起始位置</span></span><br><span class="line">  phdr_table_ = <span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Phdr)*&gt;(phdr_fragment_.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存映射</span></span><br><span class="line"><span class="comment">// fd: ELF文件的fd</span></span><br><span class="line"><span class="comment">// base_offset: ELF问价本身的偏移</span></span><br><span class="line"><span class="comment">// elf_offset: 要映射的区域本身在ELF文件中的区域。</span></span><br><span class="line"><span class="comment">// size: 要映射的区域的大小</span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line"><span class="comment">//  VirtualMemory                 File</span></span><br><span class="line"><span class="comment">// ....                            ...</span></span><br><span class="line"><span class="comment">// 0x...5000                        10      // 需要的内存地址开始</span></span><br><span class="line"><span class="comment">// 0x...5008                        18</span></span><br><span class="line"><span class="comment">// ...                             ...</span></span><br><span class="line"><span class="comment">// 0x...5128                       4128     // 需要被加载文件偏移开始</span></span><br><span class="line"><span class="comment">// 0x...5130                       4130</span></span><br><span class="line"><span class="comment">// 0x...5138                       4138</span></span><br><span class="line"><span class="comment">// ...                             ...</span></span><br><span class="line"><span class="comment">// 0x...6120                       5120     // 需要被加载的文件结束    </span></span><br><span class="line"><span class="comment">// ...                             ...</span></span><br><span class="line"><span class="comment">// 0x...6FFF                       ...      // 需要的内存地址结束</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MappedFileFragment::Map</span><span class="params">(<span class="type">int</span> fd, <span class="type">off64_t</span> base_offset, <span class="type">size_t</span> elf_offset, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">off64_t</span> offset;</span><br><span class="line">  <span class="comment">// 得到具体偏移，offset = base_offset + elf_offset</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">safe_add</span>(&amp;offset, base_offset, elf_offset));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为mmap是按页来映射的，所以这里需要根据文件映射区域的起始位置和大小，计算需要的页大小。</span></span><br><span class="line">  <span class="comment">// 计算这个偏移对应的页开始位置,比如假设PAGESIZE是4096（0x1000),偏移是0x4128，则得到0x4000</span></span><br><span class="line">  <span class="type">off64_t</span> page_min = <span class="built_in">page_start</span>(offset);</span><br><span class="line">  <span class="type">off64_t</span> end_offset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算得到区域的结束位置</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">safe_add</span>(&amp;end_offset, offset, size));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 补齐。比如偏移是0x4128,因为page_min为0x4000。如果仍然size来映射的话，可能得到的内存不够。</span></span><br><span class="line">  <span class="comment">// 所以需要在给end_offset增加0x128。</span></span><br><span class="line">  <span class="built_in">CHECK</span>(<span class="built_in">safe_add</span>(&amp;end_offset, end_offset, <span class="built_in">page_offset</span>(offset)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到需要的内存大小</span></span><br><span class="line">  <span class="type">size_t</span> map_size = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(end_offset - page_min);</span><br><span class="line">  <span class="built_in">CHECK</span>(map_size &gt;= size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将文件映射到内存</span></span><br><span class="line">  <span class="type">uint8_t</span>* map_start = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(</span><br><span class="line">                          <span class="built_in">mmap64</span>(<span class="literal">nullptr</span>, map_size, PROT_READ, MAP_PRIVATE, fd, page_min));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map_start == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存页开始位置</span></span><br><span class="line">  map_start_ = map_start;</span><br><span class="line"><span class="comment">// 内存页大小  </span></span><br><span class="line">  map_size_ = map_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到数据的开始位置指针</span></span><br><span class="line">  data_ = map_start + <span class="built_in">page_offset</span>(offset);</span><br><span class="line">  <span class="comment">// 数据大小</span></span><br><span class="line">  size_ = size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the address of the page containing address &#x27;x&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">page_start</span><span class="params">(<span class="type">uintptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; ~(<span class="built_in">page_size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the offset of address &#x27;x&#x27; in its page.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">page_offset</span><span class="params">(<span class="type">uintptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; (<span class="built_in">page_size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the address of the next page after address &#x27;x&#x27;, unless &#x27;x&#x27; is</span></span><br><span class="line"><span class="comment">// itself at the start of a page.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uintptr_t</span> <span class="title">page_end</span><span class="params">(<span class="type">uintptr_t</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">page_start</span>(x + <span class="built_in">page_size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据phdr中的p_align计算对齐</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::CheckProgramHeaderAlignment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  max_align_ = min_align_ = <span class="built_in">page_size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For loadable segments, p_align must be 0, 1,</span></span><br><span class="line">    <span class="comment">// or a positive, integral power of two.</span></span><br><span class="line">    <span class="comment">// The kernel ignores loadable segments with other values,</span></span><br><span class="line">    <span class="comment">// so we just warn rather than reject them.</span></span><br><span class="line">    <span class="keyword">if</span> ((phdr-&gt;p_align &amp; (phdr-&gt;p_align - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_WARN</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid p_align %zx in phdr %zu&quot;</span>, name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                     <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(phdr-&gt;p_align), i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    max_align_ = std::<span class="built_in">max</span>(max_align_, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(phdr-&gt;p_align));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_align &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      min_align_ = std::<span class="built_in">min</span>(min_align_, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(phdr-&gt;p_align));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射Shdrs</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadSectionHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  shdr_num_ = header_.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr_num_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has no section headers&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size = shdr_num_ * <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Shdr));</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(header_.e_shoff, size, <span class="built_in">alignof</span>(<span class="type">const</span> <span class="built_in">ElfW</span>(Shdr)))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid shdr offset/size: %zu/%zu&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                   <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(header_.e_shoff),</span><br><span class="line">                   size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!shdr_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, header_.e_shoff, size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; shdr mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 记录shdr表开始位置</span></span><br><span class="line">  shdr_table_ = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="built_in">ElfW</span>(Shdr)*&gt;(shdr_fragment_.<span class="built_in">data</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Dynamic节</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReadDynamicSection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. Find .dynamic section (in section headers)</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Shdr)</span>* dynamic_shdr </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shdr_num_; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shdr_table_[i].sh_type == SHT_DYNAMIC) &#123;</span><br><span class="line">      <span class="comment">// 记录dynamic_shdr</span></span><br><span class="line">      dynamic_shdr = &amp;shdr_table_ [i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dynamic_shdr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; .dynamic section header was not found&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验shdr中描述的dynamic节的偏移和phdr中描述dynamic开始位置是一致且大小一致</span></span><br><span class="line">  <span class="comment">// Make sure dynamic_shdr offset and size matches PT_DYNAMIC phdr</span></span><br><span class="line">  <span class="type">size_t</span> pt_dynamic_offset = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> pt_dynamic_filesz = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type == PT_DYNAMIC) &#123;</span><br><span class="line">      pt_dynamic_offset = phdr-&gt;p_offset;</span><br><span class="line">      pt_dynamic_filesz = phdr-&gt;p_filesz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pt_dynamic_offset != dynamic_shdr-&gt;sh_offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid offset: 0x%zx, &quot;</span></span><br><span class="line">                       <span class="string">&quot;expected to match PT_DYNAMIC offset: 0x%zx&quot;</span>,</span><br><span class="line">                       name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                       <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(dynamic_shdr-&gt;sh_offset),</span><br><span class="line">                       pt_dynamic_offset)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;invalid .dynamic section&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pt_dynamic_filesz != dynamic_shdr-&gt;sh_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid size: 0x%zx &quot;</span></span><br><span class="line">                       <span class="string">&quot;(expected to match PT_DYNAMIC filesz 0x%zx)&quot;</span>,</span><br><span class="line">                       name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                       <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(dynamic_shdr-&gt;sh_size),</span><br><span class="line">                       pt_dynamic_filesz)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;invalid .dynamic section&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dynamic_shdr-&gt;sh_link &gt;= shdr_num_) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid sh_link: %d&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(),</span><br><span class="line">                   dynamic_shdr-&gt;sh_link);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到字符串表</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Shdr)</span>* strtab_shdr </span>= &amp;shdr_table_[dynamic_shdr-&gt;sh_link];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (strtab_shdr-&gt;sh_type != SHT_STRTAB) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; .dynamic section has invalid link(%d) sh_type: %d (expected SHT_STRTAB)&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(), dynamic_shdr-&gt;sh_link, strtab_shdr-&gt;sh_type);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(dynamic_shdr-&gt;sh_offset, dynamic_shdr-&gt;sh_size, <span class="built_in">alignof</span>(<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid offset/size of .dynamic section&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将dynamic节映射到内存</span></span><br><span class="line">  <span class="keyword">if</span> (!dynamic_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, dynamic_shdr-&gt;sh_offset, dynamic_shdr-&gt;sh_size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; dynamic section mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到到dynamic节</span></span><br><span class="line">  dynamic_ = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="built_in">ElfW</span>(Dyn)*&gt;(dynamic_fragment_.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">CheckFileRange</span>(strtab_shdr-&gt;sh_offset, strtab_shdr-&gt;sh_size, <span class="built_in">alignof</span>(<span class="type">const</span> <span class="type">char</span>))) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; has invalid offset/size of the .strtab section linked from .dynamic section&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将字符串映射到内存</span></span><br><span class="line">  <span class="keyword">if</span> (!strtab_fragment_.<span class="built_in">Map</span>(fd_, file_offset_, strtab_shdr-&gt;sh_offset, strtab_shdr-&gt;sh_size)) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; strtab section mmap failed: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 找到了字符串</span></span><br><span class="line">  strtab_ = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(strtab_fragment_.<span class="built_in">data</span>());</span><br><span class="line">  strtab_size_ = strtab_fragment_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里读取了ELF文件的基本信息并完成了校验。并且将Phdr、Shdr、dynamic节、strtab节等映射到了内存，并记录到了ELFReader中的变量。</p>
<h1 id="二加载动态库">二、加载动态库</h1>
<p><img src="/images/android/native_dynamic_so_load.png" alt="LoadTask_load" width="720"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">load</span><span class="params">(address_space_params* address_space)</span> </span>&#123;</span><br><span class="line">    ElfReader&amp; elf_reader = <span class="built_in">get_elf_reader</span>();</span><br><span class="line">    <span class="comment">// 加载动态库，address_space用来指导内存的分配</span></span><br><span class="line">    <span class="keyword">if</span> (!elf_reader.<span class="built_in">Load</span>(address_space)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 将elf_reader中的load_bias,phdr初始地址等赋值到soinfo中。</span></span><br><span class="line">    si_-&gt;base = elf_reader.<span class="built_in">load_start</span>(); <span class="comment">// 内存页的起始位置</span></span><br><span class="line">    si_-&gt;size = elf_reader.<span class="built_in">load_size</span>();  <span class="comment">// 需要的内存大小</span></span><br><span class="line">    si_-&gt;<span class="built_in">set_mapped_by_caller</span>(elf_reader.<span class="built_in">is_mapped_by_caller</span>());</span><br><span class="line">    si_-&gt;load_bias = elf_reader.<span class="built_in">load_bias</span>(); <span class="comment">// 这个库的基地址</span></span><br><span class="line">    si_-&gt;phnum = elf_reader.<span class="built_in">phdr_count</span>(); </span><br><span class="line">    si_-&gt;phdr = elf_reader.<span class="built_in">loaded_phdr</span>();</span><br><span class="line">    si_-&gt;<span class="built_in">set_gap_start</span>(elf_reader.<span class="built_in">gap_start</span>());</span><br><span class="line">    si_-&gt;<span class="built_in">set_gap_size</span>(elf_reader.<span class="built_in">gap_size</span>());</span><br><span class="line">    si_-&gt;<span class="built_in">set_should_pad_segments</span>(elf_reader.<span class="built_in">should_pad_segments</span>());</span><br><span class="line">    si_-&gt;<span class="built_in">set_should_use_16kib_app_compat</span>(elf_reader.<span class="built_in">should_use_16kib_app_compat</span>());</span><br><span class="line">    <span class="keyword">if</span> (si_-&gt;<span class="built_in">should_use_16kib_app_compat</span>()) &#123;</span><br><span class="line">      si_-&gt;<span class="built_in">set_compat_relro_start</span>(elf_reader.<span class="built_in">compat_relro_start</span>());</span><br><span class="line">      si_-&gt;<span class="built_in">set_compat_relro_size</span>(elf_reader.<span class="built_in">compat_relro_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linker_phdr.cpp</span></span><br><span class="line"><span class="comment">// 将程序加载到指定内存位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::Load</span><span class="params">(address_space_params* address_space)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">CHECK</span>(did_read_);</span><br><span class="line">  <span class="keyword">if</span> (did_load_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据ELF文件可加载段的大小，预留内存位置</span></span><br><span class="line">  <span class="type">bool</span> reserveSuccess = <span class="built_in">ReserveAddressSpace</span>(address_space);</span><br><span class="line">  <span class="comment">// 加载Segments</span></span><br><span class="line">  <span class="keyword">if</span> (reserveSuccess &amp;&amp; <span class="built_in">LoadSegments</span>() &amp;&amp; <span class="built_in">FindPhdr</span>() &amp;&amp;</span><br><span class="line">      <span class="built_in">FindGnuPropertySection</span>()) &#123;</span><br><span class="line">    did_load_ = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__)</span></span><br><span class="line">    <span class="comment">// For Armv8.5-A loaded executable segments may require PROT_BTI.</span></span><br><span class="line">    <span class="keyword">if</span> (note_gnu_property_.<span class="built_in">IsBTICompatible</span>()) &#123;</span><br><span class="line">      did_load_ =</span><br><span class="line">          (<span class="built_in">phdr_table_protect_segments</span>(phdr_table_, phdr_num_, load_bias_, should_pad_segments_,</span><br><span class="line">                                       should_use_16kib_app_compat_, &amp;note_gnu_property_) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (reserveSuccess &amp;&amp; !did_load_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (load_start_ != <span class="literal">nullptr</span> &amp;&amp; load_size_ != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mapped_by_caller_) &#123;</span><br><span class="line">        <span class="built_in">munmap</span>(load_start_, load_size_);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> did_load_;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 预留一个能够容纳所有可加载段（loadable segments）的内存</span></span><br><span class="line"><span class="comment">// Reserve a virtual address range big enough to hold all loadable</span></span><br><span class="line"><span class="comment">// segments of a program header table. This is done by creating a</span></span><br><span class="line"><span class="comment">// private anonymous mmap() with PROT_NONE.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::ReserveAddressSpace</span><span class="params">(address_space_params* address_space)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) min_vaddr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算需要的内存大小</span></span><br><span class="line">  load_size_ = <span class="built_in">phdr_table_get_load_size</span>(phdr_table_, phdr_num_, &amp;min_vaddr);</span><br><span class="line">  <span class="keyword">if</span> (load_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has no loadable segments&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="comment">// Reserve additional space for aligning the permission boundary in compat loading</span></span><br><span class="line">    <span class="comment">// Up to kPageSize-kCompatPageSize additional space is needed, but reservation</span></span><br><span class="line">    <span class="comment">// is done with mmap which gives kPageSize multiple-sized reservations.</span></span><br><span class="line">    load_size_ += kPageSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序可加载段的最小偏移</span></span><br><span class="line">  <span class="type">uint8_t</span>* addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(min_vaddr);</span><br><span class="line">  <span class="type">void</span>* start;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认reserved_size是0，所以这个条件必然满足</span></span><br><span class="line">  <span class="keyword">if</span> (load_size_ &gt; address_space-&gt;reserved_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (address_space-&gt;must_use_address) &#123; <span class="comment">// 默认是false</span></span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;reserved address space %zd smaller than %zd bytes needed for \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">             load_size_ - address_space-&gt;reserved_size, load_size_, name_.<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> start_alignment = <span class="built_in">page_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_transparent_hugepages_supported</span>() &amp;&amp; <span class="built_in">get_application_target_sdk_version</span>() &gt;= <span class="number">31</span>) &#123;</span><br><span class="line">      <span class="comment">// Limit alignment to PMD size as other alignments reduce the number of</span></span><br><span class="line">      <span class="comment">// bits available for ASLR for no benefit.</span></span><br><span class="line">      start_alignment = max_align_ == kPmdSize ? kPmdSize : <span class="built_in">page_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预留内存位置，并获得内存的起始位置。</span></span><br><span class="line">    start = <span class="built_in">ReserveWithAlignmentPadding</span>(load_size_, kLibraryAlignment, start_alignment, &amp;gap_start_, &amp;gap_size_);</span><br><span class="line">    <span class="keyword">if</span> (start == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t reserve %zd bytes of address space for \&quot;%s\&quot;&quot;</span>, load_size_, name_.<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    start = address_space-&gt;start_addr;</span><br><span class="line">    gap_start_ = <span class="literal">nullptr</span>;</span><br><span class="line">    gap_size_ = <span class="number">0</span>;</span><br><span class="line">    mapped_by_caller_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the reserved address space to subtract the space used by this library.</span></span><br><span class="line">    address_space-&gt;start_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(address_space-&gt;start_addr) + load_size_;</span><br><span class="line">    address_space-&gt;reserved_size -= load_size_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 内存的起始位置</span></span><br><span class="line">  load_start_ = start;</span><br><span class="line"><span class="comment">// 得到程序的基地址  </span></span><br><span class="line">  load_bias_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(start) - addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="comment">// In compat mode make the initial mapping RW since the ELF contents will be read</span></span><br><span class="line">    <span class="comment">// into it; instead of mapped over it.</span></span><br><span class="line">    <span class="built_in">mprotect</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(start), load_size_, PROT_READ | PROT_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算出程序需要的地址空间大小，按页对齐。</span></span><br><span class="line"><span class="comment">// 遍历ELF文件中的所有PT_LOAD段，计算出最低地址和最高地址，即可以知道需要的内存大小。</span></span><br><span class="line"><span class="comment">/* Returns the size of the extent of all the possibly non-contiguous</span></span><br><span class="line"><span class="comment"> * loadable segments in an ELF program header table. This corresponds</span></span><br><span class="line"><span class="comment"> * to the page-aligned size in bytes that needs to be reserved in the</span></span><br><span class="line"><span class="comment"> * process&#x27; address space. If there are no loadable segments, 0 is</span></span><br><span class="line"><span class="comment"> * returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If out_min_vaddr or out_max_vaddr are not null, they will be</span></span><br><span class="line"><span class="comment"> * set to the minimum and maximum addresses of pages to be reserved,</span></span><br><span class="line"><span class="comment"> * or 0 if there is nothing to load.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">phdr_table_get_load_size</span><span class="params">(<span class="type">const</span> ElfW(Phdr)* phdr_table, <span class="type">size_t</span> phdr_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ElfW(Addr)* out_min_vaddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ElfW(Addr)* out_max_vaddr)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) min_vaddr = UINTPTR_MAX;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) max_vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> found_pt_load = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_count; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    found_pt_load = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_vaddr &lt; min_vaddr) &#123;</span><br><span class="line">      min_vaddr = phdr-&gt;p_vaddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_vaddr + phdr-&gt;p_memsz &gt; max_vaddr) &#123;</span><br><span class="line">      max_vaddr = phdr-&gt;p_vaddr + phdr-&gt;p_memsz;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!found_pt_load) &#123;</span><br><span class="line">    min_vaddr = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 需要的内存页起始位置</span></span><br><span class="line">  min_vaddr = <span class="built_in">page_start</span>(min_vaddr);</span><br><span class="line"><span class="comment">// 需要的内存页结束位置</span></span><br><span class="line">  max_vaddr = <span class="built_in">page_end</span>(max_vaddr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (out_min_vaddr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *out_min_vaddr = min_vaddr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (out_max_vaddr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *out_max_vaddr = max_vaddr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max_vaddr - min_vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ELF可加载的段的大小，用mmap预留出一段虚拟地址，并返回内存的起始位置</span></span><br><span class="line"><span class="comment">// Reserve a virtual address range such that if it&#x27;s limits were extended to the next 2**align</span></span><br><span class="line"><span class="comment">// boundary, it would not overlap with any existing mappings.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ReserveWithAlignmentPadding</span><span class="params">(<span class="type">size_t</span> size, <span class="type">size_t</span> mapping_align, <span class="type">size_t</span> start_align,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">void</span>** out_gap_start, <span class="type">size_t</span>* out_gap_size)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> mmap_flags = MAP_PRIVATE | MAP_ANONYMOUS; <span class="comment">// 私有匿名内存</span></span><br><span class="line">  <span class="comment">// Reserve enough space to properly align the library&#x27;s start address.</span></span><br><span class="line">  mapping_align = std::<span class="built_in">max</span>(mapping_align, start_align);</span><br><span class="line">  <span class="keyword">if</span> (mapping_align == <span class="built_in">page_size</span>()) &#123; <span class="comment">//  假设命中这里的条件，直接用mmap预留内存。内存权限为：PROT_NONE</span></span><br><span class="line">  <span class="comment">// 这里得到的地址是随机的，默认会受到 ASLR (Address Space Layout Randomization) 的影响。</span></span><br><span class="line">    <span class="type">void</span>* mmap_ptr = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, size, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmap_ptr == MAP_FAILED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 返回内存的起始位置。</span></span><br><span class="line">    <span class="keyword">return</span> mmap_ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Minimum alignment of shared library gap. For efficiency, this should match the second level</span></span><br><span class="line">  <span class="comment">// page size of the platform.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> kGapAlignment = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// Maximum gap size, in the units of kGapAlignment.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> kMaxGapUnits = <span class="number">32</span>;</span><br><span class="line">  <span class="comment">// Allocate enough space so that the end of the desired region aligned up is still inside the</span></span><br><span class="line">  <span class="comment">// mapping.</span></span><br><span class="line">  <span class="type">size_t</span> mmap_size = __builtin_align_up(size, mapping_align) + mapping_align - <span class="built_in">page_size</span>();</span><br><span class="line">  <span class="type">uint8_t</span>* mmap_ptr =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, mmap_size, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">  <span class="keyword">if</span> (mmap_ptr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">size_t</span> gap_size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> first_byte = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">size_t</span>&gt;(__builtin_align_up(mmap_ptr, mapping_align));</span><br><span class="line">  <span class="type">size_t</span> last_byte = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">size_t</span>&gt;(__builtin_align_down(mmap_ptr + mmap_size, mapping_align) - <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (first_byte / kGapAlignment != last_byte / kGapAlignment) &#123;</span><br><span class="line">    <span class="comment">// This library crosses a 2MB boundary and will fragment a new huge page.</span></span><br><span class="line">    <span class="comment">// Lets take advantage of that and insert a random number of inaccessible huge pages before that</span></span><br><span class="line">    <span class="comment">// to improve address randomization and make it harder to locate this library code by probing.</span></span><br><span class="line">    <span class="built_in">munmap</span>(mmap_ptr, mmap_size);</span><br><span class="line">    mapping_align = std::<span class="built_in">max</span>(mapping_align, kGapAlignment);</span><br><span class="line">    gap_size =</span><br><span class="line">        kGapAlignment * (<span class="built_in">is_first_stage_init</span>() ? <span class="number">1</span> : <span class="built_in">arc4random_uniform</span>(kMaxGapUnits - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    mmap_size = __builtin_align_up(size + gap_size, mapping_align) + mapping_align - <span class="built_in">page_size</span>();</span><br><span class="line">    mmap_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, mmap_size, PROT_NONE, mmap_flags, <span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mmap_ptr == MAP_FAILED) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* gap_end = mmap_ptr + mmap_size;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (gap_size) &#123;</span><br><span class="line">    gap_end = __builtin_align_down(gap_end, kGapAlignment);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">uint8_t</span>* gap_start = gap_end - gap_size;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* first = __builtin_align_up(mmap_ptr, mapping_align);</span><br><span class="line">  <span class="type">uint8_t</span>* last = __builtin_align_down(gap_start, mapping_align) - size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arc4random* is not available in first stage init because /dev/urandom hasn&#x27;t yet been</span></span><br><span class="line">  <span class="comment">// created. Don&#x27;t randomize then.</span></span><br><span class="line">  <span class="type">size_t</span> n = <span class="built_in">is_first_stage_init</span>() ? <span class="number">0</span> : <span class="built_in">arc4random_uniform</span>((last - first) / start_align + <span class="number">1</span>);</span><br><span class="line">  <span class="type">uint8_t</span>* start = first + n * start_align;</span><br><span class="line">  <span class="comment">// Unmap the extra space around the allocation.</span></span><br><span class="line">  <span class="comment">// Keep it mapped PROT_NONE on 64-bit targets where address space is plentiful to make it harder</span></span><br><span class="line">  <span class="comment">// to defeat ASLR by probing for readable memory mappings.</span></span><br><span class="line">  <span class="built_in">munmap</span>(mmap_ptr, start - mmap_ptr);</span><br><span class="line">  <span class="built_in">munmap</span>(start + size, gap_start - (start + size));</span><br><span class="line">  <span class="keyword">if</span> (gap_end != mmap_ptr + mmap_size) &#123;</span><br><span class="line">    <span class="built_in">munmap</span>(gap_end, mmap_ptr + mmap_size - gap_end);</span><br><span class="line">  &#125;</span><br><span class="line">  *out_gap_start = gap_start;</span><br><span class="line">  *out_gap_size = gap_size;</span><br><span class="line">  <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载Segments</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::LoadSegments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The compat(legacy) page size (4096) must be used when aligning</span></span><br><span class="line">  <span class="comment">// the 4KiB segments for loading in compat mode. The larger 16KiB page size</span></span><br><span class="line">  <span class="comment">// will lead to overwriting adjacent segments since the ELF&#x27;s segment(s)</span></span><br><span class="line">  <span class="comment">// are not 16KiB aligned.</span></span><br><span class="line">  <span class="type">size_t</span> seg_align = should_use_16kib_app_compat_ ? kCompatPageSize : kPageSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Only enforce this on 16 KB systems with app compat disabled.</span></span><br><span class="line">  <span class="comment">// Apps may rely on undefined behavior here on 4 KB systems,</span></span><br><span class="line">  <span class="comment">// which is the norm before this change is introduced</span></span><br><span class="line">  <span class="keyword">if</span> (kPageSize &gt;= <span class="number">16384</span> &amp;&amp; min_align_ &lt; kPageSize &amp;&amp; !should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR_AND_LOG</span>(<span class="string">&quot;\&quot;%s\&quot; program alignment (%zu) cannot be smaller than system page size (%zu)&quot;</span>,</span><br><span class="line">                   name_.<span class="built_in">c_str</span>(), min_align_, kPageSize);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Setup16KiBAppCompat</span>()) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; failed to setup 16KiB App Compat&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 遍历所有的段头，phdrs、shdrs、strtab、dynamic在BFS遍历find_library的时候已经映射到了内存。</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; phdr_num_; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读取loadable segments</span></span><br><span class="line">    <span class="keyword">if</span> (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取文件偏移和需要的虚拟内存地址</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) p_memsz = phdr-&gt;p_memsz;</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) p_filesz = phdr-&gt;p_filesz;</span><br><span class="line">    _extend_load_segment_vma(phdr_table_, phdr_num_, i, &amp;p_memsz, &amp;p_filesz, should_pad_segments_,</span><br><span class="line">                             should_use_16kib_app_compat_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加load_bias, 即将相对地址变为绝对地址</span></span><br><span class="line"><span class="comment">// 前面已经用mmap预留了内存，这里根据phdr中的内存相对地址+load_bias_即即可得到该段应该放到内存的什么区域。</span></span><br><span class="line">    <span class="comment">// Segment addresses in memory.</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_start = phdr-&gt;p_vaddr + load_bias_;</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_end = seg_start + p_memsz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按页向上对齐</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_page_end = __builtin_align_up(seg_end, seg_align);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) seg_file_end = seg_start + p_filesz;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到该段的文件偏移和大小信息</span></span><br><span class="line">    <span class="comment">// File offsets.</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_start = phdr-&gt;p_offset;</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_end = file_start + p_filesz;</span><br><span class="line"><span class="comment">// 按页向下对齐</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_page_start = __builtin_align_down(file_start, seg_align);</span><br><span class="line">    <span class="built_in">ElfW</span>(Addr) file_length = file_end - file_page_start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_size_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; invalid file size: %&quot;</span> PRId64, name_.<span class="built_in">c_str</span>(), file_size_);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_start + phdr-&gt;p_filesz &gt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(file_size_)) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid ELF file \&quot;%s\&quot; load segment[%zd]:&quot;</span></span><br><span class="line">          <span class="string">&quot; p_offset (%p) + p_filesz (%p) ( = %p) past end of file (0x%&quot;</span> PRIx64 <span class="string">&quot;)&quot;</span>,</span><br><span class="line">          name_.<span class="built_in">c_str</span>(), i, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(phdr-&gt;p_offset),</span><br><span class="line">          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(phdr-&gt;p_filesz),</span><br><span class="line">          <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(file_start + phdr-&gt;p_filesz), file_size_);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file_length != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据段信息中描述的权限信息，写内存页的权限</span></span><br><span class="line">      <span class="type">int</span> prot = <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags);</span><br><span class="line">      <span class="keyword">if</span> ((prot &amp; (PROT_EXEC | PROT_WRITE)) == (PROT_EXEC | PROT_WRITE)) &#123;</span><br><span class="line">        <span class="comment">// target 26后, load segemnts不能同时可写、可执行。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">26</span>, <span class="string">&quot;\&quot;%s\&quot; has load segments that are both writable and executable&quot;</span>,</span><br><span class="line">                           name_.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add_dlwarning</span>(name_.<span class="built_in">c_str</span>(), <span class="string">&quot;W+E load segments&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Pass the file_length, since it may have been extended by _extend_load_segment_vma().</span></span><br><span class="line">      <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">CompatMapSegment</span>(i, file_length)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将对应的段往指定的位置上映射</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">MapSegment</span>(i, file_length)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// pagesize是4k的情况下，内存映射是有些冗余的，将冗余的内存清零</span></span><br><span class="line">    <span class="built_in">ZeroFillSegment</span>(phdr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DropPaddingPages</span>(phdr, seg_file_end);</span><br><span class="line"><span class="comment">// 为bss节分配内存</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">MapBssSection</span>(phdr, seg_page_end, seg_file_end)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Segment对应的文件内容往指对应phdr指定的内存地址上进行映射</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::MapSegment</span><span class="params">(<span class="type">size_t</span> seg_idx, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>* phdr </span>= &amp;phdr_table_[seg_idx];</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* start = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="built_in">page_start</span>(phdr-&gt;p_vaddr + load_bias_));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The ELF could be being loaded directly from a zipped APK,</span></span><br><span class="line">  <span class="comment">// the zip offset must be added to find the segment offset.</span></span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> offset </span>= file_offset_ + <span class="built_in">page_start</span>(phdr-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> prot = <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里将对应的段，映射到指定的内存上, MAP_FIXED 为固定内存映射</span></span><br><span class="line">  <span class="type">void</span>* seg_addr = <span class="built_in">mmap64</span>(start, len, prot, MAP_FIXED | MAP_PRIVATE, fd_, offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (seg_addr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t map \&quot;%s\&quot; segment %zd: %m&quot;</span>, name_.<span class="built_in">c_str</span>(), seg_idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark segments as huge page eligible if they meet the requirements</span></span><br><span class="line">  <span class="keyword">if</span> ((phdr-&gt;p_flags &amp; PF_X) &amp;&amp; phdr-&gt;p_align == kPmdSize &amp;&amp;</span><br><span class="line">      <span class="built_in">get_transparent_hugepages_supported</span>()) &#123;</span><br><span class="line">    <span class="built_in">madvise</span>(seg_addr, len, MADV_HUGEPAGE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为bss节分配内存</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ElfReader::MapBssSection</span><span class="params">(<span class="type">const</span> ElfW(Phdr)* phdr, ElfW(Addr) seg_page_end,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ElfW(Addr) seg_file_end)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> We do not need to handle .bss in 16KiB compat mode since the mapping</span></span><br><span class="line">  <span class="comment">// reservation is anonymous and RW to begin with.</span></span><br><span class="line">  <span class="keyword">if</span> (should_use_16kib_app_compat_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// seg_file_end is now the first page address after the file content.</span></span><br><span class="line">  seg_file_end = <span class="built_in">page_end</span>(seg_file_end);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (seg_page_end &lt;= seg_file_end) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If seg_page_end is larger than seg_file_end, we need to zero</span></span><br><span class="line">  <span class="comment">// anything between them. This is done by using a private anonymous</span></span><br><span class="line">  <span class="comment">// map for all extra pages</span></span><br><span class="line">  <span class="type">size_t</span> zeromap_size = seg_page_end - seg_file_end;</span><br><span class="line">  <span class="type">void</span>* zeromap =</span><br><span class="line">      <span class="built_in">mmap</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(seg_file_end), zeromap_size, <span class="built_in">PFLAGS_TO_PROT</span>(phdr-&gt;p_flags),</span><br><span class="line">           MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (zeromap == MAP_FAILED) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;couldn&#x27;t map .bss section for \&quot;%s\&quot;: %m&quot;</span>, name_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the VMA name using prctl</span></span><br><span class="line">  <span class="built_in">prctl</span>(PR_SET_VMA, PR_SET_VMA_ANON_NAME, zeromap, zeromap_size, <span class="string">&quot;.bss&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三预链接">三、预链接</h1>
<p>这里读取dynamic中的信息将符号表信息、重定位（rela）节、构造器、hash节、字符串节等信息的地址提前计算出来记录到soinfo中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An empty list of soinfos</span></span><br><span class="line"><span class="type">static</span> <span class="type">soinfo_list_t</span> g_empty_list;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::prelink_image</span><span class="params">(<span class="type">bool</span> dlext_use_relro)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flags_ &amp; FLAG_PRELINKED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">/* Extract dynamic section */</span></span><br><span class="line">  <span class="built_in">ElfW</span>(Word) dynamic_flags = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取PT_DYNAMIC段的地址和flags</span></span><br><span class="line">  <span class="comment">// PT_DYNAMIC：描述的是 .dynamic 段的信息，本身通常也位于 某个 PT_LOAD segment 里面。</span></span><br><span class="line">  <span class="built_in">phdr_table_get_dynamic_section</span>(phdr, phnum, load_bias, &amp;dynamic, &amp;dynamic_flags);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__arm__)</span></span><br><span class="line">  (<span class="type">void</span>) <span class="built_in">phdr_table_get_arm_exidx</span>(phdr, phnum, load_bias,</span><br><span class="line">                                  &amp;ARM_exidx, &amp;ARM_exidx_count);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  TlsSegment tls_segment;</span><br><span class="line">  <span class="keyword">if</span> (__bionic_get_tls_segment(phdr, phnum, load_bias, &amp;tls_segment)) &#123;</span><br><span class="line">    <span class="comment">// The loader does not (currently) support ELF TLS, so it shouldn&#x27;t have</span></span><br><span class="line">    <span class="comment">// a TLS segment.</span></span><br><span class="line">    <span class="built_in">CHECK</span>(!relocating_linker &amp;&amp; <span class="string">&quot;TLS not supported in loader&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!__bionic_check_tls_align(tls_segment.aligned_size.align.value)) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;TLS segment alignment in \&quot;%s\&quot; is not a power of 2: %zu&quot;</span>, <span class="built_in">get_realpath</span>(),</span><br><span class="line">             tls_segment.aligned_size.align.value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tls_ = std::<span class="built_in">make_unique</span>&lt;soinfo_tls&gt;();</span><br><span class="line">    tls_-&gt;segment = tls_segment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取dynamic中的所有section信息</span></span><br><span class="line">  <span class="comment">// Extract useful information from dynamic section.</span></span><br><span class="line">  <span class="comment">// Note that: &quot;Except for the DT_NULL element at the end of the array,</span></span><br><span class="line">  <span class="comment">// and the relative order of DT_NEEDED elements, entries may appear in any order.&quot;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// source: http://www.sco.com/developers/gabi/1998-04-29/ch5.dynamic.html</span></span><br><span class="line">  <span class="type">uint32_t</span> needed_count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">ElfW</span>(Dyn)* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;dynamic entry @%p: d_tag=%p, d_val=%p&quot;</span>,</span><br><span class="line">             d, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_tag), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_un.d_val));</span><br><span class="line">    <span class="keyword">switch</span> (d-&gt;d_tag) &#123;</span><br><span class="line">      <span class="keyword">case</span> DT_SONAME: </span><br><span class="line">        <span class="comment">// this is parsed after we have strtab initialized (see below).</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取DT_HASH表信息</span></span><br><span class="line">      <span class="keyword">case</span> DT_HASH:</span><br><span class="line">        nbucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">0</span>];</span><br><span class="line">        nchain_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">1</span>];</span><br><span class="line">        bucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="number">8</span>);</span><br><span class="line">        chain_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="number">8</span> + nbucket_ * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_GNU_HASH:</span><br><span class="line">        gnu_nbucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// skip symndx</span></span><br><span class="line">        gnu_maskwords_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">2</span>];</span><br><span class="line">        gnu_shift2_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        gnu_bloom_filter_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(load_bias + d-&gt;d_un.d_ptr + <span class="number">16</span>);</span><br><span class="line">        gnu_bucket_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(gnu_bloom_filter_ + gnu_maskwords_);</span><br><span class="line">        <span class="comment">// amend chain for symndx = header[1]</span></span><br><span class="line">        gnu_chain_ = gnu_bucket_ + gnu_nbucket_ -</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint32_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">powerof2</span>(gnu_maskwords_)) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid maskwords for gnu_hash = 0x%x, in \&quot;%s\&quot; expecting power to two&quot;</span>,</span><br><span class="line">              gnu_maskwords_, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        --gnu_maskwords_;</span><br><span class="line"></span><br><span class="line">        flags_ |= FLAG_GNU_HASH;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取字符串表信息</span></span><br><span class="line">      <span class="keyword">case</span> DT_STRTAB:</span><br><span class="line">        strtab_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_STRSZ:</span><br><span class="line">        strtab_size_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取符号表</span></span><br><span class="line">      <span class="keyword">case</span> DT_SYMTAB:</span><br><span class="line">        symtab_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Sym)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_SYMENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Sym))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_SYMENT: %zd in \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">              <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val), <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 重定位表</span></span><br><span class="line">      <span class="keyword">case</span> DT_PLTREL:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != DT_RELA) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_RELA&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != DT_REL) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_PLTREL in \&quot;%s\&quot;; expected DT_REL&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_JMPREL:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">        plt_rela_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rela)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        plt_rel_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rel)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_PLTRELSZ:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">        plt_rela_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rela));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        plt_rel_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rel));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// PLTGOT表，直接忽略了... Andorid不支持</span></span><br><span class="line">      <span class="keyword">case</span> DT_PLTGOT:</span><br><span class="line">        <span class="comment">// Ignored (because RTLD_LAZY is not supported).</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_DEBUG:</span><br><span class="line">        <span class="comment">// Set the DT_DEBUG entry to the address of _r_debug for GDB</span></span><br><span class="line">        <span class="comment">// if the dynamic table is writable</span></span><br><span class="line">        <span class="keyword">if</span> ((dynamic_flags &amp; PF_W) != <span class="number">0</span>) &#123;</span><br><span class="line">          d-&gt;d_un.d_val = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;_r_debug);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line">      <span class="keyword">case</span> DT_RELA:</span><br><span class="line">        rela_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rela)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELASZ:</span><br><span class="line">        rela_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rela));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELA:</span><br><span class="line">        android_relocs_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELASZ:</span><br><span class="line">        android_relocs_size_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_REL:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_REL in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELSZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_RELSZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELAENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rela))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_RELAENT: %zd&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ignored (see DT_RELCOUNT comments for details).</span></span><br><span class="line">      <span class="keyword">case</span> DT_RELACOUNT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_REL:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_REL in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELSZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_RELSZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">case</span> DT_REL:</span><br><span class="line">        rel_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Rel)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELSZ:</span><br><span class="line">        rel_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rel));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Rel))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_RELENT: %zd&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_REL:</span><br><span class="line">        android_relocs_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELSZ:</span><br><span class="line">        android_relocs_size_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELA:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_RELA in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELASZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_ANDROID_RELASZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// &quot;Indicates that all RELATIVE relocations have been concatenated together,</span></span><br><span class="line">      <span class="comment">// and specifies the RELATIVE relocation count.&quot;</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Spec also mentions that this can be used to optimize relocation process;</span></span><br><span class="line">      <span class="comment">// Not currently used by bionic linker - ignored.</span></span><br><span class="line">      <span class="keyword">case</span> DT_RELCOUNT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELA:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_RELA in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELASZ:</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unsupported DT_RELASZ in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">case</span> DT_RELR:</span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELR:</span><br><span class="line">        relr_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Relr)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELRSZ:</span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELRSZ:</span><br><span class="line">        relr_count_ = d-&gt;d_un.d_val / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Relr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RELRENT:</span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELRENT:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val != <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Relr))) &#123;</span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;invalid DT_RELRENT: %zd&quot;</span>, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ignored (see DT_RELCOUNT comments for details).</span></span><br><span class="line">      <span class="comment">// There is no DT_RELRCOUNT specifically because it would only be ignored.</span></span><br><span class="line">      <span class="keyword">case</span> DT_ANDROID_RELRCOUNT:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取init_func_</span></span><br><span class="line">      <span class="keyword">case</span> DT_INIT:</span><br><span class="line">        init_func_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_ctor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s constructors (DT_INIT) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), init_func_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取fini_func_</span></span><br><span class="line">      <span class="keyword">case</span> DT_FINI:</span><br><span class="line">        fini_func_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_dtor_function_t</span>&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s destructors (DT_FINI) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), fini_func_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 获取init_array_的地址信息</span></span><br><span class="line">      <span class="keyword">case</span> DT_INIT_ARRAY:</span><br><span class="line">        init_array_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s constructors (DT_INIT_ARRAY) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), init_array_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_INIT_ARRAYSZ:</span><br><span class="line">        init_array_count_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FINI_ARRAY:</span><br><span class="line">        fini_array_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_dtor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s destructors (DT_FINI_ARRAY) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), fini_array_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FINI_ARRAYSZ:</span><br><span class="line">        fini_array_count_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_PREINIT_ARRAY:</span><br><span class="line">        preinit_array_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">linker_ctor_function_t</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;%s constructors (DT_PREINIT_ARRAY) found at %p&quot;</span>, <span class="built_in">get_realpath</span>(), preinit_array_);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_PREINIT_ARRAYSZ:</span><br><span class="line">        preinit_array_count_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(d-&gt;d_un.d_val) / <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_TEXTREL:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        has_text_relocations = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_SYMBOLIC:</span><br><span class="line">        has_DT_SYMBOLIC = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_NEEDED:</span><br><span class="line">        ++needed_count;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FLAGS:</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val &amp; DF_TEXTREL) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">          <span class="built_in">DL_ERR</span>(<span class="string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">          has_text_relocations = <span class="literal">true</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;d_un.d_val &amp; DF_SYMBOLIC) &#123;</span><br><span class="line">          has_DT_SYMBOLIC = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_FLAGS_1:</span><br><span class="line">        <span class="built_in">set_dt_flags_1</span>(d-&gt;d_un.d_val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((d-&gt;d_un.d_val &amp; ~SUPPORTED_DT_FLAGS_1) != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">DL_WARN</span>(<span class="string">&quot;Warning: \&quot;%s\&quot; has unsupported flags DT_FLAGS_1=%p &quot;</span></span><br><span class="line">                  <span class="string">&quot;(ignoring unsupported flags)&quot;</span>,</span><br><span class="line">                  <span class="built_in">get_realpath</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_un.d_val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Ignored: &quot;Its use has been superseded by the DF_BIND_NOW flag&quot;</span></span><br><span class="line">      <span class="keyword">case</span> DT_BIND_NOW:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERSYM:</span><br><span class="line">        versym_ = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Versym)*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERDEF:</span><br><span class="line">        verdef_ptr_ = load_bias + d-&gt;d_un.d_ptr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_VERDEFNUM:</span><br><span class="line">        verdef_cnt_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERNEED:</span><br><span class="line">        verneed_ptr_ = load_bias + d-&gt;d_un.d_ptr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_VERNEEDNUM:</span><br><span class="line">        verneed_cnt_ = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_RUNPATH:</span><br><span class="line">        <span class="comment">// this is parsed after we have strtab initialized (see below).</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> DT_TLSDESC_GOT:</span><br><span class="line">      <span class="keyword">case</span> DT_TLSDESC_PLT:</span><br><span class="line">        <span class="comment">// These DT entries are used for lazy TLSDESC relocations. Bionic</span></span><br><span class="line">        <span class="comment">// resolves everything eagerly, so these can be ignored.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__)</span></span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_BTI_PLT:</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_PAC_PLT:</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_VARIANT_PCS:</span><br><span class="line">        <span class="comment">// Ignored: AArch64 processor-specific dynamic array tags.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_MODE:</span><br><span class="line">        memtag_dynamic_entries_.has_memtag_mode = <span class="literal">true</span>;</span><br><span class="line">        memtag_dynamic_entries_.memtag_mode = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_HEAP:</span><br><span class="line">        memtag_dynamic_entries_.memtag_heap = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// The AArch64 MemtagABI originally erroneously defined</span></span><br><span class="line">      <span class="comment">// DT_AARCH64_MEMTAG_STACK as `d_ptr`, which is why the dynamic tag value</span></span><br><span class="line">      <span class="comment">// is odd (`0x7000000c`). `d_val` is clearly the correct semantics, and so</span></span><br><span class="line">      <span class="comment">// this was fixed in the ABI, but the value (0x7000000c) didn&#x27;t change</span></span><br><span class="line">      <span class="comment">// because we already had Android binaries floating around with dynamic</span></span><br><span class="line">      <span class="comment">// entries, and didn&#x27;t want to create a whole new dynamic entry and</span></span><br><span class="line">      <span class="comment">// reserve a value just to fix that tiny mistake. P.S. lld was always</span></span><br><span class="line">      <span class="comment">// outputting DT_AARCH64_MEMTAG_STACK as `d_val` anyway.</span></span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_STACK:</span><br><span class="line">        memtag_dynamic_entries_.memtag_stack = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// Same as above, except DT_AARCH64_MEMTAG_GLOBALS was incorrectly defined</span></span><br><span class="line">      <span class="comment">// as `d_val` (hence an even value of `0x7000000d`), when it should have</span></span><br><span class="line">      <span class="comment">// been `d_ptr` all along. lld has always outputted this as `d_ptr`.</span></span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_GLOBALS:</span><br><span class="line">        memtag_dynamic_entries_.memtag_globals = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(load_bias + d-&gt;d_un.d_ptr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> DT_AARCH64_MEMTAG_GLOBALSSZ:</span><br><span class="line">        memtag_dynamic_entries_.memtag_globalssz = d-&gt;d_un.d_val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (!relocating_linker) &#123;</span><br><span class="line">          <span class="type">const</span> <span class="type">char</span>* tag_name;</span><br><span class="line">          <span class="keyword">if</span> (d-&gt;d_tag == DT_RPATH) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;DT_RPATH&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;d_tag == DT_ENCODING) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;DT_ENCODING&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;d_tag &gt;= DT_LOOS &amp;&amp; d-&gt;d_tag &lt;= DT_HIOS) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;unknown OS-specific&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;d_tag &gt;= DT_LOPROC &amp;&amp; d-&gt;d_tag &lt;= DT_HIPROC) &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;unknown processor-specific&quot;</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tag_name = <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">DL_WARN</span>(<span class="string">&quot;Warning: \&quot;%s\&quot; unused DT entry: %s (type %p arg %p) (ignoring)&quot;</span>,</span><br><span class="line">                  <span class="built_in">get_realpath</span>(),</span><br><span class="line">                  tag_name,</span><br><span class="line">                  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_tag),</span><br><span class="line">                  <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(d-&gt;d_un.d_val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(dynamic, <span class="string">&quot;si-&gt;base = %p, si-&gt;strtab = %p, si-&gt;symtab = %p&quot;</span>,</span><br><span class="line">           <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base), strtab_, symtab_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validity checks.</span></span><br><span class="line">  <span class="keyword">if</span> (relocating_linker &amp;&amp; needed_count != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;linker cannot have DT_NEEDED dependencies on other libraries&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nbucket_ == <span class="number">0</span> &amp;&amp; gnu_nbucket_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;empty/missing DT_HASH/DT_GNU_HASH in \&quot;%s\&quot; &quot;</span></span><br><span class="line">        <span class="string">&quot;(new hash type from the future?)&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (strtab_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;empty/missing DT_STRTAB in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (symtab_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">DL_ERR</span>(<span class="string">&quot;empty/missing DT_SYMTAB in \&quot;%s\&quot;&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Second pass - parse entries relying on strtab. Skip this while relocating the linker so as to</span></span><br><span class="line">  <span class="comment">// avoid doing heap allocations until later in the linker&#x27;s initialization.</span></span><br><span class="line">  <span class="keyword">if</span> (!relocating_linker) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">ElfW</span>(Dyn)* d = dynamic; d-&gt;d_tag != DT_NULL; ++d) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (d-&gt;d_tag) &#123;</span><br><span class="line">        <span class="keyword">case</span> DT_SONAME:</span><br><span class="line">          <span class="built_in">set_soname</span>(<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DT_RUNPATH:</span><br><span class="line">          <span class="built_in">set_dt_runpath</span>(<span class="built_in">get_string</span>(d-&gt;d_un.d_val));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before API 23, the linker used the basename in place of DT_SONAME.</span></span><br><span class="line">  <span class="comment">// After we switched, apps with libraries without a DT_SONAME stopped working:</span></span><br><span class="line">  <span class="comment">// they could no longer be found by DT_NEEDED from another library.</span></span><br><span class="line">  <span class="comment">// The main executable does not need to have a DT_SONAME.</span></span><br><span class="line">  <span class="comment">// The linker has a DT_SONAME, but the soname_ field is initialized later on.</span></span><br><span class="line">  <span class="keyword">if</span> (soname_.<span class="built_in">empty</span>() &amp;&amp; <span class="keyword">this</span> != <span class="built_in">solist_get_somain</span>() &amp;&amp; !relocating_linker &amp;&amp;</span><br><span class="line">      <span class="built_in">get_application_target_sdk_version</span>() &lt; <span class="number">23</span>) &#123;</span><br><span class="line">    soname_ = <span class="built_in">basename</span>(realpath_.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// The `if` above means we don&#x27;t get here for targetSdkVersion &gt;= 23,</span></span><br><span class="line">    <span class="comment">// so no need to check the return value of DL_ERROR_AFTER().</span></span><br><span class="line">    <span class="comment">// We still call it rather than DL_WARN() to get the extra clarification.</span></span><br><span class="line">    <span class="built_in">DL_ERROR_AFTER</span>(<span class="number">23</span>, <span class="string">&quot;\&quot;%s\&quot; has no DT_SONAME (will use %s instead)&quot;</span>,</span><br><span class="line">                   <span class="built_in">get_realpath</span>(), soname_.<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Validate each library&#x27;s verdef section once, so we don&#x27;t have to validate</span></span><br><span class="line">  <span class="comment">// it each time we look up a symbol with a version.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">validate_verdef_section</span>(<span class="keyword">this</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// MTE globals requires remapping data segments with PROT_MTE as anonymous mappings, because file</span></span><br><span class="line">  <span class="comment">// based mappings may not be backed by tag-capable memory (see &quot;MAP_ANONYMOUS&quot; on</span></span><br><span class="line">  <span class="comment">// https://www.kernel.org/doc/html/latest/arch/arm64/memory-tagging-extension.html). This is only</span></span><br><span class="line">  <span class="comment">// done if the binary has MTE globals (evidenced by the dynamic table entries), as it destroys</span></span><br><span class="line">  <span class="comment">// page sharing. It&#x27;s also only done on devices that support MTE, because the act of remapping</span></span><br><span class="line">  <span class="comment">// pages is unnecessary on non-MTE devices (where we might still run MTE-globals enabled code).</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">should_tag_memtag_globals</span>() &amp;&amp;</span><br><span class="line">      <span class="built_in">remap_memtag_globals_segments</span>(phdr, phnum, base) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">tag_globals</span>(dlext_use_relro);</span><br><span class="line">    <span class="built_in">protect_memtag_globals_ro_segments</span>(phdr, phnum, base);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flags_ |= FLAG_PRELINKED;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the address and size of the ELF file&#x27;s .dynamic section in memory,</span></span><br><span class="line"><span class="comment"> * or null if missing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input:</span></span><br><span class="line"><span class="comment"> *   phdr_table  -&gt; program header table</span></span><br><span class="line"><span class="comment"> *   phdr_count  -&gt; number of entries in tables</span></span><br><span class="line"><span class="comment"> *   load_bias   -&gt; load bias</span></span><br><span class="line"><span class="comment"> * Output:</span></span><br><span class="line"><span class="comment"> *   dynamic       -&gt; address of table in memory (null on failure).</span></span><br><span class="line"><span class="comment"> *   dynamic_flags -&gt; protection flags for section (unset on failure)</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> *   void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">phdr_table_get_dynamic_section</span><span class="params">(<span class="type">const</span> ElfW(Phdr)* phdr_table, <span class="type">size_t</span> phdr_count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ElfW(Addr) load_bias, ElfW(Dyn)** dynamic,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    ElfW(Word)* dynamic_flags)</span> </span>&#123;</span><br><span class="line">  *dynamic = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;phdr_count; ++i) &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Phdr)</span>&amp; phdr </span>= phdr_table[i];</span><br><span class="line">    <span class="keyword">if</span> (phdr.p_type == PT_DYNAMIC) &#123;</span><br><span class="line">      *dynamic = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Dyn)*&gt;(load_bias + phdr.p_vaddr);</span><br><span class="line">      <span class="keyword">if</span> (dynamic_flags) &#123;</span><br><span class="line">        *dynamic_flags = phdr.p_flags;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四链接">四、链接</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::link_image</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list, soinfo* local_group_root,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> android_dlextinfo* extinfo, <span class="type">size_t</span>* relro_fd_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_image_linked</span>()) &#123; <span class="comment">// 如果已经link了就返回</span></span><br><span class="line">    <span class="comment">// already linked.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (g_is_ldd &amp;&amp; !<span class="built_in">is_main_executable</span>()) &#123;</span><br><span class="line">    <span class="built_in">async_safe_format_fd</span>(STDOUT_FILENO, <span class="string">&quot;\t%s =&gt; %s (%p)\n&quot;</span>, <span class="built_in">get_soname</span>(),</span><br><span class="line">                         <span class="built_in">get_realpath</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  local_group_root_ = local_group_root;</span><br><span class="line">  <span class="keyword">if</span> (local_group_root_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    local_group_root_ = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((flags_ &amp; FLAG_LINKER) == <span class="number">0</span> &amp;&amp; local_group_root_ == <span class="keyword">this</span>) &#123;</span><br><span class="line">    target_sdk_version_ = <span class="built_in">get_application_target_sdk_version</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (has_text_relocations) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DL_ERROR_AFTER</span>(<span class="number">23</span>, <span class="string">&quot;\&quot;%s\&quot; has text relocations&quot;</span>, <span class="built_in">get_realpath</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add_dlwarning</span>(<span class="built_in">get_realpath</span>(), <span class="string">&quot;text relocations&quot;</span>);</span><br><span class="line">    <span class="comment">// Make segments writable to allow text relocations to work properly. We will later call</span></span><br><span class="line">    <span class="comment">// phdr_table_protect_segments() after all of them are applied.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_unprotect_segments</span>(phdr, phnum, load_bias, should_pad_segments_,</span><br><span class="line">                                      should_use_16kib_app_compat_) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t unprotect loadable segments for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定位</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != <span class="built_in">solist_get_vdso</span>() &amp;&amp; !<span class="built_in">relocate</span>(lookup_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">LD_DEBUG</span>(any, <span class="string">&quot;[ finished linking %s ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__LP64__)</span></span><br><span class="line">  <span class="keyword">if</span> (has_text_relocations) &#123;</span><br><span class="line">    <span class="comment">// All relocations are done, we can protect our segments back to read-only.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_protect_segments</span>(phdr, phnum, load_bias, should_pad_segments_,</span><br><span class="line">                                    should_use_16kib_app_compat_) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t protect segments for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can also turn on GNU RELRO protection if we&#x27;re not linking the dynamic linker</span></span><br><span class="line">  <span class="comment">// itself --- it can&#x27;t make system calls yet, and will have to call protect_relro later.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_linker</span>() &amp;&amp; !<span class="built_in">protect_relro</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">should_tag_memtag_globals</span>()) &#123;</span><br><span class="line">    std::list&lt;std::string&gt;* vma_names_ptr = <span class="built_in">vma_names</span>();</span><br><span class="line">    <span class="comment">// should_tag_memtag_globals -&gt; __aarch64__ -&gt; vma_names() != nullptr</span></span><br><span class="line">    <span class="built_in">CHECK</span>(vma_names_ptr);</span><br><span class="line">    <span class="built_in">name_memtag_globals_segments</span>(phdr, phnum, base, <span class="built_in">get_realpath</span>(), vma_names_ptr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Handle serializing/sharing the RELRO segment */</span></span><br><span class="line">  <span class="keyword">if</span> (extinfo &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_WRITE_RELRO)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_serialize_gnu_relro</span>(phdr, phnum, load_bias,</span><br><span class="line">                                       extinfo-&gt;relro_fd, relro_fd_offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;failed serializing GNU RELRO section for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (extinfo &amp;&amp; (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_RELRO)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_map_gnu_relro</span>(phdr, phnum, load_bias,</span><br><span class="line">                                 extinfo-&gt;relro_fd, relro_fd_offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;failed mapping GNU RELRO section for \&quot;%s\&quot;: %m&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++g_module_load_counter;</span><br><span class="line">  <span class="built_in">notify_gdb_of_load</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// 标记当前的so已经link了。</span></span><br><span class="line">  <span class="built_in">set_image_linked</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定位</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::relocate</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// For ldd, don&#x27;t apply relocations because TLS segments are not registered.</span></span><br><span class="line">  <span class="comment">// We don&#x27;t care whether ldd diagnoses unresolved symbols.</span></span><br><span class="line">  <span class="keyword">if</span> (g_is_ldd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在创建一个VersionTraker用来辅助符号的查找</span></span><br><span class="line">  VersionTracker version_tracker;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!version_tracker.<span class="built_in">init</span>(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个“重定位器”，将version_tracker和lookup_list传给它，它将负责符号的重定位</span></span><br><span class="line">  <span class="function">Relocator <span class="title">relocator</span><span class="params">(version_tracker, lookup_list)</span></span>;</span><br><span class="line">  relocator.si = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 给它设置字符表</span></span><br><span class="line">  relocator.si_strtab = strtab_;</span><br><span class="line">  relocator.si_strtab_size = <span class="built_in">is_lp64_or_has_min_version</span>(<span class="number">1</span>) ? strtab_size_ : SIZE_MAX;</span><br><span class="line">  <span class="comment">// 设置符号表</span></span><br><span class="line">  relocator.si_symtab = symtab_;</span><br><span class="line">  relocator.tlsdesc_args = &amp;tlsdesc_args_;</span><br><span class="line">  relocator.tls_tp_base = __libc_shared_globals()-&gt;static_tls_layout.<span class="built_in">offset_thread_pointer</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The linker already applied its RELR relocations in an earlier pass, so</span></span><br><span class="line">  <span class="comment">// skip the RELR relocations for the linker.</span></span><br><span class="line">  <span class="keyword">if</span> (relr_ != <span class="literal">nullptr</span> &amp;&amp; !<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s relr ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Relr)</span>* begin </span>= relr_;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Relr)</span>* end </span>= relr_ + relr_count_;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">relocate_relr</span>(begin, end, load_bias, <span class="built_in">should_tag_memtag_globals</span>())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (android_relocs_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// check signature</span></span><br><span class="line">    <span class="keyword">if</span> (android_relocs_size_ &gt; <span class="number">3</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">1</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">2</span>] == <span class="string">&#x27;S&#x27;</span> &amp;&amp;</span><br><span class="line">        android_relocs_[<span class="number">3</span>] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s android rel/rela ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="type">uint8_t</span>* packed_relocs = android_relocs_ + <span class="number">4</span>;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> packed_relocs_size = android_relocs_size_ - <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">packed_relocate</span>&lt;RelocMode::Typical&gt;(relocator, <span class="built_in">sleb128_decoder</span>(packed_relocs, packed_relocs_size))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;bad android relocation header.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line"><span class="comment">// 根据rela_表进行重定位</span></span><br><span class="line">  <span class="keyword">if</span> (rela_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s rela ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::Typical&gt;(relocator, rela_, rela_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (plt_rela_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s plt rela ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::JumpTable&gt;(relocator, plt_rela_, plt_rela_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">if</span> (rel_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s rel ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::Typical&gt;(relocator, rel_, rel_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (plt_rel_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">   <span class="built_in">LD_DEBUG</span>(reloc, <span class="string">&quot;[ relocating %s plt rel ]&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">plain_relocate</span>&lt;RelocMode::JumpTable&gt;(relocator, plt_rel_, plt_rel_count_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Once the tlsdesc_args_ vector&#x27;s size is finalized, we can write the addresses of its elements</span></span><br><span class="line">  <span class="comment">// into the TLSDESC relocations.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__) || defined(__riscv)</span></span><br><span class="line">  <span class="comment">// Bionic currently only implements TLSDESC for arm64 and riscv64.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> std::pair&lt;TlsDescriptor*, <span class="type">size_t</span>&gt;&amp; pair : relocator.deferred_tlsdesc_relocs) &#123;</span><br><span class="line">    TlsDescriptor* desc = pair.first;</span><br><span class="line">    desc-&gt;func = tlsdesc_resolver_dynamic;</span><br><span class="line">    desc-&gt;arg = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">size_t</span>&gt;(&amp;tlsdesc_args_[pair.second]);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// defined(__aarch64__) || defined(__riscv)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重定位">重定位</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode OptMode, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">plain_relocate</span><span class="params">(Relocator&amp; relocator, Args ...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">needs_slow_relocate_loop</span>(relocator) ?</span><br><span class="line">      <span class="built_in">plain_relocate_impl</span>&lt;RelocMode::General&gt;(relocator, args...) :</span><br><span class="line">      <span class="built_in">plain_relocate_impl</span>&lt;OptMode&gt;(relocator, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有rela项进行处理</span></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">plain_relocate_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">rel_t</span>* rels, <span class="type">size_t</span> rel_count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rel_count; ++i) &#123; <span class="comment">// for循环遍历所有重定位表项，进行重定位</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">process_relocation</span>&lt;Mode&gt;(relocator, rels[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理rel</span></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">process_relocation</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mode == RelocMode::General ?</span><br><span class="line">      <span class="built_in">process_relocation_general</span>(relocator, reloc) :</span><br><span class="line">      <span class="built_in">process_relocation_impl</span>&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rel_t就是ElfW(Rela)</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ElfW</span><span class="params">(Rela)</span> <span class="type">rel_t</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">ElfW</span><span class="params">(Rel)</span> <span class="type">rel_t</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_general</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">process_relocation_impl</span>&lt;RelocMode::General&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理该符号的重定位</span></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得符号信息中所指向的目标地址，例如指向GOT槽</span></span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> rel_target = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">      relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(reloc.r_offset + relocator.si-&gt;load_bias));</span><br><span class="line"><span class="comment">// 获得符号的type和sym, r_sym就是.dynsym表中的符号的索引    </span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_type = <span class="built_in">ELFW</span>(R_TYPE)(reloc.r_info);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_sym = <span class="built_in">ELFW</span>(R_SYM)(reloc.r_info);</span><br><span class="line"></span><br><span class="line">  soinfo* found_in = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* sym_name = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) sym_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (r_sym != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 利用r_sym找到.dynamic中的符号信息，并获得名称信息。（名称信息通过查字符表获取）</span></span><br><span class="line">    sym_name = relocator.<span class="built_in">get_string</span>(relocator.si_symtab[r_sym].st_name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While relocating a DSO with text relocations (obsolete and 32-bit only), the .text segment is</span></span><br><span class="line">  <span class="comment">// writable (but not executable). To call an ifunc, temporarily remap the segment as executable</span></span><br><span class="line">  <span class="comment">// (but not writable). Then switch it back to continue applying relocations in the segment.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__)</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> handle_text_relocs = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">auto</span> protect_segments = []() &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> unprotect_segments = []() &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> handle_text_relocs = IsGeneral &amp;&amp; relocator.si-&gt;has_text_relocations;</span><br><span class="line">  <span class="keyword">auto</span> protect_segments = [&amp;]() &#123;</span><br><span class="line">    <span class="comment">// Make .text executable.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_protect_segments</span>(relocator.si-&gt;phdr, relocator.si-&gt;phnum,</span><br><span class="line">                                    relocator.si-&gt;load_bias, relocator.si-&gt;<span class="built_in">should_pad_segments</span>(),</span><br><span class="line">                                    relocator.si-&gt;<span class="built_in">should_use_16kib_app_compat</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t protect segments for \&quot;%s\&quot;: %m&quot;</span>, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">auto</span> unprotect_segments = [&amp;]() &#123;</span><br><span class="line">    <span class="comment">// Make .text writable.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">phdr_table_unprotect_segments</span>(relocator.si-&gt;phdr, relocator.si-&gt;phnum,</span><br><span class="line">                                      relocator.si-&gt;load_bias, relocator.si-&gt;<span class="built_in">should_pad_segments</span>(),</span><br><span class="line">                                      relocator.si-&gt;<span class="built_in">should_use_16kib_app_compat</span>()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;can&#x27;t unprotect loadable segments for \&quot;%s\&quot;: %m&quot;</span>,</span><br><span class="line">             relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip symbol lookup for R_GENERIC_NONE relocations.</span></span><br><span class="line">  <span class="keyword">if</span> (__predict_false(r_type == R_GENERIC_NONE)) &#123;</span><br><span class="line">    <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO NONE&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(USE_RELA)</span></span><br><span class="line"><span class="comment">// 如果是rela，获取到r_addend信息</span></span><br><span class="line">  <span class="keyword">auto</span> get_addend_rel   = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> reloc.r_addend; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> get_addend_norel = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> reloc.r_addend; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">auto</span> get_addend_rel   = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target); &#125;;</span><br><span class="line">  <span class="keyword">auto</span> get_addend_norel = [&amp;]() -&gt; <span class="built_in">ElfW</span>(Addr) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!IsGeneral &amp;&amp; __predict_false(<span class="built_in">is_tls_reloc</span>(r_type))) &#123;</span><br><span class="line">    <span class="comment">// Always process TLS relocations using the slow code path, so that STB_LOCAL symbols are</span></span><br><span class="line">    <span class="comment">// diagnosed, and ifunc processing is skipped.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process_relocation_general</span>(relocator, reloc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IsGeneral &amp;&amp; <span class="built_in">is_tls_reloc</span>(r_type)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// By convention in ld.bfd and lld, an omitted symbol on a TLS relocation</span></span><br><span class="line">      <span class="comment">// is a reference to the current module.</span></span><br><span class="line">      found_in = relocator.si;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ELF_ST_BIND</span>(relocator.si_symtab[r_sym].st_info) == STB_LOCAL) &#123;</span><br><span class="line">      <span class="comment">// In certain situations, the Gold linker accesses a TLS symbol using a</span></span><br><span class="line">      <span class="comment">// relocation to an STB_LOCAL symbol in .dynsym of either STT_SECTION or</span></span><br><span class="line">      <span class="comment">// STT_TLS type. Bionic doesn&#x27;t support these relocations, so issue an</span></span><br><span class="line">      <span class="comment">// error. References:</span></span><br><span class="line">      <span class="comment">//  - https://groups.google.com/d/topic/generic-abi/dJ4_Y78aQ2M/discussion</span></span><br><span class="line">      <span class="comment">//  - https://sourceware.org/bugzilla/show_bug.cgi?id=17699</span></span><br><span class="line">      sym = &amp;relocator.si_symtab[r_sym];</span><br><span class="line">      <span class="keyword">auto</span> sym_type = <span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info);</span><br><span class="line">      <span class="keyword">if</span> (sym_type == STT_SECTION) &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;unexpected TLS reference to local section in \&quot;%s\&quot;: sym type %d, rel type %u&quot;</span>,</span><br><span class="line">               relocator.si-&gt;<span class="built_in">get_realpath</span>(), sym_type, r_type);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DL_ERR</span>(</span><br><span class="line">            <span class="string">&quot;unexpected TLS reference to local symbol \&quot;%s\&quot; in \&quot;%s\&quot;: sym type %d, rel type %u&quot;</span>,</span><br><span class="line">            sym_name, relocator.si-&gt;<span class="built_in">get_realpath</span>(), sym_type, r_type);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">lookup_symbol</span>&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (found_in != <span class="literal">nullptr</span> &amp;&amp; found_in-&gt;<span class="built_in">get_tls</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// sym_name can be nullptr if r_sym is 0. A linker should never output an ELF file like this.</span></span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;TLS relocation refers to symbol \&quot;%s\&quot; in solib \&quot;%s\&quot; with no TLS segment&quot;</span>,</span><br><span class="line">             sym_name, found_in-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info) != STT_TLS) &#123;</span><br><span class="line">        <span class="comment">// A toolchain should never output a relocation like this.</span></span><br><span class="line">        <span class="built_in">DL_ERR</span>(<span class="string">&quot;reference to non-TLS symbol \&quot;%s\&quot; from TLS relocation in \&quot;%s\&quot;&quot;</span>,</span><br><span class="line">               sym_name, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      sym_addr = sym-&gt;st_value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 查找符号        </span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">lookup_symbol</span>&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> should_protect_segments = handle_text_relocs &amp;&amp;</span><br><span class="line">                                             found_in == relocator.si &amp;&amp;</span><br><span class="line">                                             <span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info) == STT_GNU_IFUNC;</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !<span class="built_in">protect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 找到符号后，resolve出它的地址。</span></span><br><span class="line">        sym_addr = found_in-&gt;<span class="built_in">resolve_symbol_address</span>(sym);</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !<span class="built_in">unprotect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (IsGeneral) &#123;</span><br><span class="line">        <span class="comment">// A weak reference to an undefined symbol. We typically use a zero symbol address, but</span></span><br><span class="line">        <span class="comment">// use the relocation base for PC-relative relocations, so that the value written is zero.</span></span><br><span class="line">        <span class="keyword">switch</span> (r_type) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">          <span class="keyword">case</span> R_X86_64_PC32:</span><br><span class="line">            sym_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__i386__)</span></span><br><span class="line">          <span class="keyword">case</span> R_386_PC32:</span><br><span class="line">            sym_addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::JumpTable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_JUMP_SLOT) &#123; <span class="comment">// 如果是SLOT类型</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="comment">// 计算出符号对应的目标地址（如外部so中该符号的地址），并加上addend</span></span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_norel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO JMP_SLOT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">    <span class="comment">// 将根据符号找出的地址赋值给，符号表的target地址（如GOT槽）</span></span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::Typical)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Almost all dynamic relocations are of one of these types, and most will be</span></span><br><span class="line">    <span class="comment">// R_GENERIC_ABSOLUTE. The platform typically uses RELR instead, but R_GENERIC_RELATIVE is</span></span><br><span class="line">    <span class="comment">// common in non-platform binaries.</span></span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_ABSOLUTE) &#123; <span class="comment">// 如果时ABS类型，直接进行计算</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO ABSOLUTE %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_GLOB_DAT) &#123;</span><br><span class="line">      <span class="comment">// The i386 psABI specifies that R_386_GLOB_DAT doesn&#x27;t have an addend. The ARM ELF ABI</span></span><br><span class="line">      <span class="comment">// document (IHI0044F) specifies that R_ARM_GLOB_DAT has an addend, but Bionic isn&#x27;t adding</span></span><br><span class="line">      <span class="comment">// it.</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_norel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO GLOB_DAT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_RELATIVE) &#123;</span><br><span class="line">      <span class="comment">// In practice, r_sym is always zero, but if it weren&#x27;t, the linker would still look up the</span></span><br><span class="line">      <span class="comment">// referenced symbol (and abort if the symbol isn&#x27;t found), even though it isn&#x27;t used.</span></span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      <span class="built_in">ElfW</span>(Addr) result = relocator.si-&gt;load_bias + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">      <span class="comment">// MTE globals reuses the place bits for additional tag-derivation metadata for</span></span><br><span class="line">      <span class="comment">// R_AARCH64_RELATIVE relocations, which makes it incompatible with</span></span><br><span class="line">      <span class="comment">// `-Wl,--apply-dynamic-relocs`. This is enforced by lld, however there&#x27;s nothing stopping</span></span><br><span class="line">      <span class="comment">// Android binaries (particularly prebuilts) from building with this linker flag if they&#x27;re</span></span><br><span class="line">      <span class="comment">// not built with MTE globals. Thus, don&#x27;t use the new relocation semantics if this DSO</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t have MTE globals.</span></span><br><span class="line">      <span class="keyword">if</span> (relocator.si-&gt;<span class="built_in">should_tag_memtag_globals</span>()) &#123;</span><br><span class="line">        <span class="type">int64_t</span>* place = <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>*&gt;(rel_target);</span><br><span class="line">        <span class="type">int64_t</span> offset = *place;</span><br><span class="line">        result = relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(result + offset) - offset;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO RELATIVE %16p &lt;- %16p&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result));</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!IsGeneral)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Almost all relocations are handled above. Handle the remaining relocations below, in a</span></span><br><span class="line">    <span class="comment">// separate function call. The symbol lookup will be repeated, but the result should be served</span></span><br><span class="line">    <span class="comment">// from the 1-symbol lookup cache.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process_relocation_general</span>(relocator, reloc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_IRELATIVE:</span><br><span class="line">      <span class="comment">// In the linker, ifuncs are called as soon as possible so that string functions work. We must</span></span><br><span class="line">      <span class="comment">// not call them again. (e.g. On arm32, resolving an ifunc changes the meaning of the addend</span></span><br><span class="line">      <span class="comment">// from a resolver function to the implementation.)</span></span><br><span class="line">      <span class="keyword">if</span> (!relocator.si-&gt;<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">        <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> ifunc_addr </span>= relocator.si-&gt;load_bias + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO IRELATIVE %16p &lt;- %16p&quot;</span>,</span><br><span class="line">                 rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(ifunc_addr));</span><br><span class="line">        <span class="keyword">if</span> (handle_text_relocs &amp;&amp; !<span class="built_in">protect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= <span class="built_in">call_ifunc_resolver</span>(ifunc_addr);</span><br><span class="line">        <span class="keyword">if</span> (handle_text_relocs &amp;&amp; !<span class="built_in">unprotect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_COPY:</span><br><span class="line">      <span class="comment">// Copy relocations allow read-only data or code in a non-PIE executable to access a</span></span><br><span class="line">      <span class="comment">// variable from a DSO. The executable reserves extra space in its .bss section, and the</span></span><br><span class="line">      <span class="comment">// linker copies the variable into the extra space. The executable then exports its copy</span></span><br><span class="line">      <span class="comment">// to interpose the copy in the DSO.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Bionic only supports PIE executables, so copy relocations aren&#x27;t supported. The ARM and</span></span><br><span class="line">      <span class="comment">// AArch64 ABI documents only allow them for ET_EXEC (non-PIE) objects. See IHI0056B and</span></span><br><span class="line">      <span class="comment">// IHI0044F.</span></span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;%s COPY relocations are not supported&quot;</span>, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLS_TPREL:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ElfW</span>(Addr) tpoff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (found_in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="comment">// Unresolved weak relocation. Leave tpoff at 0 to resolve</span></span><br><span class="line">          <span class="comment">// &amp;weak_tls_symbol to __get_tls().</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CHECK</span>(found_in-&gt;<span class="built_in">get_tls</span>() != <span class="literal">nullptr</span>); <span class="comment">// We rejected a missing TLS segment above.</span></span><br><span class="line">          <span class="type">const</span> TlsModule&amp; mod = <span class="built_in">get_tls_module</span>(found_in-&gt;<span class="built_in">get_tls</span>()-&gt;module_id);</span><br><span class="line">          <span class="keyword">if</span> (mod.static_offset != SIZE_MAX) &#123;</span><br><span class="line">            tpoff += mod.static_offset - relocator.tls_tp_base;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">DL_ERR</span>(<span class="string">&quot;TLS symbol \&quot;%s\&quot; in dlopened \&quot;%s\&quot; referenced from \&quot;%s\&quot; using IE access model&quot;</span>,</span><br><span class="line">                   sym_name, found_in-&gt;<span class="built_in">get_realpath</span>(), relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tpoff += sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLS_TPREL %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">                 rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(tpoff), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = tpoff;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLS_DTPMOD:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">size_t</span> module_id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (found_in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="comment">// Unresolved weak relocation. Evaluate the module ID to 0.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CHECK</span>(found_in-&gt;<span class="built_in">get_tls</span>() != <span class="literal">nullptr</span>); <span class="comment">// We rejected a missing TLS segment above.</span></span><br><span class="line">          module_id = found_in-&gt;<span class="built_in">get_tls</span>()-&gt;module_id;</span><br><span class="line">          <span class="built_in">CHECK</span>(module_id != kTlsUninitializedModuleId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLS_DTPMOD %16p &lt;- %zu %s&quot;</span>,</span><br><span class="line">                 rel_target, module_id, sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = module_id;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLS_DTPREL:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_rel</span>() - TLS_DTV_OFFSET;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLS_DTPREL %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">                 rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__aarch64__) || defined(__riscv)</span></span><br><span class="line">    <span class="comment">// Bionic currently implements TLSDESC for arm64 and riscv64. This implementation should work</span></span><br><span class="line">    <span class="comment">// with other architectures, as long as the resolver functions are implemented.</span></span><br><span class="line">    <span class="keyword">case</span> R_GENERIC_TLSDESC:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">ElfW</span>(Addr) addend = reloc.r_addend;</span><br><span class="line">        TlsDescriptor* desc = <span class="built_in">static_cast</span>&lt;TlsDescriptor*&gt;(rel_target);</span><br><span class="line">        <span class="keyword">if</span> (found_in == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="comment">// Unresolved weak relocation.</span></span><br><span class="line">          desc-&gt;func = tlsdesc_resolver_unresolved_weak;</span><br><span class="line">          desc-&gt;arg = addend;</span><br><span class="line">          <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLSDESC %16p &lt;- unresolved weak, addend 0x%zx %s&quot;</span>,</span><br><span class="line">                   rel_target, <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(addend), sym_name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">CHECK</span>(found_in-&gt;<span class="built_in">get_tls</span>() != <span class="literal">nullptr</span>); <span class="comment">// We rejected a missing TLS segment above.</span></span><br><span class="line">          <span class="type">size_t</span> module_id = found_in-&gt;<span class="built_in">get_tls</span>()-&gt;module_id;</span><br><span class="line">          <span class="type">const</span> TlsModule&amp; mod = <span class="built_in">get_tls_module</span>(module_id);</span><br><span class="line">          <span class="keyword">if</span> (mod.static_offset != SIZE_MAX) &#123;</span><br><span class="line">            desc-&gt;func = tlsdesc_resolver_static;</span><br><span class="line">            desc-&gt;arg = mod.static_offset - relocator.tls_tp_base + sym_addr + addend;</span><br><span class="line">            <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLSDESC %16p &lt;- static (0x%zx - 0x%zx + 0x%zx + 0x%zx) %s&quot;</span>,</span><br><span class="line">                     rel_target, mod.static_offset, relocator.tls_tp_base,</span><br><span class="line">                     <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(sym_addr), <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(addend),</span><br><span class="line">                     sym_name);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            relocator.tlsdesc_args-&gt;<span class="built_in">push_back</span>(&#123;</span><br><span class="line">              .generation = mod.first_generation,</span><br><span class="line">              .index.module_id = module_id,</span><br><span class="line">              .index.offset = sym_addr + addend,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// Defer the TLSDESC relocation until the address of the TlsDynamicResolverArg object</span></span><br><span class="line">            <span class="comment">// is finalized.</span></span><br><span class="line">            relocator.deferred_tlsdesc_relocs.<span class="built_in">push_back</span>(&#123;</span><br><span class="line">              desc, relocator.tlsdesc_args-&gt;<span class="built_in">size</span>() - <span class="number">1</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">const</span> TlsDynamicResolverArg&amp; desc_arg = relocator.tlsdesc_args-&gt;<span class="built_in">back</span>();</span><br><span class="line">            <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO TLSDESC %16p &lt;- dynamic (gen %zu, mod %zu, off %zu) %s&quot;</span>,</span><br><span class="line">                     rel_target, desc_arg.generation, desc_arg.index.module_id,</span><br><span class="line">                     desc_arg.index.offset, sym_name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// defined(__aarch64__) || defined(__riscv)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__x86_64__)</span></span><br><span class="line">    <span class="keyword">case</span> R_X86_64_32:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">const</span> Elf32_Addr result = sym_addr + reloc.r_addend;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO R_X86_64_32 %16p &lt;- 0x%08x %s&quot;</span>,</span><br><span class="line">                 rel_target, result, sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;Elf32_Addr*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_X86_64_PC32:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> target </span>= sym_addr + reloc.r_addend;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> base </span>= <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">        <span class="type">const</span> Elf32_Addr result = target - base;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO R_X86_64_PC32 %16p &lt;- 0x%08x (%16p - %16p) %s&quot;</span>,</span><br><span class="line">                 rel_target, result, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(target),</span><br><span class="line">                 <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;Elf32_Addr*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(__i386__)</span></span><br><span class="line">    <span class="keyword">case</span> R_386_PC32:</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocRelative);</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> target </span>= sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> base </span>= <span class="built_in">reinterpret_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)&gt;(rel_target);</span><br><span class="line">        <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= target - base;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO R_386_PC32 %16p &lt;- 0x%08x (%16p - %16p) %s&quot;</span>,</span><br><span class="line">                 rel_target, result, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(target),</span><br><span class="line">                 <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(base), sym_name);</span><br><span class="line">        *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;unknown reloc type %d in \&quot;%s\&quot;&quot;</span>, r_type, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="符号查找">符号查找</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> DoLogging&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">lookup_symbol</span><span class="params">(Relocator&amp; relocator, <span class="type">uint32_t</span> r_sym, <span class="type">const</span> <span class="type">char</span>* sym_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 soinfo** found_in, <span class="type">const</span> ElfW(Sym)** sym)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 看看是否在cache中                                    </span></span><br><span class="line">  <span class="keyword">if</span> (r_sym == relocator.cache_sym_val) &#123;</span><br><span class="line">    *found_in = relocator.cache_si;</span><br><span class="line">    *sym = relocator.cache_sym;</span><br><span class="line">    <span class="built_in">count_relocation_if</span>&lt;DoLogging&gt;(kRelocSymbolCached);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果有版本信息的话，获取版本信息</span></span><br><span class="line">    <span class="type">const</span> version_info* vi = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!relocator.si-&gt;<span class="built_in">lookup_version_info</span>(relocator.version_tracker, r_sym, sym_name, &amp;vi)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的lib查找符号</span></span><br><span class="line">    soinfo* local_found_in = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* local_sym </span>= <span class="built_in">soinfo_do_lookup</span>(sym_name, vi, &amp;local_found_in, relocator.lookup_list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把找到的结果缓存一下，并将查找到的信息返回出去</span></span><br><span class="line">    relocator.cache_sym_val = r_sym;</span><br><span class="line">    relocator.cache_si = local_found_in;</span><br><span class="line">    relocator.cache_sym = local_sym;</span><br><span class="line">    *found_in = local_found_in;</span><br><span class="line">    *sym = local_sym;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (*sym == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果没有找到，并且符号类型不是弱符号则查找失败</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ELF_ST_BIND</span>(relocator.si_symtab[r_sym].st_info) != STB_WEAK) &#123;</span><br><span class="line">      <span class="built_in">DL_ERR</span>(<span class="string">&quot;cannot locate symbol \&quot;%s\&quot; referenced by \&quot;%s\&quot;...&quot;</span>, sym_name, relocator.si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">count_relocation_if</span>&lt;DoLogging&gt;(kRelocSymbol);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的soinfo,查找符号</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* <span class="title">soinfo_do_lookup</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> version_info* vi,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  soinfo** si_found_in, <span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> lookup_list.<span class="built_in">needs_slow_path</span>() ?</span><br><span class="line">      <span class="built_in">soinfo_do_lookup_impl</span>&lt;<span class="literal">true</span>&gt;(name, vi, si_found_in, lookup_list) :</span><br><span class="line">      <span class="built_in">soinfo_do_lookup_impl</span>&lt;<span class="literal">false</span>&gt;(name, vi, si_found_in, lookup_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> IsGeneral&gt;</span><br><span class="line">__attribute__((noinline)) <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>*</span></span><br><span class="line"><span class="function"><span class="title">soinfo_do_lookup_impl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> version_info* vi,</span></span></span><br><span class="line"><span class="params"><span class="function">                      soinfo** si_found_in, <span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算符号名的hash,名称长度                        </span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> [ hash, name_len ] = <span class="built_in">calculate_gnu_hash</span>(name);</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">uint32_t</span> kBloomMaskBits = <span class="built_in">sizeof</span>(<span class="built_in">ElfW</span>(Addr)) * <span class="number">8</span>;</span><br><span class="line">  <span class="function">SymbolName <span class="title">elf_symbol_name</span><span class="params">(name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得起始位置和结束位置，进行迭代查询。</span></span><br><span class="line">  <span class="type">const</span> SymbolLookupLib* end = lookup_list.<span class="built_in">end</span>();</span><br><span class="line">  <span class="type">const</span> SymbolLookupLib* it = lookup_list.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前指向的lib</span></span><br><span class="line">    <span class="type">const</span> SymbolLookupLib* lib;</span><br><span class="line">    <span class="type">uint32_t</span> sym_idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over libraries until we find one whose Bloom filter matches the symbol we&#x27;re</span></span><br><span class="line">    <span class="comment">// searching for.</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果遍历完了，还没找到返回nullptr</span></span><br><span class="line">      <span class="keyword">if</span> (it == end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      lib = it++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral &amp;&amp; lib-&gt;<span class="built_in">needs_sysv_lookup</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> <span class="built_in">ElfW</span>(Sym)* sym = lib-&gt;si_-&gt;<span class="built_in">find_symbol_by_name</span>(elf_symbol_name, vi)) &#123;</span><br><span class="line">          *si_found_in = lib-&gt;si_;</span><br><span class="line">          <span class="keyword">return</span> sym;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (IsGeneral) &#123;</span><br><span class="line">        <span class="built_in">LD_DEBUG</span>(lookup, <span class="string">&quot;SEARCH %s in %s@%p (gnu)&quot;</span>,</span><br><span class="line">                 name, lib-&gt;si_-&gt;<span class="built_in">get_realpath</span>(), <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(lib-&gt;si_-&gt;base));</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// bloom过滤加快查找过程</span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; lib-&gt;gnu_maskwords_;</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> bloom_word </span>= lib-&gt;gnu_bloom_filter_[word_num];</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> h1 = hash % kBloomMaskBits;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint32_t</span> h2 = (hash &gt;&gt; lib-&gt;gnu_shift2_) % kBloomMaskBits;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) == <span class="number">1</span>) &#123;</span><br><span class="line">        sym_idx = lib-&gt;gnu_bucket_[hash % lib-&gt;gnu_nbucket_];</span><br><span class="line">        <span class="keyword">if</span> (sym_idx != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the library&#x27;s hash table chain.</span></span><br><span class="line">    <span class="built_in">ElfW</span>(Versym) verneed = kVersymNotNeeded;</span><br><span class="line">    <span class="type">bool</span> calculated_verneed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> chain_value = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      sym = lib-&gt;symtab_ + sym_idx;</span><br><span class="line">      chain_value = lib-&gt;gnu_chain_[sym_idx];</span><br><span class="line">      <span class="keyword">if</span> ((chain_value &gt;&gt; <span class="number">1</span>) == (hash &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vi != <span class="literal">nullptr</span> &amp;&amp; !calculated_verneed) &#123;</span><br><span class="line">          calculated_verneed = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 查找匹配到的版本信息</span></span><br><span class="line">          verneed = <span class="built_in">find_verdef_version_index</span>(lib-&gt;si_, vi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 看版本是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_symbol_version</span>(lib-&gt;versym_, sym_idx, verneed) &amp;&amp;</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(sym-&gt;st_name) + name_len + <span class="number">1</span> &lt;= lib-&gt;strtab_size_ &amp;&amp;</span><br><span class="line">            <span class="comment">// 比较名称是否相等</span></span><br><span class="line">            <span class="built_in">memcmp</span>(lib-&gt;strtab_ + sym-&gt;st_name, name, name_len + <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// 判断符号是否是GLOBAL的，类型为（STB_GLOBAL或STB_WEAK）</span></span><br><span class="line">            <span class="built_in">is_symbol_global_and_defined</span>(lib-&gt;si_, sym)) &#123;</span><br><span class="line">            <span class="comment">// 如果都匹配就找到了，否则继续遍历    </span></span><br><span class="line">          *si_found_in = lib-&gt;si_;</span><br><span class="line">          <span class="keyword">return</span> sym;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++sym_idx;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((chain_value &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash计算</span></span><br><span class="line">__attribute__((unused))</span><br><span class="line"><span class="function"><span class="type">static</span> std::pair&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title">calculate_gnu_hash_simple</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* name_bytes = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(name);</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> unroll 8</span></span><br><span class="line">  <span class="keyword">while</span> (*name_bytes != <span class="number">0</span>) &#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">5</span>) + *name_bytes++; <span class="comment">// h*33 + c = h + h * 32 + c = h + h &lt;&lt; 5 + c</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; h, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(name_bytes) - name &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> std::pair&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title">calculate_gnu_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_GNU_HASH_NEON</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">calculate_gnu_hash_neon</span>(name);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">calculate_gnu_hash_simple</span>(name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">is_symbol_global_and_defined</span><span class="params">(<span class="type">const</span> soinfo* si, <span class="type">const</span> ElfW(Sym)* s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__predict_true(<span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info) == STB_GLOBAL ||</span><br><span class="line">                     <span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info) == STB_WEAK)) &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;st_shndx != SHN_UNDEF;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__predict_false(<span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info) != STB_LOCAL)) &#123;</span><br><span class="line">    <span class="built_in">DL_WARN</span>(<span class="string">&quot;Warning: unexpected ST_BIND value: %d for \&quot;%s\&quot; in \&quot;%s\&quot; (ignoring)&quot;</span>,</span><br><span class="line">            <span class="built_in">ELF_ST_BIND</span>(s-&gt;st_info), si-&gt;<span class="built_in">get_string</span>(s-&gt;st_name), si-&gt;<span class="built_in">get_realpath</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="五调用构造器">五、调用构造器</h1>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">soinfo::call_constructors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (constructors_called) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We set constructors_called before actually calling the constructors, otherwise it doesn&#x27;t</span></span><br><span class="line">  <span class="comment">// protect against recursive constructor calls. One simple example of constructor recursion</span></span><br><span class="line">  <span class="comment">// is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so:</span></span><br><span class="line">  <span class="comment">// 1. The program depends on libc, so libc&#x27;s constructor is called here.</span></span><br><span class="line">  <span class="comment">// 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 3. dlopen() calls the constructors on the newly created</span></span><br><span class="line">  <span class="comment">//    soinfo for libc_malloc_debug_leak.so.</span></span><br><span class="line">  <span class="comment">// 4. The debug .so depends on libc, so CallConstructors is</span></span><br><span class="line">  <span class="comment">//    called again with the libc soinfo. If it doesn&#x27;t trigger the early-</span></span><br><span class="line">  <span class="comment">//    out above, the libc constructor will be called again (recursively!).</span></span><br><span class="line">  constructors_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_main_executable</span>() &amp;&amp; preinit_array_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// The GNU dynamic linker silently ignores these, but we warn the developer.</span></span><br><span class="line">    <span class="built_in">DL_WARN</span>(<span class="string">&quot;\&quot;%s\&quot;: ignoring DT_PREINIT_ARRAY in shared library!&quot;</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用所以子依赖的构造器</span></span><br><span class="line">  <span class="built_in">get_children</span>().for_each([] (soinfo* si) &#123;</span><br><span class="line">    si-&gt;<span class="built_in">call_constructors</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">    <span class="built_in">bionic_trace_begin</span>((std::<span class="built_in">string</span>(<span class="string">&quot;calling constructors: &quot;</span>) + <span class="built_in">get_realpath</span>()).<span class="built_in">c_str</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用DT_INIT函数和DT_INIT_ARRAY中的所有函数</span></span><br><span class="line">  <span class="comment">// DT_INIT should be called before DT_INIT_ARRAY if both are present.</span></span><br><span class="line">  <span class="built_in">call_function</span>(<span class="string">&quot;DT_INIT&quot;</span>, init_func_, <span class="built_in">get_realpath</span>());</span><br><span class="line">  <span class="built_in">call_array</span>(<span class="string">&quot;DT_INIT_ARRAY&quot;</span>, init_array_, init_array_count_, <span class="literal">false</span>, <span class="built_in">get_realpath</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">is_linker</span>()) &#123;</span><br><span class="line">    <span class="built_in">bionic_trace_end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p>Android的namespace机制: <a
target="_blank" rel="noopener" href="https://zhenhuaw.me/blog/2017/namespace-based-dynamic-linking.html"
class="uri">https://zhenhuaw.me/blog/2017/namespace-based-dynamic-linking.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blueberrycoder.github.io/2025/09/06/android/native_dynamic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blueberry">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep learning">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Keep learning">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/06/android/native_dynamic/" class="post-title-link" itemprop="url">Android动态链接技术一（ELF文件）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-09-06 10:43:41" itemprop="dateCreated datePublished" datetime="2025-09-06T10:43:41+08:00">2025-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-02 14:54:24" itemprop="dateModified" datetime="2025-11-02T14:54:24+08:00">2025-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/code/" itemprop="url" rel="index"><span itemprop="name">code</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言">前言</h1>
<p>Android开发中涉及Native（C/C++等）程序、接入外部动态库、处理线上崩溃、Native
Hook、加固、逆向等，都需要了解到动态链接技术。</p>
<h1 id="动态库与位置关代码">动态库与位置⽆关代码</h1>
<h2 id="共享库">共享库</h2>
<p>使用一些高级语言（C/C++）最终编译后产物是二进制文件。我们通常引用第三方库，会使用它的动态共享库。同时我们自己开发的二方库本身时也可能依赖其他的共享库，我们也可能给别人提供共享库。</p>
<p>我们为了代码复用，多个Module复用同样的代码时，我们可以将这些代码剥离处理做成一个共享库供其使用。
<img src="/images/android/native_shared_library.png" alt="shared_library" width="720">
共享库又分为静态库库和动态共享库。</p>
<h2 id="静态共享库">静态共享库</h2>
<p>静态库是编译时依赖，即编译程序时，会将共享库的内容打包到可执行程序中（假设我们是一个可执行程序，依赖一个共享库）。而静态库不会作为单独的文件和可执行程序发布。
<img src="/images/android/native_static_shared_library.png" alt="static_shared" width="720"></p>
<h2 id="动态共享库">动态共享库</h2>
<p>动态库是运行时依赖，即编译程序时，不会将共享库的内容打包到可执行程序。发布程序时需要将动态库一起发布。
<img src="/images/android/native_dynamic_shared_library.png" alt="dynamic_shared" width="720"></p>
<h2 id="位置无关代码">位置无关代码</h2>
<p>因为动态库是要运行时动态加载，其加载位置即运行时地址是不固定的。因此需要保证代码时位置无关的(PIC,
Position Idependent Code)。 为了接下来的演示，我在Android
Arm64平台写下如下代码: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SayHelloWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (i++ % <span class="number">2</span>  == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SayHello</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">JNIEXPORT jstring JNICALL</span></span><br><span class="line"><span class="function"><span class="title">Java_com_blueberry_anative_MainActivity_stringFromJNI</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">        jobject <span class="comment">/* this */</span>)</span> </span>&#123;</span><br><span class="line">    std::string hello = <span class="string">&quot;Hello from C++&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SayHelloWrapper</span>();</span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>(hello.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
这段代码编译完后，我们可以在arm64-v8a目录中得到动态(libanative.so)。</p>
<p>我们使用<code>objdump -d libanative.so</code>
对产物进行反汇编。可以得到： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   1dc68:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000001dc6c &lt;SayHelloWrapper&gt;:</span><br><span class="line">// 指令地址    机器码           汇编指令                 符号名（可选）</span><br><span class="line">   1dc6c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!</span><br><span class="line">   1dc70:	910003fd 	mov	x29, sp</span><br><span class="line">   1dc74:	14000001 	b	1dc78 &lt;SayHelloWrapper+0xc&gt;</span><br><span class="line">   1dc78:	f000014a 	adrp	x10, 48000 &lt;_DYNAMIC+0x12b8&gt;</span><br><span class="line">   1dc7c:	b9446148 	ldr	w8, [x10, #1120]</span><br><span class="line">   1dc80:	11000509 	add	w9, w8, #0x1</span><br><span class="line">   1dc84:	b9046149 	str	w9, [x10, #1120]</span><br><span class="line">   1dc88:	5280004a 	mov	w10, #0x2                   	// #2</span><br><span class="line">   1dc8c:	1aca0d09 	sdiv	w9, w8, w10</span><br><span class="line">   1dc90:	1b0a7d29 	mul	w9, w9, w10</span><br><span class="line">   1dc94:	6b090108 	subs	w8, w8, w9</span><br><span class="line">   1dc98:	35000068 	cbnz	w8, 1dca4 &lt;SayHelloWrapper+0x38&gt;</span><br><span class="line">   1dc9c:	14000001 	b	1dca0 &lt;SayHelloWrapper+0x34&gt;</span><br><span class="line">   1dca0:	14000002 	b	1dca8 &lt;SayHelloWrapper+0x3c&gt;</span><br><span class="line">   1dca4:	17fffff5 	b	1dc78 &lt;SayHelloWrapper+0xc&gt;</span><br><span class="line">   1dca8:	9400920e 	bl	424e0 &lt;SayHello@plt&gt;</span><br><span class="line">   1dcac:	a8c17bfd 	ldp	x29, x30, [sp], #16</span><br><span class="line">   1dcb0:	d65f03c0 	ret</span><br><span class="line"></span><br><span class="line">000000000001dcb4 &lt;Java_com_blueberry_anative_MainActivity_stringFromJNI&gt;:</span><br><span class="line">   1dcb4:	d10183ff 	sub	sp, sp, #0x60</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
上面的是SayHelloWrapper这个函数对应的汇编指令，我们来看这一行：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1dca0:	14000002 	b	1dca8 &lt;SayHelloWrapper+0x3c&gt;</span><br></pre></td></tr></table></figure>
这条指令对应的汇编语言是跳转到1dca8地址，即当前指令地址+2的位置，这里+2的单位是指令长度。虽然反汇编的结果是直接指向这个地址值，但它的指令其实用的是相对偏移。这一点从它的机器码的地位其实可以看出端倪（它的末尾是2）。另外这些指令的地址都是相对地址并不是动态库被加载后的运行时的地址。运行时的真实地址是基地址(load_bias)+这里的相对地址。load_bias为加载动态库后的执行段的起始地址。</p>
<p>这里的指令集是AArch64指令集，其中b指令的格式为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">31  30........5    0</span><br><span class="line">|  opcode=000101   | imm26 |</span><br><span class="line">- 高 6 位固定 = 000101 (0x05)</span><br><span class="line">- 剩下 26 位是带符号偏移量 imm26（相对于当前指令地址，单位是 4 字节）</span><br></pre></td></tr></table></figure>
0x14000002的二进制是：<code>0001 0100 0000 0000 0000 0000 0000 0010</code>
这条指令的opcode = 000101，imm26 = 0x0000002的偏移量 = 2 * 4 = 8
字节，也就是跳转的目标地址是距离当前指令地址+8字节的地址，因为当前指令的地址是：1dca0，所有目标地址是：1dca8。那么无论这个动态库被加载在什么位置都不影响这个跳转指令的正确性。</p>
<h2 id="绝对地址跳转">绝对地址跳转</h2>
<p>当跨模块调用时，比如我们上面的代码在SayHello中使用了libc的printf函数。编译器在编译期间是无法知道这个函数的地址的，它是怎么保证跳转的正确呢？
那么我们先来使用objdump看下SayHello函数的汇编指令： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">000000000001dc50 &lt;SayHello&gt;:</span><br><span class="line">   1dc50:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!</span><br><span class="line">   1dc54:	910003fd 	mov	x29, sp</span><br><span class="line">   1dc58:	d0ffffa0 	adrp	x0, 13000 &lt;GCC_except_table133+0x14&gt;</span><br><span class="line">   1dc5c:	913be000 	add	x0, x0, #0xef8</span><br><span class="line">   1dc60:	94009224 	bl	424f0 &lt;printf@plt&gt;</span><br><span class="line">   1dc64:	a8c17bfd 	ldp	x29, x30, [sp], #16</span><br><span class="line">   1dc68:	d65f03c0 	ret</span><br></pre></td></tr></table></figure> 其中：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1dc60:	94009224 	bl	424f0 &lt;printf@plt&gt;  </span><br></pre></td></tr></table></figure>
是想跳转到printf函数，它跳转的地址是424f0，对应的符号是printf@plt。
我们使用<code>objdump -d -j .plt libanative.so</code>查看对应plt表，得到：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">00000000000424f0 &lt;printf@plt&gt;:</span><br><span class="line">   424f0:	b0000030 	adrp	x16, 47000 &lt;_ZTVSt9bad_alloc@@Base+0x740&gt;</span><br><span class="line">   424f4:	f9402e11 	ldr	x17, [x16, #88]</span><br><span class="line">   424f8:	91016210 	add	x16, x16, #0x58</span><br><span class="line">   424fc:	d61f0220 	br	x17</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
可以看到地址00000000000424f0对应的代码段，它只有4条指令。这段代码通常被称为“蹦床（trampoline”或跳板函数(stubs)。下面我们逐行解释下这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">00000000000424f0 &lt;printf@plt&gt;:</span><br><span class="line">   // 将47000（.got.plt表的基址）放到x16寄存器。</span><br><span class="line">   424f0:	b0000030 	adrp	x16, 47000 &lt;_ZTVSt9bad_alloc@@Base+0x740&gt;</span><br><span class="line">   // 将x16寄存器的值+88得到的地址存放到x17寄存器。（即got表中这个函数对应的slot地址）</span><br><span class="line">   424f4:	f9402e11 	ldr	x17, [x16, #88]</span><br><span class="line">   // 将x16寄存器的值加0x58也就是十进制88,（即got表中这个函数对应的slot地址）用户之后的resolve回填函数地址。</span><br><span class="line">   424f8:	91016210 	add	x16, x16, #0x58</span><br><span class="line">   // 跳转到x17中存放的地址（即got表中对应的地址）。</span><br><span class="line">   424fc:	d61f0220 	br	x17</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的代码首先会找到GOT表的基地址，然后加上当前函数对应在got表slot槽的偏移。然后往这个slot对应的地址跳转，并且用x16保存了slot的地址。即x16存放的是slot的地址，x17存放的是slot中值。slot中存放的值是目标函数的地址即printf函数的地址（假设已经完成延时绑定的话）。</p>
<p>下面我们来看got表的信息，着重看got表0x58偏移对应的内容（got表的基地址为0x47000）。
因为.got.plt是数据段，我们用<code>objdump -s -j .got -j .got.plt libanative.so</code>来查看：</p>
<p>.got用来保存全局变量引用的地址，.got.plt用来保存函数引用的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a objdump -s -j .got  -j .got.plt libanative.so</span><br><span class="line"></span><br><span class="line">libanative.so:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Contents of section .got:</span><br><span class="line"> 46f18 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f28 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f38 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f48 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f58 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f68 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f78 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f88 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46f98 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fa8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fb8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fc8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fd8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46fe8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 46ff8 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 47008 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 47018 00000000 00000000                    ........</span><br><span class="line">Contents of section .got.plt:</span><br><span class="line"> 47020 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 47030 00000000 00000000 90240400 00000000  .........$......</span><br><span class="line"> 47040 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47050 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47060 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47070 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47080 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 47090 90240400 00000000 90240400 00000000  .$.......$......</span><br><span class="line"> 470a0 90240400 00000000 90240400 00000000  .$.......$......</span><br></pre></td></tr></table></figure>
<p>最左边一列是数据的地址，后面的4列是数据，数据是以小端方式排列的。一行显示16字节，那么0x47000
+ 0x58对应的槽的就在数据的第4行第3列。 它的值为90240400
00000000，另外我们可以看到got表中前0x47038前的都是0，后面每个槽的值都是90240400
00000000。（这里每个槽都是8个字节）。</p>
<p>这里是因为，GOT表中的前几个槽都时预留的不给我们的代码使用，后续的槽默认都PLT0(PLT表的基地址)。</p>
<p>具体来讲，我通过查资料得到在linux系统中动态库被加载后动态加载器会给他们赋值：</p>
<p>GOT[0]:保存的是.dynamic段的地址（即动态段的起始地址）。动态链接器ld.so启动时会用这个地址来获取需要解析的动态信息，比如
.dynsym、.dynstr、.rel.plt等表。</p>
<p>GOT[1]:保存的是linker/loader的解析函数地址，即_dl_runtime_resolve（或平台相关的
resolver stub）。当你第一次调用某个外部函数时，PLT
entry会跳到GOT[1]指向的解析器。解析器会根据GOT[2]+槽地址找到具体要解析的符号，然后去加载对应的动态库函数地址。</p>
<p>GOT[2]:保存的是link_map
结构体指针，这是动态链接器内部维护的ELF链接状态表（每个已加载的共享对象有一个link_map节点）。_dl_runtime_resolve通过GOT[2]能够知道“当前进程有哪些已加载的库”，从而去符号查找、重定位。</p>
<p>但通过我们这个Android平台的so文件，我发现GOT[6]（这个例子中就是地址0x47030）应该存储的是linker/loader的解析函数地址，即_dl_runtime_resolve。
另外我们也可以通过readelf查看槽位的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -r libanative.so</span><br><span class="line"></span><br><span class="line">Relocation section &#x27;.rela.plt&#x27; at offset 0x11d88 contains 122 entries:</span><br><span class="line">  Offset          Info           Type           Sym. Value    Sym. Name + Addend</span><br><span class="line">000000047038  000100000402 R_AARCH64_JUMP_SL 0000000000000000 __cxa_finalize@LIBC + 0</span><br><span class="line">000000047040  000200000402 R_AARCH64_JUMP_SL 0000000000000000 __cxa_atexit@LIBC + 0</span><br><span class="line">000000047048  000300000402 R_AARCH64_JUMP_SL 0000000000000000 __register_atfork@LIBC + 0</span><br><span class="line">000000047050  021400000402 R_AARCH64_JUMP_SL 000000000001dc50 SayHello + 0</span><br><span class="line">000000047058  000400000402 R_AARCH64_JUMP_SL 0000000000000000 printf@LIBC + 0</span><br><span class="line">000000047060  018900000402 R_AARCH64_JUMP_SL 000000000001dc6c SayHelloWrapper + 0</span><br><span class="line">000000047068  01aa00000402 R_AARCH64_JUMP_SL 000000000001dd64 _ZNSt6__ndk112bas[...</span><br></pre></td></tr></table></figure>
<p>我们可以看到printf函数对应的槽信息，它的类型为：R_AARCH64_JUMP_SLOT
表示“这个 GOT 条目需要在运行时被填充成目标函数的真实地址”。</p>
<p>90240400 00000000
因为是小端存储的，所以对应的值是：0x402490，它就是PLT0的地址。
我们使用<code>objdump -d -j .plt libanative.so</code>来看.plt表来验证。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// PLT 表头（PLT0）</span><br><span class="line">0000000000042490 &lt;__cxa_finalize@plt-0x20&gt;:</span><br><span class="line">//  入栈保存 x16/IP0 与 LR（x30）</span><br><span class="line">   42490:	a9bf7bf0 	stp	x16, x30, [sp, #-16]!</span><br><span class="line">// x16 = .got.plt 所在页基址   </span><br><span class="line">   42494:	b0000030 	adrp	x16, 47000 &lt;_ZTVSt9bad_alloc@@Base+0x740&gt;</span><br><span class="line">// x17 = [.got.plt + 0x30（48）]（解析器入口指针 _dl_runtime_resolve）   </span><br><span class="line">   42498:	f9401a11 	ldr	x17, [x16, #48]</span><br><span class="line">// x16 =  .got.plt + 0x30（把“当前槽地址”传给解析器）   </span><br><span class="line">   4249c:	9100c210 	add	x16, x16, #0x30</span><br><span class="line">//  跳到解析器（_dl_runtime_resolve 的桩）   </span><br><span class="line">   424a0:	d61f0220 	br	x17</span><br><span class="line">   424a4:	d503201f 	nop</span><br><span class="line">   424a8:	d503201f 	nop</span><br><span class="line">   424ac:	d503201f 	nop</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
从上面的分析，我们得到我们在第一次调用print这个外部函数时，由于GOT表中的条目是指向PLT0，所以我们最终调用了_dl_runtime_resolve函数。</p>
<p>_dl_runtime_resolve因为知道GOT表的槽（保存在x16寄存器的槽位置）并且通过.rela.plt也能知道我们调用的函数的符号信息，找到对应的外部函数的地址。然后执行，并且将查到的地址写入到我们槽。那么下次再调用这个函数就不用再执行解析操作了。这个机制也叫延时绑定机制(lazy
binding)。</p>
<p>_dl_runtime_resolve是一个glibc中的一个汇编段，它在dl-trampoline.S文件中。
它的大致实现为： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* RELA relocatons are 3 pointers */</span><br><span class="line">#define RELA_SIZE (PTR_SIZE * 3)</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.globl _dl_runtime_resolve</span><br><span class="line">	.type _dl_runtime_resolve, #function</span><br><span class="line">	cfi_startproc</span><br><span class="line">	.align 2</span><br><span class="line">_dl_runtime_resolve:</span><br><span class="line">	/* AArch64 we get called with:</span><br><span class="line">	   ip0		&amp;PLTGOT[2]</span><br><span class="line">	   ip1		temp(dl resolver entry point)</span><br><span class="line">	   [sp, #8]	lr</span><br><span class="line">	   [sp, #0]	&amp;PLTGOT[n]</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	cfi_rel_offset (lr, 8)</span><br><span class="line"></span><br><span class="line">	/* Save arguments.  */</span><br><span class="line">	stp	x8, x9, [sp, #-(80+8*16)]!</span><br><span class="line">	cfi_adjust_cfa_offset (80+8*16)</span><br><span class="line">	cfi_rel_offset (x8, 0)</span><br><span class="line">	cfi_rel_offset (x9, 8)</span><br></pre></td></tr></table></figure> <a
target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.29/source/sysdeps/aarch64/dl-trampoline.S"
class="uri">https://elixir.bootlin.com/glibc/glibc-2.29/source/sysdeps/aarch64/dl-trampoline.S</a></p>
<p>但是Android使用的bionic的libc，它没有_dl_runtime_resolve函数的定义，上述代码PLT[0]，以及调用_dl_runtime_resolve的方式是我查资料，并且在linux的gcc
libc中看到实现。
而Android默认并没有开启延时绑定（RTLD_LAZY），它在so加载时直接进行了绑定。</p>
<p><a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/bionic/"
class="uri">https://android.googlesource.com/platform/bionic/</a></p>
<h1 id="elf文件格式">ELF文件格式</h1>
<p>ELF（Executable and Linkable
Format）常见发音：(/ɛlf/)，elf的中文意义也有小精灵、精灵族的意思。ELF文件是linux平台使用的一个二进制文件格式。我们平时的.o文件(可重定位文件)、so文件、可执行文件、coredump文件都是ELF文件格式。</p>
<p><img src="/images/android/native_elf_brief.png" alt="elf_brief" width="720"></p>
<h2 id="编译链接流程">编译链接流程</h2>
<p>如图描述了c/c++程序编译&amp;链接的流程。
<img src="/images/android/native_c_compilation.png" alt="elf_brief" width="720"></p>
<h2 id="ehdr">Ehdr</h2>
<p>Ehdr，定义了文件基础信息，它在整个文件的开头，它拥有文件的标识（Magic
为’E’,‘L’,‘F’）、ELF版本号、CPU架构类型、程序入的虚拟地址、Promgram
header表的偏移、数量、Section Header表的偏移、数量、Section
String表的偏移、大小等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#define EI_NIDENT (16)</span><br><span class="line">// 32 bit</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */</span><br><span class="line">  Elf32_Half	e_type;			/* Object file type */</span><br><span class="line">  Elf32_Half	e_machine;		/* Architecture */</span><br><span class="line">  Elf32_Word	e_version;		/* Object file version */</span><br><span class="line">  Elf32_Addr	e_entry;		/* Entry point virtual address */</span><br><span class="line">  Elf32_Off	e_phoff;		/* Program header table file offset */</span><br><span class="line">  Elf32_Off	e_shoff;		/* Section header table file offset */</span><br><span class="line">  Elf32_Word	e_flags;		/* Processor-specific flags */</span><br><span class="line">  Elf32_Half	e_ehsize;		/* ELF header size in bytes */</span><br><span class="line">  Elf32_Half	e_phentsize;		/* Program header table entry size */</span><br><span class="line">  Elf32_Half	e_phnum;		/* Program header table entry count */</span><br><span class="line">  Elf32_Half	e_shentsize;		/* Section header table entry size */</span><br><span class="line">  Elf32_Half	e_shnum;		/* Section header table entry count */</span><br><span class="line">  Elf32_Half	e_shstrndx;		/* Section header string table index */</span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line">// 64bit</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */</span><br><span class="line">  Elf64_Half	e_type;			/* Object file type */</span><br><span class="line">  Elf64_Half	e_machine;		/* Architecture */</span><br><span class="line">  Elf64_Word	e_version;		/* Object file version */</span><br><span class="line">  Elf64_Addr	e_entry;		/* Entry point virtual address */</span><br><span class="line">  Elf64_Off	e_phoff;		/* Program header table file offset */</span><br><span class="line">  Elf64_Off	e_shoff;		/* Section header table file offset */</span><br><span class="line">  Elf64_Word	e_flags;		/* Processor-specific flags */</span><br><span class="line">  Elf64_Half	e_ehsize;		/* ELF header size in bytes */</span><br><span class="line">  Elf64_Half	e_phentsize;		/* Program header table entry size */</span><br><span class="line">  Elf64_Half	e_phnum;		/* Program header table entry count */</span><br><span class="line">  Elf64_Half	e_shentsize;		/* Section header table entry size */</span><br><span class="line">  Elf64_Half	e_shnum;		/* Section header table entry count */</span><br><span class="line">  Elf64_Half	e_shstrndx;		/* Section header string table index */</span><br><span class="line">&#125; Elf64_Ehdr;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>e_ident的结构为：
<img src="/images/android/native_elf_ident.png" alt="ident" width="720"></p>
<p>通过<code>readelf -h libanative.so</code>我们也能查看文件的头信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -h libanative.so</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           AArch64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          1897688 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         9</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         34</span><br><span class="line">  Section header string table index: 32</span><br></pre></td></tr></table></figure>
<p>文件头信息中，多数信息是固定不变的（Margic、Version、Machine等）。所以我们重点关注下e_phoff
、 e_shoff 、 e_phnum 、 e_shnum 、
e_shstrndx这些值。这几个字段描述了三类信息：Section头、Program头、字符串。</p>
<p>Section和Program是对这个文件的两种不同视角的描述，Section为不加载的情况下的静态分析视角、Pragma描述的是文件加载后的运行时视角。</p>
<h2 id="shdr">Shdr</h2>
<p>Section Header,
ELF文件中的代码(code)、数据(data)分为了一些连续的块。Section
Header就是描述这些块的名称、类型、在文件中的偏移、被加载后的虚拟地址（应该被加载在什么地方）、大小等。为了节省篇幅，我后续只贴出64位的数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word	sh_name;		/* Section name (string tbl index) */</span><br><span class="line">  Elf64_Word	sh_type;		/* Section type */</span><br><span class="line">  Elf64_Xword	sh_flags;		/* Section flags */</span><br><span class="line">  Elf64_Addr	sh_addr;		/* Section virtual addr at execution */</span><br><span class="line">  Elf64_Off	sh_offset;		/* Section file offset */</span><br><span class="line">  Elf64_Xword	sh_size;		/* Section size in bytes */</span><br><span class="line">  Elf64_Word	sh_link;		/* Link to another section */</span><br><span class="line">  Elf64_Word	sh_info;		/* Additional section information */</span><br><span class="line">  Elf64_Xword	sh_addralign;		/* Section alignment */</span><br><span class="line">  Elf64_Xword	sh_entsize;		/* Entry size if section holds table */</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p>这里的sh_name描述了Section的名称，但它并不是一个字符串而是指向字符串表的索引。字符串表也是一个Section，它是一个字符串池，也有自己的压缩方式。
我们可以使用<code>readelf -S libanative.so</code>来查看ELF文件中的所有Section
Header: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -S libanative.so</span><br><span class="line">There are 34 section headers, starting at offset 0x1cf4d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.androi[...] NOTE             0000000000000238  00000238</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .note.gnu.bu[...] NOTE             00000000000002d0  000002d0</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .dynsym           DYNSYM           00000000000002f8  000002f8</span><br><span class="line">       0000000000003708  0000000000000018   A       7     1     8</span><br><span class="line">  [ 4] .gnu.version      VERSYM           0000000000003a00  00003a00</span><br><span class="line">       0000000000000496  0000000000000002   A       3     0     2</span><br><span class="line">  [ 5] .gnu.version_r    VERNEED          0000000000003e98  00003e98</span><br><span class="line">       0000000000000040  0000000000000000   A       7     2     4</span><br><span class="line">  [ 6] .gnu.hash         GNU_HASH         0000000000003ed8  00003ed8</span><br><span class="line">       0000000000000e2c  0000000000000000   A       3     0     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000004d04  00004d04</span><br><span class="line">       000000000000484a  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .rela.dyn         RELA             0000000000009550  00009550</span><br><span class="line">       0000000000008838  0000000000000018   A       3     0     8</span><br><span class="line">  [ 9] .rela.plt         RELA             0000000000011d88  00011d88</span><br><span class="line">       0000000000000b70  0000000000000018  AI       3    21     8</span><br><span class="line">  [10] .gcc_except_table PROGBITS         00000000000128f8  000128f8</span><br><span class="line">       0000000000000bc0  0000000000000000   A       0     0     4</span><br><span class="line">  [11] .rodata           PROGBITS         00000000000134c0  000134c0</span><br><span class="line">       000000000000364c  0000000000000000 AMS       0     0     16</span><br><span class="line">  [12] .eh_frame_hdr     PROGBITS         0000000000016b0c  00016b0c</span><br><span class="line">       0000000000001534  0000000000000000   A       0     0     4</span><br><span class="line">  [13] .eh_frame         PROGBITS         0000000000018040  00018040</span><br><span class="line">       0000000000005ba4  0000000000000000   A       0     0     8</span><br><span class="line">  [14] .text             PROGBITS         000000000001dbf0  0001dbf0</span><br><span class="line">       0000000000024894  0000000000000000  AX       0     0     16</span><br><span class="line">  [15] .plt              PROGBITS         0000000000042490  00042490</span><br><span class="line">       00000000000007c0  0000000000000000  AX       0     0     16</span><br><span class="line">  [16] .data.rel.ro      PROGBITS         0000000000043c50  00042c50</span><br><span class="line">       00000000000030e0  0000000000000000  WA       0     0     8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY       0000000000046d30  00045d30</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [18] .init_array       INIT_ARRAY       0000000000046d40  00045d40</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     8</span><br><span class="line">  [19] .dynamic          DYNAMIC          0000000000046d48  00045d48</span><br><span class="line">       00000000000001d0  0000000000000010  WA       7     0     8</span><br><span class="line">  [20] .got              PROGBITS         0000000000046f18  00045f18</span><br><span class="line">       0000000000000108  0000000000000000  WA       0     0     8</span><br><span class="line">  [21] .got.plt          PROGBITS         0000000000047020  00046020</span><br><span class="line">       00000000000003e8  0000000000000000  WA       0     0     8</span><br><span class="line">  [22] .data             PROGBITS         0000000000048408  00046408</span><br><span class="line">       0000000000000058  0000000000000000  WA       0     0     8</span><br><span class="line">  [23] .bss              NOBITS           0000000000048460  00046460</span><br><span class="line">       0000000000000ac0  0000000000000000  WA       0     0     16</span><br><span class="line">  [24] .comment          PROGBITS         0000000000000000  00046460</span><br><span class="line">       00000000000000b1  0000000000000001  MS       0     0     1</span><br><span class="line">  [25] .debug_abbrev     PROGBITS         0000000000000000  00046511</span><br><span class="line">       0000000000004286  0000000000000000           0     0     1</span><br><span class="line">  [26] .debug_info       PROGBITS         0000000000000000  0004a797</span><br><span class="line">       000000000006df30  0000000000000000           0     0     1</span><br><span class="line">  [27] .debug_ranges     PROGBITS         0000000000000000  000b86c7</span><br><span class="line">       0000000000022bd0  0000000000000000           0     0     1</span><br><span class="line">  [28] .debug_str        PROGBITS         0000000000000000  000db297</span><br><span class="line">       000000000003acd0  0000000000000001  MS       0     0     1</span><br><span class="line">  [29] .debug_line       PROGBITS         0000000000000000  00115f67</span><br><span class="line">       0000000000025b35  0000000000000000           0     0     1</span><br><span class="line">  [30] .debug_loc        PROGBITS         0000000000000000  0013ba9c</span><br><span class="line">       000000000006f3b4  0000000000000000           0     0     1</span><br><span class="line">  [31] .symtab           SYMTAB           0000000000000000  001aae50</span><br><span class="line">       0000000000010ed8  0000000000000018          33   2303     8</span><br><span class="line">  [32] .shstrtab         STRTAB           0000000000000000  001bbd28</span><br><span class="line">       0000000000000163  0000000000000000           0     0     1</span><br><span class="line">  [33] .strtab           STRTAB           0000000000000000  001bbe8b</span><br><span class="line">       0000000000013649  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure></p>
<p>重点看下字段的类型吧，</p>
<p><strong>sh_type</strong></p>
<pre><code>- SHT_NULL ：Section入口（未使用）
- SHT_PROGBITS ：存放指令、常量。
- SHT_SYMTAB ： 静态符号表
- SHT_STRTAB： 字符串表
- SHT_RELA： 重定位信息(有addends)
- SHT_HASH： 哈希表
- SHT_DYNAMIC： 动态链接信息
- SHT_NOTE： Note
- SHT_NOBITS： 未初始化数据
- SHT_REL: 重定位信息(无addends)
- SHT_DYNSYM：动态链接符号表</code></pre>
<p><strong>sh_flags</strong></p>
<pre><code>- SHF_WRITE：运行时可写入。
- SHF_ALLOC：运行时将被加载到虚拟内存。
- SHF_EXECINSTR： 包含可执行指令。</code></pre>
<p><strong>sh_addr</strong></p>
<p>该Section在运行时的虚拟地址。</p>
<p><strong>sh_offset</strong></p>
<p>该Section在ELF文件中的偏移。</p>
<h2 id="常见的section">常见的Section</h2>
<ul>
<li>.init
存放程序最开始执行时的任务。（可执行文件中，这里面的程序会运行在main函数之前）。</li>
<li>.fini 存放程序结束时需要运行的代码。</li>
<li>.text 存放用户写的代码。</li>
<li>.bss
存放没有初始化的数据，它不占用磁盘（避免空间开销）所以它的数据会在运行时被初始化为0。编译器/链接器只需要知道
.bss 这块区域需要多大。</li>
<li>.data 存放程序的初始化数据。</li>
<li>.rodata 存放程序的只读数据，如程序中用到的字符串。</li>
<li>.plt 即 Procedure Linkage
Table上文已经提到，它和GOT表一起来实现调用外部函数。</li>
<li>.got.plt 用于延时绑定，上文已经提到。</li>
<li>.rel.* 包含重定向的信息，_dl_runtime_resolv
借助它来寻找外部函数以及修改GOT表。</li>
<li>.rela.* 同上，只是它有addend信息。</li>
<li>.dynamic
动态链接的数据结构和对象，用来描述依赖库、符号表、重定位信息、初始化/析构函数等；它是动态链接工作的“说明书”。</li>
<li>.init_array
存放一组函数指针，这组函数会在可执行文件初始化后立即执行。C语言中<code>__attribute__((constructor)</code>标记的函数就会存放在这里。</li>
<li>.fini_array 与.init_array相反，程序销毁的时候执行。</li>
<li>.shstrtab 字符串表，存放一些节区名（.text、.data 等）</li>
<li>.symtab 符号表，如存放函数、变量的符号。</li>
<li>.strtab 字符串表，符号名（函数、变量、文件名等）</li>
<li>.dynsym 动态链接符号表。</li>
<li>.dynstr 字符串表，用于动态链接时。</li>
<li>.interp RTLD_* 是一组 动态加载标志（flags），用于 dlopen()
这个函数。如：RTLD_LAZY，懒解析：只在第一次调用符号时才解析。RTLD_NOW
立即解析：dlopen() 时就把所有未定义符号解析完（性能差但安全）。</li>
<li>.rel.dyn 全局变量可重定位表。</li>
<li>.rel.plt 函数可重定位表。</li>
<li>.eh_frame 发生crash后，用于栈展开（unwind）。</li>
</ul>
<p>为了加载可执行文件，我们需要以不同的方式组织code和data，所有ELF有另一种逻辑视图（运行视图），它叫做segments，它用在运行时。相对应的上面讲的Section它可能用在静态链接时，以及我们用工具分析二进制文件时。</p>
<p>所有理论上Section信息时，在运行时是可选的（我分析bionic时，如果有section
信息，加载器也会读取）。程序通过Pragma
header就可以知道如何去加载这个ELF文件到内存中。</p>
<h2 id="phdr">Phdr</h2>
<p>与Shdr相对，Phdr是提供segments视图(运行视图)，它给操作系统或动态链接器（dynamic-linker）提供了如何去加载这个程序的信息。与之相对的Shdr可以看作是提供给程序静态链接用的。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word	p_type;		/* Segment type */</span><br><span class="line">  Elf64_Word	p_flags;		/* Segment flags */</span><br><span class="line">  Elf64_Off	p_offset;		/* Segment file offset */</span><br><span class="line">  Elf64_Addr	p_vaddr;		/* Segment virtual address */</span><br><span class="line">  Elf64_Addr	p_paddr;		/* Segment physical address */</span><br><span class="line">  Elf64_Xword	p_filesz;		/* Segment size in file */</span><br><span class="line">  Elf64_Xword	p_memsz;		/* Segment size in memory */</span><br><span class="line">  Elf64_Xword	p_align;		/* Segment alignment */</span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
这个头信息描述了Segemnt的类型、标志、在ELF文件中的偏移、被加载的虚拟的地址、物理地址、该Segement在文件中的大小、在内存中的占用大小等。</p>
<p><strong>p_offset</strong></p>
<p>Segment在文件中的偏移。</p>
<p><strong>p_vaddr</strong></p>
<p>Segment在内存中的虚拟地址，（对于可加载段，p_vaddr % PAGE_SIZE 必须和
p_offset % PAGE_SIZE相等）。</p>
<p><strong>p_paddr</strong></p>
<p>物理地址，适用于没有MMU的操作系统，对于现代的操作系统无用。</p>
<p><strong>p_memsz</strong></p>
<p>Segment在内存中的大小。（一些Section只指定了需要在内存中分配多大空间，并不要求将Section中的数据映射到内存，比如.bss）。</p>
<p>同样我们可以用readelf查看Segments Header的信息。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -l libanative.so</span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R      0x8</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000042c50 0x0000000000042c50  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000037b8  RW     0x1000</span><br><span class="line">  LOAD           0x0000000000046408 0x0000000000048408 0x0000000000048408</span><br><span class="line">                 0x0000000000000058 0x0000000000000b18  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000045d48 0x0000000000046d48 0x0000000000046d48</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  GNU_RELRO      0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000043b0  R      0x1</span><br><span class="line">  GNU_EH_FRAME   0x0000000000016b0c 0x0000000000016b0c 0x0000000000016b0c</span><br><span class="line">                 0x0000000000001534 0x0000000000001534  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x0</span><br><span class="line">  NOTE           0x0000000000000238 0x0000000000000238 0x0000000000000238</span><br><span class="line">                 0x00000000000000bc 0x00000000000000bc  R      0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .note.android.ident .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .gcc_except_table .rodata .eh_frame_hdr .eh_frame .text .plt</span><br><span class="line">   02     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   03     .data .bss</span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .note.android.ident .note.gnu.build-id</span><br></pre></td></tr></table></figure>
从上面的信息中，我们可以看到Segemnts的被映射的地址范围、标记、权限信息。以及每个Segment与Sections的对应关系。
这个so文件中：</p>
<p>PHDR：是Program Header自身。</p>
<p>GNU_STACK：
表示的是程序的栈是否允许有可执⾏权限，其p_flags⼀般是RW，表示栈不允许有可执⾏权限。</p>
<p>LOAD: 有3个LOAD Segments他们的执行权限分别是：R、RE、RW。</p>
<p>DYNAMIC： 内存映射结束后，dynamic
linker还会去查找外部符号（函数、变量）的地址，并填写GOT表的Slot，这个过程叫重定向，其相关的信息都在.dynamic中。</p>
<p>NOTE：
是一些非必要的注释信息，其中.note.gnu.build-id是动态库的build-id信息。</p>
<p>GNU_EH_FRAME：用于栈回溯。</p>
<h1 id="符号与符号表">符号与符号表</h1>
<p>符号是一些data或code的一种符号化引用，例如一些函数、变量的引用。</p>
<p>它的结构如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word	st_name;		/* Symbol name (string tbl index) */</span><br><span class="line">  unsigned char	st_info;		/* Symbol type and binding */</span><br><span class="line">  unsigned char st_other;		/* Symbol visibility */</span><br><span class="line">  Elf64_Section	st_shndx;		/* Section index */</span><br><span class="line">  Elf64_Addr	st_value;		/* Symbol value */</span><br><span class="line">  Elf64_Xword	st_size;		/* Symbol size */</span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure></p>
<p><strong>st_name</strong></p>
<p>符号名称。</p>
<p><strong>st_info</strong></p>
<p>符号的binding和类型，binging有：</p>
<ul>
<li>STB_LOCAL：局部符号（仅当前文件可见）</li>
<li>STB_GLOBAL：全局符号（可导出/可被其他文件引用）</li>
<li>STB_WEAK：弱符号（可被同名全局符号覆盖）</li>
</ul>
<p>常见的类型有：</p>
<ul>
<li>STT_NOTYPE： 未定义类型</li>
<li>STT_FUNC： 函数类型、或其它可执行代码类型。</li>
<li>STT_OBJECT：数据对象类型</li>
<li>STT_SECTION： Section类型</li>
</ul>
<p><strong>st_other</strong></p>
<p>符号的可见性：</p>
<ul>
<li>STV_DEFAULT： 由符号的binding来决定。</li>
<li>STV_PROTECTED：符号对其他模块可见，但不能被重定义</li>
<li>STV_HIDDEN：符号对其他模块不可见，但在本模块内可用</li>
<li>STV_INTERNAL：内部可见性（保留，通常不用）</li>
</ul>
<h2 id="符号表">符号表</h2>
<p>符号存放在符号表中，其中.dynsym存放GLOBAL和WEAK类的符号、.symtab存放GLOBAL、WEAK、LOCAL符号。因此.dynsym是.symtab的一个子集。每个符号表都有与之对应的字符串池，如.shstrtab、.strtab。
使用命令<code>readelf --dyn-sym -W  libanative.so</code>
可以查看符号表中的符号信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf --dyn-sym -W  libanative.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 587 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)</span><br><span class="line">     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __register_atfork@LIBC (2)</span><br><span class="line">     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@LIBC (2)</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@LIBC (2)</span><br><span class="line">     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@LIBC (2)</span><br><span class="line">     7: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memmove@LIBC (2)</span><br><span class="line">     8: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memcpy@LIBC (2)</span><br><span class="line">     9: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memchr@LIBC (2)</span><br><span class="line">    10: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND memset@LIBC (2)</span><br><span class="line">    ...</span><br><span class="line">   532: 000000000001dc50    28 FUNC    GLOBAL DEFAULT   14 SayHello</span><br><span class="line">   ...    </span><br></pre></td></tr></table></figure>
也可以使用<code>readelf -s</code> 将.dynsym和.symtab中的符号都打印出来：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -s -W  libanative.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 587 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_finalize@LIBC (2)</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __cxa_atexit@LIBC (2)</span><br><span class="line">     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __register_atfork@LIBC (2)</span><br><span class="line">     4: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND printf@LIBC (2)</span><br><span class="line">     5: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@LIBC (2)</span><br><span class="line">     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND strlen@LIBC (2)</span><br><span class="line">...</span><br><span class="line">   292: 00000000000248a0     0 NOTYPE  LOCAL  DEFAULT   14 $x.170</span><br><span class="line">   293: 0000000000024a44     0 NOTYPE  LOCAL  DEFAULT   14 $x.171</span><br><span class="line">   294: 0000000000024b84     0 NOTYPE  LOCAL  DEFAULT   14 $x.172</span><br><span class="line">   295: 0000000000024cc4     0 NOTYPE  LOCAL  DEFAULT   14 $x.173</span><br><span class="line">   296: 0000000000024e04     0 NOTYPE  LOCAL  DEFAULT   14 $x.174</span><br><span class="line">   297: 0000000000012f74     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table129</span><br><span class="line">   298: 0000000000012f74     0 NOTYPE  LOCAL  DEFAULT   10 $d.175</span><br><span class="line">   299: 0000000000024fb4     0 NOTYPE  LOCAL  DEFAULT   14 $x.176</span><br><span class="line">   300: 0000000000012f8c     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table130</span><br><span class="line">   301: 0000000000012f8c     0 NOTYPE  LOCAL  DEFAULT   10 $d.177</span><br><span class="line">   302: 0000000000025164     0 NOTYPE  LOCAL  DEFAULT   14 $x.178</span><br><span class="line">   303: 0000000000012fa4     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table131</span><br><span class="line">   304: 0000000000012fa4     0 NOTYPE  LOCAL  DEFAULT   10 $d.179</span><br><span class="line">   305: 00000000000148a0     0 NOTYPE  LOCAL  DEFAULT   11 $d.180</span><br><span class="line">   306: 000000000002530c     0 NOTYPE  LOCAL  DEFAULT   14 $x.181</span><br><span class="line">   307: 0000000000012fbc     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table132</span><br><span class="line">   308: 0000000000012fbc     0 NOTYPE  LOCAL  DEFAULT   10 $d.182</span><br><span class="line">   309: 0000000000025510     0 NOTYPE  LOCAL  DEFAULT   14 $x.183</span><br><span class="line">   310: 0000000000012fec     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table133</span><br><span class="line">   311: 0000000000012fec     0 NOTYPE  LOCAL  DEFAULT   10 $d.184</span><br><span class="line">   312: 0000000000025710     0 NOTYPE  LOCAL  DEFAULT   14 $x.185</span><br><span class="line">   313: 000000000001301c     0 NOTYPE  LOCAL  DEFAULT   10 GCC_except_table134</span><br><span class="line">   314: 000000000001301c     0 NOTYPE  LOCAL  DEFAULT   10 $d.186</span><br><span class="line">   315: 0000000000025908     0 NOTYPE  LOCAL  DEFAULT   14 $x.187</span><br><span class="line">   316: 0000000000025940     0 NOTYPE  LOCAL  DEFAULT   14 $x.188     </span><br></pre></td></tr></table></figure> 可以看到.symtab中的符号的数量远比.dynsym
中的符号数量多的多，而多出来的符号只是用于调试，不会影响程序的正常运行。因此一般的release的动态库中，都会把
.symtab 给裁剪掉。所以局部符号是外部不可见的。</p>
<h2 id="hash表">Hash表</h2>
<p>我们知道dlsym等接口可以通过符号名查找符号的地址，这是如何实现的呢？</p>
<p>最简单的，我们可以通过Section Headers等信息，获取 .dynsym 或者
.symtab
的地址，然后遍历一下符号表中的所有符号，并匹配符号名即可。显然这种方式效率太低。</p>
<p>为了提升程序的加载速度和运行效率，ELF采用了hash查找方式，传入符号名，就可以通过hash算法算得符号在符号表中得index。</p>
<p>有两种hash表，分别为 .hash 和 .gnu_hash
，可以只存在一种，也可以同时存在两种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -S  libanative.so</span><br><span class="line">There are 34 section headers, starting at offset 0x1cf4d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .note.androi[...] NOTE             0000000000000238  00000238</span><br><span class="line">       0000000000000098  0000000000000000   A       0     0     4</span><br><span class="line">  [ 2] .note.gnu.bu[...] NOTE             00000000000002d0  000002d0</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 3] .dynsym           DYNSYM           00000000000002f8  000002f8</span><br><span class="line">       0000000000003708  0000000000000018   A       7     1     8</span><br><span class="line">  [ 4] .gnu.version      VERSYM           0000000000003a00  00003a00</span><br><span class="line">       0000000000000496  0000000000000002   A       3     0     2</span><br><span class="line">  [ 5] .gnu.version_r    VERNEED          0000000000003e98  00003e98</span><br><span class="line">       0000000000000040  0000000000000000   A       7     2     4</span><br><span class="line">// Hash表       </span><br><span class="line">  [ 6] .gnu.hash         GNU_HASH         0000000000003ed8  00003ed8</span><br><span class="line">       0000000000000e2c  0000000000000000   A       3     0     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           0000000000004d04  00004d04</span><br><span class="line">       000000000000484a  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .rela.dyn         RELA             0000000000009550  00009550</span><br><span class="line">       0000000000008838  0000000000000018   A       3     0     8</span><br><span class="line">  [ 9] .rela.plt         RELA             0000000000011d88  00011d88</span><br></pre></td></tr></table></figure>
<p>已GNU hash为例，大致算法实现如下：</p>
<ul>
<li>来自bionic libc:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker_soinfo.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span>* <span class="title function_">soinfo::find_symbol_by_name</span><span class="params">(SymbolName&amp; symbol_name,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> version_info* vi)</span> <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> is_gnu_hash() ? gnu_lookup(symbol_name, vi) : elf_lookup(symbol_name, vi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span>* <span class="title function_">soinfo::gnu_lookup</span><span class="params">(SymbolName&amp; symbol_name, <span class="type">const</span> version_info* vi)</span> <span class="type">const</span> &#123;</span><br><span class="line">     <span class="comment">// 先计算符号的HASH</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> hash = symbol_name.gnu_hash();</span><br><span class="line"></span><br><span class="line">  <span class="type">constexpr</span> <span class="type">uint32_t</span> kBloomMaskBits = <span class="keyword">sizeof</span>(ElfW(Addr)) * <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> word_num = (hash / kBloomMaskBits) &amp; gnu_maskwords_;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> bloom_word = gnu_bloom_filter_[word_num];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> h1 = hash % kBloomMaskBits;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> h2 = (hash &gt;&gt; gnu_shift2_) % kBloomMaskBits;</span><br><span class="line"></span><br><span class="line">  LD_DEBUG(lookup, <span class="string">&quot;SEARCH %s in %s@%p (gnu)&quot;</span>,</span><br><span class="line">           symbol_name.get_name(), get_realpath(), reinterpret_cast&lt;<span class="type">void</span>*&gt;(base));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// test against bloom filter</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="number">1</span> &amp; (bloom_word &gt;&gt; h1) &amp; (bloom_word &gt;&gt; h2)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先bloom筛选，加速</span></span><br><span class="line">  <span class="comment">// bloom test says &quot;probably yes&quot;...</span></span><br><span class="line">  <span class="type">uint32_t</span> n = gnu_bucket_[hash % gnu_nbucket_];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nullptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Versym)</span> verneed = find_verdef_version_index(this, vi);</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Versym)</span>* versym = get_versym_table();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ElfW(Sym)* s = symtab_ + n;</span><br><span class="line">    <span class="comment">// 计算出桶</span></span><br><span class="line">    <span class="keyword">if</span> (((gnu_chain_[n] ^ hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        check_symbol_version(versym, n, verneed) &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(get_string(s-&gt;st_name), symbol_name.get_name()) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        is_symbol_global_and_defined(this, s)) &#123;</span><br><span class="line">      <span class="keyword">return</span> symtab_ + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">  &#125; <span class="keyword">while</span> ((gnu_chain_[n++] &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算HASH, HASH算法如下：</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">SymbolName::gnu_hash</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_gnu_hash_) &#123;</span><br><span class="line">    gnu_hash_ = calculate_gnu_hash(name_).first;</span><br><span class="line">    has_gnu_hash_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gnu_hash_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title function_">calculate_gnu_hash</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_GNU_HASH_NEON</span></span><br><span class="line">  <span class="keyword">return</span> calculate_gnu_hash_neon(name);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">return</span> calculate_gnu_hash_simple(name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">__attribute__((unused))</span><br><span class="line"><span class="type">static</span> <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="type">uint32_t</span>, <span class="type">uint32_t</span>&gt; <span class="title function_">calculate_gnu_hash_simple</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> h = <span class="number">5381</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span>* name_bytes = reinterpret_cast&lt;<span class="type">const</span> <span class="type">uint8_t</span>*&gt;(name);</span><br><span class="line">  <span class="meta">#<span class="keyword">pragma</span> unroll 8</span></span><br><span class="line">  <span class="keyword">while</span> (*name_bytes != <span class="number">0</span>) &#123;</span><br><span class="line">    h += (h &lt;&lt; <span class="number">5</span>) + *name_bytes++; <span class="comment">// h*33 + c = h + h * 32 + c = h + h &lt;&lt; 5 + c</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; h, reinterpret_cast&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(name_bytes) - name &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的是，只有 .dynsym 有hash表， .symtab
是没有hash表只能遍历查找。</p>
<h1 id="重定位">重定位</h1>
<p>前文讲到调用外部函数时，会获取GOT表槽中的值作为地址然后跳转过去，而这个地址在编译时无法确定，所以运行时会被dynamic
linker设置位真正的函数地址。这个给GOT表设置真实地址的过程就叫做重定位。</p>
<h2 id="重定位信息">重定位信息</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">&#125; Elf64_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Addr	r_offset;		<span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword	r_info;			<span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword	r_addend;		<span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p><strong>r_offset</strong>
指向需要执行重定位操作的位置。如GOT表重定位的case下，这个值就是被需要被重定位的函数对应的GOT表Slot的相对地址。</p>
<ul>
<li><p>对于 ET_REL
类型的二进制文件，此值表示节（section）内的偏移量，即需要进行重定位的节内位置。</p></li>
<li><p>对于 ET_EXEC
类型的二进制文件，此值表示受重定位影响的虚拟地址。</p></li>
</ul>
<p><strong>r_info</strong>
同时提供了符号表索引（指明此次重定位所依据的符号）以及需要应用的重定位类型。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_R_SYM(i) ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_R_TYPE(i) ((i) &amp; 0xffffffff)</span></span><br></pre></td></tr></table></figure>
info中包含了类型、符号信息。其中符号就是上文提到的.dynsym表中的符号的索引。
重定位的类型有很多，arm64常见的有：</p>
<ul>
<li>R_AARCH64_JUMP_SLOT</li>
<li>R_AARCH64_GLOB_DAT</li>
<li>R_AARCH64_ABS64</li>
</ul>
<p>不同类型的重定位信息存储在不同的重定位表中。</p>
<p><strong>r_addend</strong>
指定一个常量加数，用于计算写入可重定位字段的最终值。</p>
<h2 id="重定位表">重定位表</h2>
<p>可以通过 <code>readelf -S libanative.so</code>
查看重定位表的信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -S libanative.so</span><br><span class="line">There are 34 section headers, starting at offset 0x1cf4d8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  ...   </span><br><span class="line">  [ 8] .rela.dyn         RELA             0000000000009550  00009550</span><br><span class="line">       0000000000008838  0000000000000018   A       3     0     8</span><br><span class="line">  [ 9] .rela.plt         RELA             0000000000011d88  00011d88</span><br><span class="line">       0000000000000b70  0000000000000018  AI       3    21     8</span><br><span class="line">  ...</span><br><span class="line">  [16] .data.rel.ro      PROGBITS         0000000000043c50  00042c50</span><br><span class="line">       00000000000030e0  0000000000000000  WA       0     0     8</span><br><span class="line">  [19] .dynamic          DYNAMIC          0000000000046d48  00045d48</span><br><span class="line">       00000000000001d0  0000000000000010  WA       7     0     8</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>其中.rela.plt
存放函数跳转相关的R_AARCH64_JUMP_SLOT类型的重定位信息。.rela.dyn存放非函数跳转相关的其他类型重定位信息。
可以通过<code>readelf -rW libanative.so</code>
工具重新打印重定位表。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -rW libanative.so</span><br><span class="line"></span><br><span class="line">Relocation section <span class="string">&#x27;.rela.dyn&#x27;</span> at offset 0x9550 contains 1453 entries:</span><br><span class="line">    Offset             Info             Type               Symbol<span class="string">&#x27;s Value  Symbol&#x27;</span>s Name + Addend</span><br><span class="line">0000000000043c50  0000000000000403 R_AARCH64_RELATIVE                        43c50</span><br><span class="line">0000000000043c60  0000000000000403 R_AARCH64_RELATIVE                        43cc0</span><br><span class="line">0000000000043c68  0000000000000403 R_AARCH64_RELATIVE                        2ab48</span><br><span class="line">0000000000043c70  0000000000000403 R_AARCH64_RELATIVE                        2ab54</span><br><span class="line">...</span><br><span class="line">0000000000048458  0000000000000403 R_AARCH64_RELATIVE                        48f20</span><br><span class="line">0000000000046fa0  0000002700000401 R_AARCH64_GLOB_DAT     0000000000000000 __sF@LIBC + 0</span><br><span class="line">0000000000046aa8  0000004500000101 R_AARCH64_ABS64        0000000000046ac8 _ZTISt12length_error + 0</span><br><span class="line">0000000000046f18  0000004500000401 R_AARCH64_GLOB_DAT     0000000000046ac8 _ZTISt12length_error + 0</span><br><span class="line">0000000000046088  0000004600000101 R_AARCH64_ABS64        00000000000163b2 _ZTSs + 0</span><br><span class="line">00000000000460d8  0000004900000101 R_AARCH64_ABS64        00000000000163bb _ZTSt + 0</span><br><span class="line">0000000000046598  0000004a00000101 R_AARCH64_ABS64        000000000001644b _ZTSPDs + 0</span><br><span class="line">0000000000047010  0000004b00000401 R_AARCH64_GLOB_DAT     0000000000046bf8 _ZTVSt8bad_cast</span><br><span class="line">...</span><br><span class="line">Relocation section <span class="string">&#x27;.rela.plt&#x27;</span> at offset 0x11d88 contains 122 entries:</span><br><span class="line">    Offset             Info             Type               Symbol<span class="string">&#x27;s Value  Symbol&#x27;</span>s Name + Addend</span><br><span class="line">0000000000047038  0000000100000402 R_AARCH64_JUMP_SLOT    0000000000000000 __cxa_finalize@LIBC + 0</span><br><span class="line">0000000000047040  0000000200000402 R_AARCH64_JUMP_SLOT    0000000000000000 __cxa_atexit@LIBC + 0</span><br><span class="line">0000000000047048  0000000300000402 R_AARCH64_JUMP_SLOT    0000000000000000 __register_atfork@LIBC + 0</span><br><span class="line">0000000000047050  0000021400000402 R_AARCH64_JUMP_SLOT    000000000001dc50 SayHello + 0</span><br><span class="line">0000000000047058  0000000400000402 R_AARCH64_JUMP_SLOT    0000000000000000 <span class="built_in">printf</span>@LIBC + 0</span><br></pre></td></tr></table></figure>
<p>上图表中：</p>
<ul>
<li>Offset,对应Elf64_Rela中的r_offset字段。</li>
<li>Info,对应Elf64_Rela中的r_info字段。</li>
<li>Type,对应r_info中的重定位类型信息。</li>
<li>Symbol’s Value,对对应r_info中计算出的符号地址信息。</li>
<li>Symbol’s Name + Addend，对应r_info中查找符号表的符号名信息。
通过上面的打印，不难发现：，除了外部符号（Symbol’s
Value等于0）外，很多内部符号也需要重新定位。</li>
</ul>
<h2 id="重定位过程">重定位过程</h2>
<h3 id="r_aarch64_jump_slot">R_AARCH64_JUMP_SLOT</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bionic linker_info.h</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">soinfo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">soinfo</span>(<span class="type">android_namespace_t</span>* ns, <span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="keyword">struct</span> stat* file_stat,</span><br><span class="line">         <span class="type">off64_t</span> file_offset, <span class="type">int</span> rtld_flags);</span><br><span class="line">  ~<span class="built_in">soinfo</span>();</span><br><span class="line"> soinfo* next;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">relocate</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list)</span></span>;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soinfo::relocate</span><span class="params">(<span class="type">const</span> SymbolLookupList&amp; lookup_list)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">packed_relocate</span>&lt;RelocMode::Typical&gt;(relocator, <span class="built_in">sleb128_decoder</span>(packed_relocs, packed_relocs_size))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode OptMode, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">packed_relocate</span><span class="params">(Relocator&amp; relocator, Args ...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">needs_slow_relocate_loop</span>(relocator) ?</span><br><span class="line">      <span class="built_in">packed_relocate_impl</span>&lt;RelocMode::General&gt;(relocator, args...) :</span><br><span class="line">      <span class="built_in">packed_relocate_impl</span>&lt;OptMode&gt;(relocator, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">packed_relocate_impl</span><span class="params">(Relocator&amp; relocator, sleb128_decoder decoder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> for_all_packed_relocs(decoder, [&amp;](<span class="type">const</span> <span class="type">rel_t</span>&amp; reloc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process_relocation</span>&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">process_relocation</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Mode == RelocMode::General ?</span><br><span class="line">      <span class="built_in">process_relocation_general</span>(relocator, reloc) :</span><br><span class="line">      <span class="built_in">process_relocation_impl</span>&lt;Mode&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_general</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">process_relocation_impl</span>&lt;RelocMode::General&gt;(relocator, reloc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (__aarch64__)</span></span><br><span class="line">....</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R_GENERIC_JUMP_SLOT     R_AARCH64_JUMP_SLOT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line">  <span class="comment">// 计算出 r_offse的真实虚拟地址 = 基地址（load_bias) +  r_offset</span></span><br><span class="line">    <span class="type">void</span>* <span class="type">const</span> rel_target = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">      relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(reloc.r_offset + relocator.si-&gt;load_bias));</span><br><span class="line">  <span class="comment">// 存放该符号，对应的地址    </span></span><br><span class="line">   <span class="built_in">ElfW</span>(Addr) sym_addr = <span class="number">0</span>;   </span><br><span class="line">   ... </span><br><span class="line">    <span class="keyword">if</span> (r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">lookup_symbol</span>&lt;IsGeneral&gt;(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (sym != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">bool</span> should_protect_segments = handle_text_relocs &amp;&amp;</span><br><span class="line">                                             found_in == relocator.si &amp;&amp;</span><br><span class="line">                                             <span class="built_in">ELF_ST_TYPE</span>(sym-&gt;st_info) == STT_GNU_IFUNC;</span><br><span class="line">        <span class="keyword">if</span> (should_protect_segments &amp;&amp; !<span class="built_in">protect_segments</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 寻找到与符号对应的外部函数地址</span></span><br><span class="line">        sym_addr = found_in-&gt;<span class="built_in">resolve_symbol_address</span>(sym);</span><br><span class="line">     &#125;</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsGeneral || Mode == RelocMode::JumpTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里R_GENERIC_JUMP_SLOT在arm64平台就是R_AARCH64_JUMP_SLOT</span></span><br><span class="line">    <span class="keyword">if</span> (r_type == R_GENERIC_JUMP_SLOT) &#123;</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="comment">// 将寻找到的函数地址，赋值给符号信息中r_offset对应的地址</span></span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + get_addend  _norel();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO JMP_SLOT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="r_aarch64_glob_dat">R_AARCH64_GLOB_DAT</h2>
<p>这类是全局变量的地址。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linker_relocate.cpp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R_GENERIC_GLOB_DAT      R_AARCH64_GLOB_DAT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RelocMode Mode&gt;</span><br><span class="line">__attribute__((always_inline))</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">process_relocation_impl</span><span class="params">(Relocator&amp; relocator, <span class="type">const</span> <span class="type">rel_t</span>&amp; reloc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">bool</span> IsGeneral = Mode == RelocMode::General;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* <span class="type">const</span> rel_target = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(</span><br><span class="line">      relocator.si-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(reloc.r_offset + relocator.si-&gt;load_bias));</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_type = <span class="built_in">ELFW</span>(R_TYPE)(reloc.r_info);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> r_sym = <span class="built_in">ELFW</span>(R_SYM)(reloc.r_info);</span><br><span class="line"></span><br><span class="line">  soinfo* found_in = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span>* sym </span>= <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* sym_name = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">ElfW</span>(Addr) sym_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (r_type == R_GENERIC_ABSOLUTE) &#123;</span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_rel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO ABSOLUTE %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_GLOB_DAT) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">count_relocation_if</span>&lt;IsGeneral&gt;(kRelocAbsolute);</span><br><span class="line">      <span class="keyword">if</span> (found_in) sym_addr = found_in-&gt;<span class="built_in">apply_memtag_if_mte_globals</span>(sym_addr);</span><br><span class="line">      <span class="comment">// 将寻找到的地址，赋值给reloc.r_offset对应的虚拟地址</span></span><br><span class="line">      <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Addr)</span> result </span>= sym_addr + <span class="built_in">get_addend_norel</span>();</span><br><span class="line">      <span class="built_in">LD_DEBUG</span>(reloc &amp;&amp; IsGeneral, <span class="string">&quot;RELO GLOB_DAT %16p &lt;- %16p %s&quot;</span>,</span><br><span class="line">               rel_target, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(result), sym_name);</span><br><span class="line">      *<span class="built_in">static_cast</span>&lt;<span class="built_in">ElfW</span>(Addr)*&gt;(rel_target) = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r_type == R_GENERIC_RELATIVE) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="r_aarch64_relative">R_AARCH64_RELATIVE</h2>
<p>基址修正、无外部符号依赖。即它的重定位不依赖符号解析。计算方式： B +
A;</p>
<h2 id="r_aarch64_abs64">R_AARCH64_ABS64</h2>
<p>64
位绝对地址重定位，需要符号解析。常见于需要存放全局变量或函数的真实指针的场景。计算方式：B
+ S;</p>
<h1 id="dynamic段">Dynamic段</h1>
<p>Phdr中的LOAD和GNU_RELRO只负责动态库的地址映射。而Sections
Header中信息主要都存入了dynamic段，它包含了linker需要的大多数信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -l libanative.so</span><br><span class="line"></span><br><span class="line">Elf file <span class="built_in">type</span> is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R      0x8</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000042c50 0x0000000000042c50  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000037b8  RW     0x1000</span><br><span class="line">  LOAD           0x0000000000046408 0x0000000000048408 0x0000000000048408</span><br><span class="line">                 0x0000000000000058 0x0000000000000b18  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000045d48 0x0000000000046d48 0x0000000000046d48</span><br><span class="line">                 0x00000000000001d0 0x00000000000001d0  RW     0x8</span><br><span class="line">  GNU_RELRO      0x0000000000042c50 0x0000000000043c50 0x0000000000043c50</span><br><span class="line">                 0x00000000000037b8 0x00000000000043b0  R      0x1</span><br><span class="line">  GNU_EH_FRAME   0x0000000000016b0c 0x0000000000016b0c 0x0000000000016b0c</span><br><span class="line">                 0x0000000000001534 0x0000000000001534  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x0</span><br><span class="line">  NOTE           0x0000000000000238 0x0000000000000238 0x0000000000000238</span><br><span class="line">                 0x00000000000000bc 0x00000000000000bc  R      0x4</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .note.android.ident .note.gnu.build-id .dynsym .gnu.version .gnu.version_r .gnu.hash .dynstr .rela.dyn .rela.plt .gcc_except_table .rodata .eh_frame_hdr .eh_frame .text .plt</span><br><span class="line">   02     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   03     .data .bss</span><br><span class="line">   04     .dynamic</span><br><span class="line">   05     .data.rel.ro .fini_array .init_array .dynamic .got .got.plt</span><br><span class="line">   06     .eh_frame_hdr</span><br><span class="line">   07</span><br><span class="line">   08     .note.android.ident .note.gnu.build-id</span><br></pre></td></tr></table></figure>
<p>.dynamic也是一个表，每个表项的结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Sxword	d_tag;			<span class="comment">/* Dynamic entry type */</span></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      Elf64_Xword d_val;		<span class="comment">/* Integer value */</span></span><br><span class="line">      Elf64_Addr d_ptr;			<span class="comment">/* Address value */</span></span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>
<p><strong>d_tag</strong></p>
<ul>
<li>DT_NEEDED,依赖的共享库名（索引到字符串表）</li>
<li>DT_SYMTAB,指向符号表</li>
<li>DT_HASH,符号哈希表，用于快速符号查找</li>
<li>DT_STRTAB,指向字符串表，用于存储库名、符号名</li>
<li>DT_PLTGOT,PLT/GOT 表地址</li>
<li>SONAME,当前动态库名称的索引，索引是相对于.dynstr表的偏移</li>
<li>SYMTAB,.dynsym表起始地址</li>
<li>SYMENT,.dynsym表表项大小</li>
<li>STRTAB,.dynstr表起始地址</li>
<li>STRSZ,.dynstr表的字节数大小</li>
<li>INIT_ARRAY .init_array表的起始地址</li>
<li>.INIT_ARRAYSZ .init_array表的字节数大小</li>
</ul>
<p><strong>d_val</strong>
保存一个整数值，其含义视具体情况而定，例如可以表示单个重定位条目的大小等。
<strong>d_ptr</strong>
保存一个虚拟内存地址，可指向链接器所需的各种位置；一个典型示例是，当
d_tag 为 DT_SYMTAB 时，它指向符号表的地址。</p>
<p>执行<code>arm64-v8a readelf -d libanative.so</code> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">➜  arm64-v8a readelf -d libanative.so</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0x45d48 contains 29 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [liblog.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libm.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so]</span><br><span class="line"> 0x000000000000000e (SONAME)             Library soname: [libanative.so]</span><br><span class="line"> 0x000000000000001e (FLAGS)              BIND_NOW</span><br><span class="line"> 0x000000006ffffffb (FLAGS_1)            Flags: NOW</span><br><span class="line"> 0x0000000000000007 (RELA)               0x9550</span><br><span class="line"> 0x0000000000000008 (RELASZ)             34872 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffff9 (RELACOUNT)          989</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x11d88</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           2928 (bytes)</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x47020</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x2f8</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x4d04</span><br><span class="line"> 0x000000000000000a (STRSZ)              18506 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x3ed8</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x46d40</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x46d30</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       16 (bytes)</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x3a00</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x3e98</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         2</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure>
可见.dynamic 和Section Headers类似，指向的是参与动态链接的Sections</p>
<h1 id="参考">参考</h1>
<p>https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-48031.html#scrolltoc</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://blueberrycoder.github.io/2025/08/25/graphic/colormodel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="blueberry">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Keep learning">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Keep learning">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/25/graphic/colormodel/" class="post-title-link" itemprop="url">色彩模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-08-25 20:02:24" itemprop="dateCreated datePublished" datetime="2025-08-25T20:02:24+08:00">2025-08-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-11-02 17:51:45" itemprop="dateModified" datetime="2025-11-02T17:51:45+08:00">2025-11-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/graphic/" itemprop="url" rel="index"><span itemprop="name">graphic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="光谱">光谱</h1>
<p>1666年牛顿发现太阳光经三棱镜的折射后可呈现彩色光，称为光的色散现象。</p>
<p><img src="/images/graphic/color_newton.png" alt="newton" width="600">
由牛顿的色散实验结果，可知白光是由多种颜色的光所组成。太阳光呈白色，当它通过三棱镜被折射后，将形成由红、橙、黄、绿、蓝、靛、紫（或红、橙、黄、绿、青、蓝、紫）顺次连续分布的彩色光谱，覆盖了大约在390到770纳米的可见光区。</p>
<p><img src="/images/graphic/color_spectrum.png" alt="spd" width="600"></p>
<h2 id="spd谱功率密度">SPD(谱功率密度)</h2>
<p>可以用谱功率密度（Spectral Power
Distribution）用来描述光。SPD用来描述单位光在不同波长之间的能量分布，它的单位是辐射度单位/波长，例如(watts/nm)。</p>
<blockquote>
<p>Note: In radiometry, photometry, and color science, a spectral power
distribution (SPD) measurement describes the power per unit area per
unit wavelength of an illumination (radiant exitance).</p>
<p>power 为单位时间内的能量，单位为watt。即</p>
</blockquote>
<p>比如下面这幅图中，太阳部分光线的SPD和蓝天部分的SPD如下：</p>
<p><img src="/images/graphic/color_eg_spd.png" alt="spd" width="600">
再如下图不同光的不同的SPD:
<img src="/images/graphic/color_spd2.png" alt="spd" width="600"></p>
<h2 id="线性性质">线性性质</h2>
<p>SPD具有线性性质，比如蓝色和黄色的光加起来得到的SPD，就是蓝色光和黄色光分别的SPD相加。
<img src="/images/graphic/color_spd_linear.png" alt="spd" width="600"></p>
<h1 id="什么是颜色">什么是颜色？</h1>
<p>颜色是人眼感知得到的，它并不是光的一种物理属性。不同波长的光也不是颜色。</p>
<h2 id="人眼的结构">人眼的结构</h2>
<p>颜色的结构类似一个摄像机，光线通过晶状体聚焦子视网膜上，视网膜再将收到的光信号转化为发送给大脑的电信号。</p>
<p><img src="/images/graphic/color_eye.png" alt="spd" width="600">
人眼有大约1200万的视干细胞，它们能给大脑提供亮度信息，600～700万左右的视锥细胞，它们能给大脑提供颜色信息。（从这个数量上我们也能看出来，人眼对亮度信息更敏感）。</p>
<p><img src="/images/graphic/color_eye_cones.png" alt="spd" width="600">
视锥细胞也可以分为三种：S型、M型、L型，它们对不同波长的响应强度如下：
<img src="/images/graphic/color_cone_resp.png" alt="spd" width="600">
下图是从12个不同人中统计的视觉细胞的类型分布，注意不同类型视锥细胞的比例存在高度差异。这也就是说，不同的人感知到的颜色其实是有很大差异的（每个人的看到的世界是不一样的🐶）。
<img src="/images/graphic/color_cones_distribute.png" alt="spd" width="600"></p>
<h1 id="三色理论">三色理论</h1>
<p>了解以上理论支持，人们就可以用一种数学模型来描述人眼对光的感知。人眼感知到的光的能量等于人眼的三种细胞对不同波长的强度乘以光源的SPD中不同波长的强度然后相加，可以用如下数学公式描述：</p>
<p><img src="/images/graphic/color_spd_cones.png" alt="spd" width="600"></p>
<h2 id="同色异谱">同色异谱</h2>
<p>由以上的数学定义，我们可以得出对于人眼感知到的颜色，光源其实可以拥有不同的频谱。（只要保证最后积分和的结果是一致的就行）。
如下图中，4张不同的频谱，最终人眼感知到的能量是一样的。
<img src="/images/graphic/color_metamerism.png" alt="spd" width="600">
下图中2个太阳的频谱虽然不同，但是最终人眼感知到的是一样的。
<img src="/images/graphic/color_sunlight.png" alt="spd" width="600"></p>
<h1 id="加色模型">加色模型</h1>
<p>如图，我们可以用三个信号，它们的SPD分别为：sR(λ), sG(λ),
sB(λ)来表示三种原始光，我们分别调节不同原始光的强度就可以得到不同的颜色。最终的到的颜色为：R
sR(λ) + G sG(λ) + B sB(λ)， R,G,B代表它们的强度。</p>
<p><img src="/images/graphic/color_rgb_additive.png" alt="spd" width="600"></p>
<h2 id="cie-rgb匹配函数">CIE RGB匹配函数</h2>
<p>CIE通过用以下3个原色的光做实验，得到一个颜色匹配函数。
<img src="/images/graphic/color_cie_primary.png" alt="spd" width="600">
颜色匹配函数如下，对于任意的频谱，人眼感知到到的颜色能通过这个函数的到人眼感知到的颜色（定义在CIE
RGB中的颜色）
<img src="/images/graphic/color_cie_rgb.png" alt="spd" width="600"></p>
<blockquote>
<p>在匹配函数中有负数的情况，这种可以在实验时向目标色加一个红色强度的光来实现，即实现了对原色的减法。</p>
</blockquote>
<h1 id="颜色空间">颜色空间</h1>
<p>色彩模型（color
model）是用一组数组（每个颜色用3个或4个数字来表示）来描述颜色的数学模型。</p>
<h1 id="cie-xyz">CIE XYZ</h1>
<p>CIE
XYZ中定义的X、Y、Z是并不存在的颜色。其中Y是表示的亮度(luminance)，另外2个是颜色相关的虚拟量。这个定义消除了负数的情况。
<img src="/images/graphic/color_cie_xyz.png" alt="spd" width="600"></p>
<blockquote>
<p>CIE在1931年定义了新的三刺激系统X,Y,Z，它是实验RGB的线性变换
https://en.wikipedia.org/wiki/CIE_1931_color_space</p>
</blockquote>
<video src="/videos/graphic/Visible_gamut_within_CIEXYZ_color_space_D65_whitepoint_mesh.webm.480p.vp9.webm" controls style="max-width: 100%; border-radius: 12px;">
</video>
<blockquote>
<p>更多色彩空间几何模型可以参考： <a
target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Visible_gamut_within_CIEXYZ_color_space_D65_whitepoint_mesh.webm"
class="uri">https://commons.wikimedia.org/wiki/File:Visible_gamut_within_CIEXYZ_color_space_D65_whitepoint_mesh.webm</a></p>
</blockquote>
<h2 id="色域">色域</h2>
<p>为了让我们更好的在二维平面中展示CIE
XYZ，通过以下手段将三维的颜色空间显示在了二维平面。人眼能看见的颜色就是下图的这个马蹄形状。
它通过统一亮度Y，然后对X、Y、Z归一化，然后通过下面的数学公式得到x,y,z，因为x、y、z满足x+y+z=1所以我们可以在二维平面呈现这个颜色空间。</p>
<p><img src="/images/graphic/color_cie_gamut.png" alt="spd" width="720"></p>
<p>下图是一些常见的色彩空间的色域图：</p>
<p><img src="/images/graphic/color_gamut.png" alt="spd" width="720"></p>
<blockquote>
<p>CIE XYZ
是绝对色彩空间。它直接描述光的“物理能量分布”，是绝对的参考空间。
色温指的是一个理想“黑体”在某个温度下发出的光的颜色。
sRGB中D65定义为6504k，为显示器标准白光。</p>
</blockquote>
<h2 id="颜色是相对的">颜色是相对的</h2>
<p>观察下面的图：
<img src="/images/graphic/color_eg_relative0.png" alt="spd" width="720"></p>
<p><img src="/images/graphic/color_eg_relative1.png" alt="spd" width="720">
你能看出黄色是一致的吗？（你的大脑一直在欺骗你🐶）</p>
<p>再例如下图，请盯着中间的十字一致看。
<img src="/images/graphic/optic_pink_circle.gif" width="720"></img></p>
<p>你否是看到了一个绿色小球在转动？</p>
<h1 id="rgb色彩模型">RGB色彩模型</h1>
<p>RGB色彩模型是由红(R)、绿(G)、蓝(B)组成的一种加法颜色模型。它是我们在电视机、计算机中种常用的颜色模型。RGB色彩模型是一种设备依赖(device-dependent)的色彩模型，不同的设备因为厂商有不同的物理实现（比如：使用不同的荧光粉、不同的染料），所提供的红、绿、蓝的实现等级不一样，甚至同一台设备随着时间推移老化提供出的颜色也不是不一样的。所以如果没有色彩管理(color
management)，不同的设备将不能提供出一致的颜色。</p>
<h2 id="加法颜色模型">加法颜色模型</h2>
<p>要用RGB生成一个颜色，需要将3种基础颜色（红、绿、蓝）叠加在一起（如：可以通过发射出3种光线直接进入人眼、或在白纸上照射3种光，通过反射进入人眼）。每束基础光都有自己的强度，假设从（0.0
到 1.0），混合在一起形成一种颜色。</p>
<p><img src="/images/graphic/color_model_rgb.png" alt="RGB加法" width="360"></p>
<p>从上面这幅图我们可以看出，红、绿、蓝可以叠加成白色、红和绿可以叠加成黄色、红和蓝可以叠加成品红色、绿和蓝可以叠加成蓝绿色。
我们把这3个基础色也称之为颜色的分量。如果所有的分量（基础颜色）的强度都为0，我们将只能得到黑色。如果所有的分量都为1我们将得到白色，该点也是该颜色系统的白点(white
point)。当所有分量的强度都相等时，我们得到是一种灰色，强度越低颜色越暗，强度越高颜色越亮。当所有分量强度不同时，我们将得到具有色相的颜色；其饱和度取决于所用原色中最强与最弱分量强度之间的差异——差异越大，饱和度越高；差异越小，饱和度越低。</p>
<p>RGB色彩模型并没有规定红、绿、蓝具体的实现、即没有定义原色本身是什么（比如它相对于人眼感知到的结果有多红？、有多蓝？、有多绿？、强度分布是怎么样的？）。所以它是一种相对的色彩空间。只有当红、绿、蓝这3种基础颜色并精准定义后，这个颜色空间才会变为绝对颜色空间，如sRGB，AdobeRGB。</p>
<p>原色的选择与人眼的生理结构有关，“良好”的原色的定义应当是能最大化人眼视锥细胞对不同波长的影响差异（在色度图中形成更大的颜色三家形）。人眼中正常的三类对光敏感的感光受体（锥体细胞）分别对黄色（长波，L）、绿色（中波，M）和紫色（短波，S）光最为敏感（各自的峰值波长分别约为
570 nm、540 nm 和 440
nm）。三类受体所接收到信号的差异，使得大脑能够区分非常广泛的颜色范围；总体上，人眼对黄绿色光以及绿到橙区间的色相差异最为敏感。</p>
<p><img src="/images/graphic/color_cone_cell_resp.png" alt="cone" width="360"></p>
<p>仅使用三种原色并不足以复现所有颜色；只有位于由三原色色度所定义的颜色三角形内的那些颜色，才能通过对这三种光进行加法混合加以再现。</p>
<p>如图，是sRGB颜色模型在色域图中的分布。</p>
<p><img src="/images/graphic/color_srgb.png" alt="sRGB" width="360"></p>
<h2 id="rgb设备">RGB设备</h2>
<p>常见的RGB显示设备有：阴极射线管(CRT)、液晶显示（LCD）、OLED等设备。屏幕上的每个像素由三个微小、彼此非常接近但仍相互独立的
RGB
发光单元驱动构成。在通常的观看距离下，这些独立的光源不可分辨，人的眼睛会把它们感知为某一种均匀的颜色。所有像素在矩形屏幕表面共同排列，便构成了彩色图像。在数字图像处理过程中，每个像素都可以在计算机内存或接口硬件（例如显卡）中，用红、绿、蓝三个颜色分量的二进制数值来表示。经过适当的管理，这些数值会通过伽马校正转换为电流或电压，以校正某些设备固有的非线性，从而在显示设备上再现预期的亮度/强度。</p>
<p>CRT显示：</p>
<p><img src="/images/graphic/color_crt_tv.webp" alt="crt" width="360"></p>
<p>LCD显示设备：</p>
<p><img src="/images/graphic/color_lcd.jpg" alt="lcd" width="360"></p>
<h3 id="打包格式">打包格式</h3>
<p>设备内存中存储常用RGBA_8888、RGB_888、RGB_565等来存储RGB颜色。RGB_888即R、G、B的强度分别用8位二进制来表示。在这种体系下，允许16,777,216（256³
或 2²⁴） 种离散的 R、G、B
组合。为增加明暗层次，人们采用了多种做法；一些格式（如 .png、.tga
等）会使用第四个灰度颜色通道作为遮罩层，通常称为 RGB32（即带有额外通道的
RGB），在内存中的一般为RGBA_8888格式。RGB_565适用越内存比较紧张的场景、即用5位二进制表示红色和蓝色，用6位二进制来表示绿色（颜色对绿色比较敏感）。</p>
<h2 id="几何表示">几何表示</h2>
<p>由于颜色通常由三个分量来定义——不仅在 RGB 模型中如此，在诸如
CIELAB、Y’UV
等其他色彩模型中也是如此——因此可以把这些分量值视作欧氏空间中的普通笛卡尔坐标，从而描述一个三维体积。对
RGB 模型而言，这对应于一个使用 0–1 非负取值的立方体：将黑色赋予位于顶点
(0, 0, 0) 的原点，沿三条坐标轴分量强度递增，直到对角顶点 (1, 1, 1)
的白色。 一个 RGB 三元组 (r, g, b)
表示该颜色在立方体（或其面、棱）中的三维坐标。这样一来，只需计算两种 RGB
颜色之间的距离就能评估它们的颜色相似度：距离越短，相似度越高。超出色域的计算也可以用这种方式进行。</p>
<p><img src="/images/graphic/color_rgb_cube.png" alt="rgb_cube" width="360"></p>
<h1 id="yuv色彩模型">YUV色彩模型</h1>
<p>Y′UV（也写作 YUV）是模拟彩色电视标准中采用的色彩模型。一种颜色用一个
Y′ 分量（亮度信号，luma）和两个色度分量 U、V
来描述。撇号（′）表示这个亮度Y′是从经过伽马校正的RGB输入计算得到的，因此与真实的亮度（luminance）不同。如今，在计算机行业中，“YUV”这一术语常被用来泛指以
YCbCr 编码的各种色彩空间。</p>
<p>在电视制式里，色彩信息（U与V）通过副载波单独加入，这样黑白电视机也能接收并以其原生的黑白方式显示彩色节目的传输，而无需额外的传输带宽。</p>
<p>Y′UV是在工程师们希望在黑白电视基础设施上实现彩色电视时发明的。他们需要一种既兼容黑白电视、又能加入色彩的传输方式。亮度分量（Y′）本就作为黑白信号而存在；他们在此基础上加入
U、V 色度信号作为解决方案。 之所以选用 U、V 来表示色度，而不是直接传输
R、B，是因为 U、V 是色差信号。换言之，U、V
告诉电视机在不改变亮度的情况下把某一点的颜色偏移到何处，或者以此消彼长地调整两种原色的相对亮度，以及应偏移多少。当
U、V 值越高（或为负时数值越低），该点就越饱和（更“有色”）；当 U、V
越接近
0，色偏越小，意味着红、绿、蓝的亮度更为均衡，产生更灰的外观。这就是使用色差信号的好处：与其直接说明某颜色里“有多少红”，不如说明它“比绿或蓝多多少红”。
由此可知，当 U、V 为 0 或不存在时，显示的就是灰度图像。若当初采用的是
R、B
信号，那么即使在黑白场景中它们也不会为零，于是仍需三路数据承载。这一点在彩色电视的早期尤为重要：旧式黑白电视信号不包含
U、V，彩电直接按黑白方式显示即可。另一方面，黑白接收机可以取用 Y′，忽略
U、V，使 Y′UV 与既有黑白设备（输入与输出）向后兼容。</p>
<h2 id="与rgb的转换">与RGB的转换</h2>
<p>Y′UV 信号通常由经过伽马校正的RGB（红、绿、蓝）做为源生成。先对
R、G、B 设定权重并求和得到 Y′，它表示整体亮度（luma/近似于
luminance）。随后将 U、V 计算为 B、R 与 Y′
的差值按比例缩放后的结果。</p>
<h3 id="itu-r-bt.601-转换">ITU-R BT.601 转换</h3>
<p>用于标清电视（SDTV）的Y′CbCr形式由 ITU-R BT.601（原 CCIR
601）为数字分量视频定义，其来源是相应的 RGB 空间（ITU-R BT.470-6 System
M 的原色）。常数为： <span
class="math display"><em>K</em><sub><em>R</em></sub> = 0.299,  <em>K</em><sub><em>G</em></sub> = 0.587,  <em>K</em><sub><em>B</em></sub> = 0.114.</span>
由上述常数与公式，可推得 BT.601 下的关系。</p>
<h4 id="rgb转yuv">RGB转YUV</h4>
<p><strong>模拟信号R′G′B′转模拟 YPbPr</strong> <span
class="math display">$$
\begin{aligned}
Y'  &amp;= 0.299\,R' + 0.587\,G' + 0.114\,B',\\
P_B &amp;= -0.168736\,R' - 0.331264\,G' + 0.5\,B',\\
P_R &amp;= \phantom{-}0.5\,R' - 0.418688\,G' - 0.081312\,B'.
\end{aligned}
$$</span> 矩阵形式为： <span class="math display">$$
\begin{bmatrix}
Y' \\[6pt]
P_B \\[6pt]
P_R
\end{bmatrix}
=
\begin{bmatrix}
0.299 &amp; 0.587 &amp; 0.114 \\
-0.168736 &amp; -0.331264 &amp; 0.5 \\
0.5 &amp; -0.418688 &amp; -0.081312
\end{bmatrix}
\begin{bmatrix}
R' \\[6pt]
G' \\[6pt]
B'
\end{bmatrix}
$$</span></p>
<h4 id="逆变换">逆变换</h4>
<p><strong>模拟信号YUV转RGB</strong> <span class="math display">$$
\begin{bmatrix}
R'\\ G'\\ B'
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0 &amp; 1.402\\
1 &amp; -0.344136 &amp; -0.714136\\
1 &amp; 1.772 &amp; 0
\end{bmatrix}
\begin{bmatrix}
Y'\\ P_B\\ P_R
\end{bmatrix}
$$</span></p>
<p><strong>模拟 R′G′B′转数字 Y′CbCr（每分量 8 位）：</strong> <span
class="math display">$$
\begin{aligned}
Y'  &amp;= 16 + \bigl(65.481\,R' + 128.553\,G' + 24.966\,B'\bigr),\\
C_B &amp;= 128 + \bigl(-37.797\,R' - 74.203\,G' + 112.0\,B'\bigr),\\
C_R &amp;= 128 + \bigl(112.0\,R' - 93.786\,G' - 18.214\,B'\bigr).
\end{aligned}
$$</span> 矩阵形式（带偏置项）：</p>
<p><span class="math display">$$
\begin{bmatrix}
Y' \\[6pt]
C_B \\[6pt]
C_R
\end{bmatrix}
=
\begin{bmatrix}
65.481 &amp; 128.553 &amp; 24.966 \\
-37.797 &amp; -74.203 &amp; 112.0 \\
112.0 &amp; -93.786 &amp; -18.214
\end{bmatrix}
\begin{bmatrix}
R' \\[6pt]
G' \\[6pt]
B'
\end{bmatrix}
+
\begin{bmatrix}
16 \\[6pt]
128 \\[6pt]
128
\end{bmatrix}
$$</span></p>
<p>此种 Y′CbCr 形式主要用于较早的标清电视系统，其所用 RGB 模型贴合老式
CRT 荧光粉的发光特性。</p>
<h3 id="itu-r-bt.709-转换">ITU-R BT.709 转换</h3>
<p>ITU-R
BT.709标准为HDTV主要指定了另一种形式的Y′CbCr。这种较新的形式也用于一些面向计算机显示的应用，在BT.709中，常数
<span class="math inline"><em>K</em><sub><em>b</em></sub></span> 与
<span class="math inline"><em>K</em><sub><em>r</em></sub></span>
的取值不同，但使用它们的公式相同。对BT.709，有： <span
class="math display"><em>K</em><sub><em>B</em></sub> = 0.0722,  <em>K</em><sub><em>R</em></sub> = 0.2126,  <em>K</em><sub><em>G</em></sub> = 1 − <em>K</em><sub><em>B</em></sub> − <em>K</em><sub><em>R</em></sub> = 0.7152.</span>
这种 Y′CbCr
形式所基于的RGB模型更贴合较新CRT及其他现代显示设备的荧光粉发光特性。</p>
<h4 id="rgb转yuv-1">RGB转YUV</h4>
<p><strong>模拟R′G′B′转模拟 YPbPr：</strong> <span
class="math display">$$
\begin{bmatrix}
Y'\\ C_B\\ C_R
\end{bmatrix}
=
\begin{bmatrix}
0.2126 &amp; 0.7152 &amp; 0.0722\\
-0.09991 &amp; -0.33609 &amp; 0.436\\
0.615 &amp; -0.55861 &amp; -0.05639
\end{bmatrix} \\
\begin{bmatrix}
R'\\ G'\\ B'
\end{bmatrix}
$$</span></p>
<h4 id="逆变化">逆变化</h4>
<p><strong>模拟YPbPr转模拟 R′G′B′</strong> <span class="math display">$$
\begin{bmatrix}R'\\G'\\B'\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 0        &amp; 1.5748 \\
1 &amp; -0.21482  &amp; -0.38059 \\
1 &amp; 2.12798   &amp; 0
\end{bmatrix}
\begin{bmatrix}Y'\\C_B\\C_R\end{bmatrix}  
$$</span></p>
<h3 id="打包格式-1">打包格式</h3>
<p>RGB文件通常以每像素 8、12、16 或 24
位进行编码。下面的示例我们假定每个像素24bits，记作
RGB888。标准的字节顺序很简单： r0, g0, b0, r1, g1, b1, …</p>
<p>YCbCr 的打包像素格式往往被称为“YUV”。这类文件可以用 每像素 12、16 或
24 位编码。根据色度抽样不同，大致可描述为 4:2:0p、4:2:2、4:4:4。Y
后面的撇号（′）常被省略，YUV420p 里的
p（planar，平面）也常被省略。就实际文件格式而言，4:2:0
最常见，因为数据量更小，文件扩展名通常为
“.YUV”。数据率与抽样（A:B:C）之间的关系由 Y 与 U/V 通道采样数之比定义。
从 RGB 到 YUV
或相反方向转换，最简单是使用RGB888与4:4:4。对于4:1:1、4:2:2、4:2:0，需要先转换/重建到
4:4:4 再处理。</p>
<p><strong>4:4:4</strong></p>
<p>4:4:4
很直接，因为不分组像素；差别只在于每个通道分配多少位以及字节排列方式。基础的
YUV3 方案每像素用 3 字节，顺序为： y0, u0, v0, y1, u1, v1, … （这里用 u
代表 Cb、v 代表 Cr；以下相同。）</p>
<p><strong>4:1:1</strong></p>
<p>4:1:1 较少使用。像素按每 4 个水平分组。</p>
<p><strong>4:2:0</strong></p>
<p>4:2:0 使用极其广泛。主要格式有
IMC2、IMC4、YV12、NV12。这些格式都是平面型（planar），即把 Y、U、V
各自成片集中存放，而不是交错；在 8 位通道下总计每像素 12 位。</p>
<ul>
<li><p>NV12：可能是最常见的 8-bit 4:2:0 格式；Android
相机预览的默认格式。先写完整 Y 平面，然后写交织的色度行：U0, V0, U1, V1,
…</p></li>
<li><p>I420：更简单、也更常用。先写完整 Y 平面，再写完整 U
平面，最后写完整 V 平面。</p></li>
</ul>
<p><img src="/images/graphic/yuv420.svg.png" alt="yuv420" width="720"></p>
<ul>
<li><p>IMC2：先写完整的 Y 图；色度每行按 V0…Vn, U0…Un 排列，其中 n
为该行的色度采样数（等于 Y 宽度的一半）。</p></li>
<li><p>IMC4：与 IMC2 类似，但色度行顺序为 U0…Un, V0…Vn。</p></li>
<li><p>YV12：与 I420 相同，只是 U/V 平面的顺序对调。</p></li>
</ul>
<h1 id="gamma校正">Gamma校正</h1>
<p>在物理设备中，如CRT显示器。当我们将颜色的亮度调整高一倍时，设备并不会将输出的电压增加一倍。将输出的电压线性翻倍，显示器的亮度并不会线性的加倍，而是会大约按2.2的次方的指数关系加倍，这个指数关系被称为显示器的gamma。</p>
<p><span class="math display">$$\begin{aligned} L = V^{\gamma}，其中 γ ≈
2.2 \end{aligned}$$</span></p>
<p>下图能更高的解释这个现象，它对比了对人观察到的亮度的线性变化和物理上电压的线性变换对应的亮度。
<img src="/images/graphic/gamma_correction_brightness.png"></img>
因为人眼更符合上图中的第一个线性变换，所以直到今天显示器依然会使用一个幂函数来转换输出的颜色。</p>
<p>这个非线性转换更好的适配了我们的视觉，但是它带来了另一个渲染的问题：我们在显示器中观察到的颜色的强度变换实际上时非线性的。
如下图：
<img src="/images/graphic/gamma_correction_gamma_curves.png"><img>
其中的虚线是线性的表示颜色空间，实线是显示器以一种幂函数的显示颜色空间。举个例子：当我们有一个颜色(0.5,0.0,0.0),它代表一个半红色，当我们对它的色值翻一倍为（1.0,0.0,0.0）。它原始的颜色在显示器中其实为（0.218，0.0，0.0）翻倍后会比表示为（1.0，0.0，0.0）实际上显示器对他翻了约4.5倍。</p>
<p>所以我们在设计图形颜色，都假设我们是在线性空间中，其实在物理上是不正确的。</p>
<p>如果我们想让显示器显示半红（0.5,0.0,0.0）我们根据上面的图得到gamma假定时2.2，因为显示器是会给颜色值取2.2的次方。所以我们应该事先使用一个逆操作（gamma校正）对颜色进行校正，然后传递显示器。显示器最红又对这个值进行gamma变化，然后就真的显示我们的色值。</p>
<p><span
class="math display">(0.5, 0.0, 0.0)<sup>(</sup>1/2.2) = (0.5, 0.0, 0.0)<sup>0.45</sup> = (0.73, 0.0, 0.0)</span></p>
<p>然后把(0.73,0.0,0.0)传递给显示器。显示器然后进行转换:</p>
<p><span
class="math display">(0.73, 0.0, 0.0)<sup>2.0</sup> = (0.5, 0.0, 0.0)</span></p>
<h1 id="hsl和hsv色彩模型">HSL和HSV色彩模型</h1>
<p>HSL 和 HSV 是在 RGB
色彩模型中用来表示颜色点的两种最常见的圆柱坐标表示。与笛卡尔（立方体）表示相比，这两种表示通过重新组织
RGB 的几何结构，力图更直观、更符合人类感知。它们于 20 世纪 70
年代为计算机图形学应用所开发；如今广泛用于取色器、图像编辑软件，而在图像分析和计算机视觉中使用相对较少。
HSL 代表
Hue（色相）、Saturation（饱和度）、Lightness（明度），也常被写作 HLS。
HSV 代表 Hue（色相）、Saturation（饱和度）、Value（值），也常被称为
HSB（其中 B 指 Brightness，亮度）。 第三种在计算机视觉中常见的模型是
HSI，即 Hue（色相）、Saturation（饱和度）、Intensity（强度）。</p>
<p><img src="/images/graphic/color_hsl_hsv_models.svg.png" alt="hsl_hsv" width="720"></p>
<p>在这两种“圆柱体”模型中，绕中央垂直轴的角度对应“色相（hue）”，离轴心的距离对应“饱和度（saturation）”，沿轴向的位置对应“明度（lightness）”“值（value）或“亮度（brightness）”。需要注意的是，虽然
HSL 与 HSV
中的“色相”指的是同一属性，但它们对“饱和度”的定义差异很大。由于 HSL 与
HSV 都是对设备依赖的 RGB
模型做的简单变换，它们所定义的物理颜色取决于设备或特定 RGB
空间中红、绿、蓝三原色的具体颜色，以及用于表示这些原色分量大小的伽马校正。因此，每一台
RGB 设备都有其独特的 HSL 与 HSV 空间；相同的 HSL/HSV 数值在不同的基准
RGB 空间中会表示不同的颜色。</p>
<p>在这两种圆柱体几何中，围绕中央垂直轴的角度对应色相（hue）：从0°的红原色出发，经过120°的绿原色与240°的蓝原色，最后在
360°回到红。两种几何的中轴都由中性、无彩或灰色组成：自上而下从亮度
1（或值 1）的白到 亮度 0（或值 0）的黑。</p>
<p>在两种几何中，加色的原色与二次色——红、黄、绿、青、蓝、洋红——以及它们之间相邻成分的线性混合（有时称为纯色）都以饱和度
1排布在圆柱的外缘。这些饱和色在 HSL中的明度(lightness)为 0.5，而在 HSV
中的值(value)为 1。把这些纯色与黑混合（得到所谓的
shade，加黑）时，饱和度不变。在 HSL
中，与白混合（tint，加白）时饱和度也不变；只有同时与黑和白混合（tone，加灰）时，饱和度才会小于
1。而在 HSV 中，仅加白就会降低饱和度。</p>
<p>另外可以观察到，在HSL中他最顶部的整个区域都是白色、最底部整个区域都是黑色。HSV中最底部都是黑色。所以为了方便认为调色，它们还有另外一种表示方式：用双圆锥型表示HSL，用单圆锥表示HSV模型。</p>
<div class="img-row">
<p><img src="/images/graphic/color_hsl_cone.png" alt="hsl_cone" width="260">
<img src="/images/graphic/color_hsv_cone.png" alt="hsv_cone" width="260"></p>
</div>
<h2 id="色彩模型转换">色彩模型转换</h2>
<h3 id="rgb转hsl">RGB转HSL</h3>
<p><span class="math display">$$
\begin{aligned}
&amp;\textbf{归一化:}\quad
r=\frac{R}{255},\quad g=\frac{G}{255},\quad b=\frac{B}{255} \\[4pt]
&amp;\textbf{极值与差值:}\quad
C_{\max}=\max(r,g,b),\quad
C_{\min}=\min(r,g,b),\quad
\Delta=C_{\max}-C_{\min} \\[6pt]
&amp;\textbf{Lightness:}\quad
L=\frac{C_{\max}+C_{\min}}{2} \\[6pt]
&amp;\textbf{Saturation:}\quad
S=\begin{cases}
0, &amp; \Delta=0 \\[6pt]
\dfrac{\Delta}{1-\lvert 2L-1\rvert}, &amp; \Delta\neq 0
\end{cases} \\[10pt]
&amp;\textbf{Hue:}\quad
H=
\begin{cases}
0, &amp; \Delta=0 \\[6pt]
60^\circ\!\times\!\big((\tfrac{g-b}{\Delta})\bmod 6\big), &amp;
C_{\max}=r \\[8pt]
60^\circ\!\times\!\big(\tfrac{b-r}{\Delta}+2\big), &amp; C_{\max}=g
\\[8pt]
60^\circ\!\times\!\big(\tfrac{r-g}{\Delta}+4\big), &amp; C_{\max}=b
\end{cases}
\end{aligned}
$$</span></p>
<h3 id="rgb转hsv">RGB转HSV</h3>
<p><strong>先将RGB（假设8bit）归一化。</strong> <span
class="math display">$$
\begin{aligned}
&amp;\text{归一化：}\quad
r=\frac{R}{255},\quad g=\frac{G}{255},\quad b=\frac{B}{255} \\[4pt]
&amp;\text{极值与差值：}\quad
C_{\max}=\max(r,g,b),\;
C_{\min}=\min(r,g,b),\;
\Delta=C_{\max}-C_{\min}
\end{aligned}
$$</span></p>
<p><strong>Hue（色相）：</strong></p>
<p><span class="math display">$$
H=
\begin{cases}
0, &amp; \Delta=0 \\[6pt]
60^\circ\!\times\!\big((\frac{g-b}{\Delta})\bmod 6\big), &amp;
C_{\max}=r \\[8pt]
60^\circ\!\times\!\Big(\frac{b-r}{\Delta}+2\Big), &amp; C_{\max}=g
\\[8pt]
60^\circ\!\times\!\Big(\frac{r-g}{\Delta}+4\Big), &amp; C_{\max}=b
\end{cases}
$$</span></p>
<p><strong>Saturation（饱和度）：</strong></p>
<p><span class="math display">$$
S=
\begin{cases}
0, &amp; C_{\max}=0 \\[6pt]
\dfrac{\Delta}{C_{\max}}, &amp; C_{\max}\neq 0
\end{cases}
$$</span></p>
<p><strong>Value（明度）：</strong></p>
<p><span
class="math display"><em>V</em> = <em>C</em><sub>max</sub>.</span></p>
<h3 id="转换代码">转换代码</h3>
<h4 id="rgb转hsv-1">rgb转hsv</h4>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> rgb2hsv(<span class="type">vec3</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">-1.0</span>/<span class="number">3.0</span>, <span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> p = <span class="built_in">mix</span>(<span class="type">vec4</span>(c.bg, K.wz), <span class="type">vec4</span>(c.gb, K.xy), <span class="built_in">step</span>(c.b, c.g));</span><br><span class="line">    <span class="type">vec4</span> q = <span class="built_in">mix</span>(<span class="type">vec4</span>(p.xyw, c.r), <span class="type">vec4</span>(c.r, p.yzx), <span class="built_in">step</span>(p.x, c.r));</span><br><span class="line">    <span class="type">float</span> d = q.x - <span class="built_in">min</span>(q.w, q.y);</span><br><span class="line">    <span class="type">float</span> e = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(<span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e)), d / (q.x + e), q.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> hsv2rgb(<span class="type">vec3</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">1.0</span>, <span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">1.0</span>/<span class="number">3.0</span>, <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">vec3</span> p = <span class="built_in">abs</span>(<span class="built_in">fract</span>(c.xxx + K.xyz) * <span class="number">6.0</span> - K.www);</span><br><span class="line">    <span class="keyword">return</span> c.z * <span class="built_in">mix</span>(K.xxx, <span class="built_in">clamp</span>(p - K.xxx, <span class="number">0.0</span>, <span class="number">1.0</span>), c.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="rgb转hls">rgb转hls</h4>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> rgb2hls(<span class="type">vec3</span> c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> K = <span class="type">vec4</span>(<span class="number">0.0</span>, <span class="number">-1.0</span>/<span class="number">3.0</span>, <span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">-1.0</span>);</span><br><span class="line">    <span class="type">vec4</span> p = <span class="built_in">mix</span>(<span class="type">vec4</span>(c.bg, K.wz), <span class="type">vec4</span>(c.gb, K.xy), <span class="built_in">step</span>(c.b, c.g));</span><br><span class="line">    <span class="type">vec4</span> q = <span class="built_in">mix</span>(<span class="type">vec4</span>(p.xyw, c.r), <span class="type">vec4</span>(c.r, p.yzx), <span class="built_in">step</span>(p.x, c.r));</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> Cmax = q.x;</span><br><span class="line">    <span class="type">float</span> Cmin = <span class="built_in">min</span>(q.w, q.y);</span><br><span class="line">    <span class="type">float</span> d    = Cmax - Cmin;           <span class="comment">// Δ (chroma)</span></span><br><span class="line">    <span class="type">float</span> L    = <span class="number">0.5</span> * (Cmax + Cmin);   <span class="comment">// HLS 的 Lightness</span></span><br><span class="line">    <span class="type">float</span> e    = <span class="number">1.0e-10</span>;</span><br><span class="line">    <span class="type">float</span> H = <span class="built_in">abs</span>(q.z + (q.w - q.y) / (<span class="number">6.0</span> * d + e));</span><br><span class="line">    <span class="type">float</span> S = d / (<span class="number">1.0</span> - <span class="built_in">abs</span>(<span class="number">2.0</span> * L - <span class="number">1.0</span>) + e);</span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec3</span>(H, L, S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> hls2rgb(<span class="type">vec3</span> hls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> H = hls.x;</span><br><span class="line">    <span class="type">float</span> L = hls.y;</span><br><span class="line">    <span class="type">float</span> S = hls.z;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> C = (<span class="number">1.0</span> - <span class="built_in">abs</span>(<span class="number">2.0</span> * L - <span class="number">1.0</span>)) * S;</span><br><span class="line">    <span class="type">vec3</span> t = <span class="built_in">clamp</span>(<span class="built_in">abs</span>(<span class="built_in">mod</span>(H * <span class="number">6.0</span> + <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>), <span class="number">6.0</span>) - <span class="number">3.0</span>) - <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">return</span> L + C * (t - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">blueberry · All rights reserved.</span>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
